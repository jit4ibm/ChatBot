'use strict';

var llm_cjs = require('../../llms/llm.cjs');
var base_cjs = require('../../llms/base.cjs');
var nodeSdk = require('@ibm-generative-ai/node-sdk');
var R = require('remeda');
var errors_cjs = require('../../errors.cjs');
var decoratorCache_cjs = require('../../cache/decoratorCache.cjs');
var stream_cjs = require('../../internals/helpers/stream.cjs');
var utils_cjs = require('../../serializer/utils.cjs');
var number_cjs = require('../../internals/helpers/number.cjs');
var object_cjs = require('../../internals/helpers/object.cjs');
var emitter_cjs = require('../../emitter/emitter.cjs');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var R__namespace = /*#__PURE__*/_interopNamespace(R);

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate, "_ts_decorate");
function _ts_metadata(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
}
__name(_ts_metadata, "_ts_metadata");
class BAMLLMOutput extends base_cjs.BaseLLMOutput {
  static {
    __name(this, "BAMLLMOutput");
  }
  meta;
  results;
  moderations;
  constructor(content) {
    super();
    this.meta = content.meta;
    this.results = content.results;
    this.moderations = R__namespace.isArray(content.moderations) ? content.moderations : [
      content.moderations
    ].filter(R__namespace.isDefined);
  }
  static {
    this.register();
  }
  getTextContent() {
    return this.finalResult.generated_text;
  }
  get finalModeration() {
    return BAMLLMOutput._combineModerations(...this.moderations, this.finalResult.moderations);
  }
  get finalResult() {
    if (this.results.length === 0) {
      throw new base_cjs.LLMOutputError("No chunks to get final result from!");
    }
    return object_cjs.customMerge(this.results, {
      generated_text: /* @__PURE__ */ __name((value = "", oldValue = "") => oldValue + value, "generated_text"),
      input_token_count: number_cjs.safeSum,
      generated_token_count: number_cjs.safeSum,
      input_text: /* @__PURE__ */ __name((value, oldValue) => value ?? oldValue, "input_text"),
      generated_tokens: /* @__PURE__ */ __name((value, oldValue) => [
        ...value || [],
        ...oldValue || []
      ], "generated_tokens"),
      seed: /* @__PURE__ */ __name((value, oldValue) => value ?? oldValue, "seed"),
      stop_reason: /* @__PURE__ */ __name((value, oldValue) => value ?? oldValue, "stop_reason"),
      stop_sequence: /* @__PURE__ */ __name((value, oldValue) => value ?? oldValue, "stop_sequence"),
      input_tokens: /* @__PURE__ */ __name((value, oldValue) => value ?? oldValue, "input_tokens"),
      moderations: /* @__PURE__ */ __name((value, oldValue) => value && oldValue ? BAMLLMOutput._combineModerations(oldValue, value) : value ?? oldValue, "moderations")
    });
  }
  merge(other) {
    decoratorCache_cjs.Cache.getInstance(this, "finalResult").clear();
    this.results.push(...other.results);
    this.moderations.push(...other.moderations);
    Object.assign(this.meta, object_cjs.omitUndefined(other.meta));
  }
  createSnapshot() {
    return {
      results: utils_cjs.shallowCopy(this.results),
      moderations: utils_cjs.shallowCopy(this.moderations),
      meta: utils_cjs.shallowCopy(this.meta)
    };
  }
  loadSnapshot(snapshot) {
    Object.assign(this, snapshot);
  }
  toString() {
    return this.getTextContent();
  }
  static _combineModerations(...entries) {
    const newModerations = {};
    for (const entry of entries) {
      for (const [key, records] of R__namespace.entries(entry ?? {})) {
        if (R__namespace.isEmpty(records)) {
          continue;
        }
        if (!newModerations[key]) {
          newModerations[key] = [];
        }
        newModerations[key].push(...records);
      }
    }
    return newModerations;
  }
}
_ts_decorate([
  decoratorCache_cjs.Cache(),
  _ts_metadata("design:type", typeof Readonly === "undefined" ? Object : Readonly),
  _ts_metadata("design:paramtypes", [])
], BAMLLMOutput.prototype, "finalResult", null);
class BAMLLM extends llm_cjs.LLM {
  static {
    __name(this, "BAMLLM");
  }
  emitter = emitter_cjs.Emitter.root.child({
    namespace: [
      "bam",
      "llm"
    ],
    creator: this
  });
  client;
  parameters;
  constructor({ client, parameters, modelId, cache, executionOptions = {} }) {
    super(modelId, executionOptions, cache);
    this.client = client ?? new nodeSdk.Client();
    this.parameters = parameters ?? {};
  }
  static {
    this.register();
  }
  async meta() {
    try {
      const { result } = await this.client.model.retrieve({
        id: this.modelId
      });
      const tokenLimit = result.token_limits?.find?.((limit) => {
        if (this.parameters?.beam_width !== void 0) {
          return limit.token_limit !== void 0 && limit.beam_width === this.parameters.beam_width;
        }
        return limit.token_limit !== void 0;
      });
      return {
        tokenLimit: tokenLimit?.token_limit ?? Infinity
      };
    } catch {
      if (this.modelId === "meta-llama/llama-3-1-70b-instruct") {
        return {
          tokenLimit: 131072
        };
      } else if (this.modelId.includes("llama-3-70b-instruct")) {
        return {
          tokenLimit: 8196
        };
      }
      return {
        tokenLimit: Infinity
      };
    }
  }
  async embed(input, options) {
    const maxEmbeddingInputs = 20;
    const results = await Promise.all(R.chunk(input, maxEmbeddingInputs).map(async (texts) => {
      const response = await this.client.text.embedding.create({
        model_id: this.modelId,
        input: texts,
        parameters: {
          truncate_input_tokens: true
        }
      }, {
        signal: options?.signal
      });
      if (response.results?.length !== texts.length) {
        throw new Error("Missing embedding");
      }
      return response.results.map((result) => result.embedding);
    }));
    return {
      embeddings: results.flat()
    };
  }
  createSnapshot() {
    return {
      ...super.createSnapshot(),
      client: null,
      modelId: this.modelId,
      parameters: utils_cjs.shallowCopy(this.parameters),
      executionOptions: utils_cjs.shallowCopy(this.executionOptions)
    };
  }
  loadSnapshot(snapshot) {
    super.loadSnapshot(snapshot);
    Object.assign(this, snapshot, {
      client: snapshot?.client ?? new nodeSdk.Client()
    });
  }
  // TODO: serialize?
  _transformError(error) {
    if (error instanceof errors_cjs.FrameworkError) {
      throw error;
    }
    if (error instanceof nodeSdk.HttpError) {
      throw new base_cjs.LLMError("LLM has occurred an error!", [
        error
      ], {
        isRetryable: [
          408,
          425,
          429,
          500,
          503
        ].includes(error.status_code)
      });
    }
    return new base_cjs.LLMError("LLM has occurred an error!", [
      error
    ]);
  }
  async tokenize(input) {
    try {
      const { results: [result] } = await this.client.text.tokenization.create({
        input,
        model_id: this.modelId,
        parameters: {
          return_options: {
            tokens: true
          }
        }
      });
      return {
        tokensCount: result.token_count,
        tokens: result.tokens
      };
    } catch (e) {
      throw this._transformError(e);
    }
  }
  async _generate(input, options, run) {
    try {
      const response = await this.client.text.generation.create({
        input,
        moderations: options?.moderations,
        model_id: this.modelId,
        parameters: this._prepareParameters(options)
      }, {
        signal: run.signal
      });
      return this._rawResponseToOutput(response);
    } catch (e) {
      throw this._transformError(e);
    }
  }
  async *_stream(input, options, run) {
    try {
      const response = await this.client.text.generation.create_stream({
        input,
        moderations: options?.moderations,
        model_id: this.modelId,
        parameters: this._prepareParameters(options)
      }, {
        signal: run.signal
      });
      yield* stream_cjs.transformAsyncIterable(response[Symbol.asyncIterator](), this._rawResponseToOutput.bind(this));
    } catch (e) {
      throw this._transformError(e);
    }
  }
  _rawResponseToOutput(raw) {
    const chunks = raw.results ?? [];
    return new BAMLLMOutput({
      results: chunks,
      moderations: raw?.moderations,
      meta: R__namespace.pickBy({
        id: raw.id,
        model_id: raw.model_id,
        created_at: raw.created_at,
        input_parameters: raw.input_parameters
      }, R__namespace.isDefined)
    });
  }
  _prepareParameters(overrides) {
    const guided = object_cjs.omitUndefined(overrides?.guided ? {} : this.parameters.guided ?? {});
    const guidedOverride = object_cjs.omitUndefined(overrides?.guided ?? {});
    if (guidedOverride?.choice) {
      guided.choice = guidedOverride.choice;
    } else if (guidedOverride?.grammar) {
      guided.grammar = guidedOverride.grammar;
    } else if (guidedOverride?.json) {
      guided.json_schema = R.isString(guidedOverride.json) ? JSON.parse(guidedOverride.json) : guidedOverride.json;
    } else if (guidedOverride?.regex) {
      guided.regex = guidedOverride.regex;
    } else if (!R.isEmpty(guidedOverride ?? {})) {
      throw new errors_cjs.NotImplementedError(`Following types ${Object.keys(overrides.guided).join(",")}" for the constraint decoding are not supported!`);
    }
    return {
      ...this.parameters,
      guided: R.isEmpty(guided) ? void 0 : guided
    };
  }
}

exports.BAMLLM = BAMLLM;
exports.BAMLLMOutput = BAMLLMOutput;
//# sourceMappingURL=llm.cjs.map
//# sourceMappingURL=llm.cjs.map