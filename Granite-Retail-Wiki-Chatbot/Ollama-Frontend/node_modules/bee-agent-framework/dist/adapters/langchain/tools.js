import { Tool, JSONToolOutput } from '../../tools/base.js';
import { ZodEffects } from 'zod';
import * as LCTools from '@langchain/core/tools';
import { Serializer } from '../../serializer/serializer.js';
import { toCamelCase, pickBy, pick, isTruthy } from 'remeda';
import { toJsonSchema } from '../../internals/helpers/schema.js';
import { getProp } from '../../internals/helpers/object.js';
import { Emitter } from '../../emitter/emitter.js';

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
class LangChainTool extends Tool {
  static {
    __name(this, "LangChainTool");
  }
  tool;
  static serializedSchemaKey = "_internalJsonSchema";
  emitter;
  constructor({ tool, ...options }) {
    super(options);
    this.tool = tool;
    this.name = tool.name;
    this.description = tool.description;
    this.emitter = Emitter.root.child({
      namespace: [
        "tool",
        "langchain",
        toCamelCase(this.name)
      ],
      creator: this
    });
  }
  static {
    this.register();
    for (const Class of [
      LCTools.DynamicTool,
      LCTools.DynamicStructuredTool
    ]) {
      Serializer.register(Class, {
        toPlain: /* @__PURE__ */ __name((instance) => ({
          options: pickBy({
            ...pick(instance, [
              "name",
              "description",
              "metadata",
              "responseFormat",
              "returnDirect",
              "func"
            ]),
            schema: instance.schema instanceof ZodEffects ? toJsonSchema(instance.schema.sourceType()) : toJsonSchema(instance.schema)
          }, isTruthy)
        }), "toPlain"),
        fromPlain: /* @__PURE__ */ __name(({ options }) => {
          return new Class({
            ...options,
            metadata: {
              ...options?.metadata,
              [LangChainTool.serializedSchemaKey]: options.schema
            }
          });
        }, "fromPlain")
      });
    }
  }
  inputSchema() {
    const { schema, metadata = {} } = this.tool;
    return getProp(metadata, [
      LangChainTool.serializedSchemaKey
    ], schema instanceof ZodEffects ? schema.sourceType() : schema);
  }
  async _run(arg, options, run) {
    const { outputClass = JSONToolOutput } = this.options;
    const raw = await this.tool.invoke(arg, {
      ...options,
      signal: run.signal
    });
    return new outputClass(raw);
  }
  createSnapshot() {
    return {
      ...super.createSnapshot(),
      tool: this.tool
    };
  }
  loadSnapshot({ tool, ...snapshot }) {
    super.loadSnapshot(snapshot);
    this.tool = tool;
  }
}

export { LangChainTool };
//# sourceMappingURL=tools.js.map
//# sourceMappingURL=tools.js.map