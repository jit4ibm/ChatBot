{"version":3,"sources":["../../src/instrumentation/create-telemetry-middleware.ts"],"names":["createTelemetryMiddleware","context","emitter","trace","id","FrameworkError","traceId","activeTracesMap","has","set","instance","constructor","name","instrumentationLogger","debug","source","runParams","basePath","createFullPath","namespace","prompt","BaseAgent","spansMap","Map","parentIdsMap","spansToDeleteMap","generatedMessage","undefined","history","groupIterations","idNameManager","IdNameManager","newTokenEventName","partialUpdateEventName","successEventName","finishEventName","startEventName","errorEventName","eventsIterationsMap","startTimeDate","Date","getTime","startTimePerf","performance","now","convertDateToPerformance","date","serializer","traceSerializer","ignored_keys","INSTRUMENTATION_IGNORED_KEYS","cleanSpanSources","spanId","parentId","get","parent_id","spanCount","delete","match","event","path","_","meta","findLast","memory","messages","message","role","Role","USER","text","buildTraceTree","spans","JSON","parse","Array","from","values","version","Version","runErrorSpanKey","startTime","endTime","e","warn","data","includes","runId","groupId","parentRunId","createSpan","target","startedAt","createdAt","push","parentSpanId","getIds","serializedData","getSerializedObjectSafe","isEmpty","span","parent","ctx","error","getErrorSafe","lastIteration","length","lastIterationOnNewTokenSpanId","lastIterationEventSpanId","attributes","isDeepEqual","span_id","creator","dataObject","map","msg","assertLLMWithMessagesToPromptFn","input","rawPrompt","messagesToPrompt","createSnapshot"],"mappings":"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","file":"create-telemetry-middleware.js","sourcesContent":["/**\n * Copyright 2024 IBM Corp.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getSerializedObjectSafe } from \"./helpers/get-serialized-object-safe.js\";\nimport { createSpan } from \"./helpers/create-span.js\";\nimport { IdNameManager } from \"./helpers/id-name-manager.js\";\nimport { getErrorSafe } from \"./helpers/get-error-safe.js\";\nimport { findLast, isDeepEqual, isEmpty } from \"remeda\";\nimport type { BeeCallbacks } from \"@/agents/bee/types.js\";\nimport type { InferCallbackValue } from \"@/emitter/types.js\";\nimport { type BaseLLMEvents } from \"@/llms/base.js\";\nimport { FrameworkError } from \"@/errors.js\";\nimport { Version } from \"@/version.js\";\nimport { Role } from \"@/llms/primitives/message.js\";\nimport type { GetRunContext, RunInstance } from \"@/context.js\";\nimport type { GeneratedResponse, FrameworkSpan } from \"./types.js\";\nimport { activeTracesMap, buildTraceTree } from \"./tracer.js\";\nimport { traceSerializer } from \"./helpers/trace-serializer.js\";\nimport { INSTRUMENTATION_IGNORED_KEYS } from \"./config.js\";\nimport { createFullPath } from \"@/emitter/utils.js\";\nimport type { BeeAgent } from \"@/agents/bee/agent.js\";\nimport { instrumentationLogger } from \"./logger.js\";\nimport { BaseAgent } from \"@/agents/base.js\";\nimport { assertLLMWithMessagesToPromptFn } from \"./helpers/utils.js\";\n\nexport function createTelemetryMiddleware() {\n  return (context: GetRunContext<RunInstance, unknown>) => {\n    if (!context.emitter?.trace?.id) {\n      throw new FrameworkError(`Fatal error. Missing traceId`, [], { context });\n    }\n\n    const traceId = context.emitter?.trace?.id;\n    if (activeTracesMap.has(traceId)) {\n      return;\n    }\n    activeTracesMap.set(traceId, context.instance.constructor.name);\n\n    instrumentationLogger.debug(\n      {\n        source: context.instance.constructor.name,\n        traceId: traceId,\n      },\n      \"createTelemetryMiddleware\",\n    );\n    const { emitter, runParams, instance } = context;\n    const basePath = createFullPath(emitter.namespace, \"\");\n\n    let prompt: string | undefined | null = null;\n    if (instance instanceof BaseAgent) {\n      prompt = (runParams as Parameters<BeeAgent[\"run\"]>)[0].prompt;\n    }\n\n    const spansMap = new Map<string, FrameworkSpan>();\n    const parentIdsMap = new Map<string, number>();\n    const spansToDeleteMap = new Map<string, undefined>();\n\n    let generatedMessage: GeneratedResponse | undefined = undefined;\n    let history: GeneratedResponse[] | undefined = undefined;\n    const groupIterations: string[] = [];\n\n    const idNameManager = new IdNameManager();\n\n    const newTokenEventName: keyof BaseLLMEvents = `newToken`;\n    const partialUpdateEventName: keyof BeeCallbacks = \"partialUpdate\";\n    const successEventName: keyof BaseLLMEvents = `success`;\n    const finishEventName: keyof BaseLLMEvents = `finish`;\n    const startEventName: keyof BaseLLMEvents = `start`;\n    const errorEventName: keyof BaseLLMEvents = `error`;\n\n    const eventsIterationsMap = new Map<string, Map<string, string>>();\n\n    const startTimeDate = new Date().getTime();\n    const startTimePerf = performance.now();\n    function convertDateToPerformance(date: Date) {\n      return date.getTime() - startTimeDate + startTimePerf;\n    }\n\n    const serializer = traceSerializer({ ignored_keys: INSTRUMENTATION_IGNORED_KEYS });\n\n    function cleanSpanSources({ spanId }: { spanId: string }) {\n      const parentId = spansMap.get(spanId)?.parent_id;\n      if (!parentId) {\n        return;\n      }\n\n      const spanCount = parentIdsMap.get(parentId);\n      if (!spanCount) {\n        return;\n      }\n\n      if (spanCount > 1) {\n        // increase the span count for the parentId\n        parentIdsMap.set(parentId, spanCount - 1);\n      } else if (spanCount === 1) {\n        parentIdsMap.delete(parentId);\n        // check the `spansToDelete` if the span should be deleted when it has no children's\n        if (spansToDeleteMap.has(parentId)) {\n          spansMap.delete(parentId);\n          spansToDeleteMap.delete(parentId);\n        }\n      }\n    }\n\n    /**\n     * Create OpenTelemetry spans from collected data\n     */\n    emitter.match(\n      (event) => event.path === `${basePath}.run.${finishEventName}`,\n      async (_, meta) => {\n        try {\n          instrumentationLogger.debug({ path: meta.path, traceId: traceId }, \"run finish event\");\n\n          if (!prompt && instance instanceof BaseAgent) {\n            prompt = findLast(\n              instance.memory.messages,\n              (message) => message.role === Role.USER,\n            )?.text;\n\n            if (!prompt) {\n              throw new FrameworkError(\"The prompt must be defined for the Agent's run\", [], {\n                context,\n              });\n            }\n          }\n\n          // create tracer spans from collected data\n          buildTraceTree({\n            prompt: prompt,\n            history,\n            generatedMessage,\n            spans: JSON.parse(serializer(Array.from(spansMap.values()))),\n            traceId,\n            version: Version,\n            runErrorSpanKey: `${basePath}.run.${errorEventName}`,\n            startTime: startTimePerf,\n            endTime: performance.now(),\n            source: activeTracesMap.get(traceId)!,\n          });\n        } catch (e) {\n          instrumentationLogger.warn(e, \"Instrumentation error\");\n        } finally {\n          activeTracesMap.delete(traceId);\n        }\n      },\n    );\n\n    /**\n     * This block collects all \"not run category\" events with their data and prepares spans for the OpenTelemetry.\n     * The huge number of `newToken` events are skipped and only the last one for each parent event is saved because of `generated_token_count` information\n     * The framework event tree structure is different from the open-telemetry tree structure and must be transformed from groupId and parentGroupId pattern via idNameManager\n     * The artificial \"iteration\" main tree level is computed from the `meta.groupId`\n     */\n    emitter.match(\"*.*\", (data, meta) => {\n      // allow `run.error` event due to the runtime error information\n      if (meta.path.includes(\".run.\") && meta.path !== `${basePath}.run.${errorEventName}`) {\n        return;\n      }\n      if (!meta.trace?.runId) {\n        throw new FrameworkError(`Fatal error. Missing runId for event: ${meta.path}`, [], {\n          context,\n        });\n      }\n\n      /**\n       * create groupId span level (id does not exist)\n       * I use only the top-level groups like iterations other nested groups like tokens would introduce unuseful complexity\n       */\n      if (meta.groupId && !meta.trace.parentRunId && !groupIterations.includes(meta.groupId)) {\n        spansMap.set(\n          meta.groupId,\n          createSpan({\n            id: meta.groupId,\n            name: meta.groupId,\n            target: \"groupId\",\n            startedAt: convertDateToPerformance(meta.createdAt),\n          }),\n        );\n        groupIterations.push(meta.groupId);\n      }\n\n      const { spanId, parentSpanId } = idNameManager.getIds({\n        path: meta.path,\n        id: meta.id,\n        runId: meta.trace.runId,\n        parentRunId: meta.trace.parentRunId,\n        groupId: meta.groupId,\n      });\n\n      const serializedData = getSerializedObjectSafe(data);\n\n      // skip partialUpdate events with no data\n      if (meta.name === partialUpdateEventName && isEmpty(serializedData)) {\n        return;\n      }\n\n      const span = createSpan({\n        id: spanId,\n        name: meta.name,\n        target: meta.path,\n        ...(parentSpanId && { parent: { id: parentSpanId } }),\n        ctx: getSerializedObjectSafe(meta.context),\n        data: serializedData,\n        error: getErrorSafe(data),\n        startedAt: convertDateToPerformance(meta.createdAt),\n      });\n\n      const lastIteration = groupIterations[groupIterations.length - 1];\n\n      // delete the `newToken` event if exists and create the new one\n      const lastIterationOnNewTokenSpanId = eventsIterationsMap.get(lastIteration)?.get(meta.name);\n      if (lastIterationOnNewTokenSpanId && meta.name === newTokenEventName) {\n        // delete span\n        cleanSpanSources({ spanId: lastIterationOnNewTokenSpanId });\n        spansMap.delete(lastIterationOnNewTokenSpanId);\n      }\n\n      // delete the last `partialUpdate` event if the new one has same data and the original one does not have nested spans\n      const lastIterationEventSpanId = eventsIterationsMap.get(lastIteration)?.get(meta.name);\n      if (\n        lastIterationEventSpanId &&\n        partialUpdateEventName === meta.name &&\n        spansMap.has(lastIterationEventSpanId)\n      ) {\n        const { attributes, context } = spansMap.get(lastIterationEventSpanId)!;\n\n        if (isDeepEqual(serializedData, attributes.data)) {\n          if (parentIdsMap.has(context.span_id)) {\n            spansToDeleteMap.set(lastIterationEventSpanId, undefined);\n          } else {\n            // delete span\n            cleanSpanSources({ spanId: lastIterationEventSpanId });\n            spansMap.delete(lastIterationEventSpanId);\n          }\n        }\n      }\n\n      // create new span\n      spansMap.set(span.context.span_id, span);\n      // update number of nested spans for parent_id if exists\n      if (span.parent_id) {\n        parentIdsMap.set(span.parent_id, (parentIdsMap.get(span.parent_id) || 0) + 1);\n      }\n\n      // save the last event for each iteration\n      if (groupIterations.length > 0) {\n        if (eventsIterationsMap.has(lastIteration)) {\n          eventsIterationsMap.get(lastIteration)!.set(meta.name, span.context.span_id);\n        } else {\n          eventsIterationsMap.set(lastIteration, new Map().set(meta.name, span.context.span_id));\n        }\n      }\n    });\n\n    // The generated response and message history are collected from the `success` agent's event\n    emitter.match(\n      (event) => event.name === successEventName && event.creator instanceof BaseAgent,\n      (data: InferCallbackValue<BeeCallbacks[typeof successEventName]>) => {\n        const { data: dataObject, memory } = data;\n\n        generatedMessage = {\n          role: dataObject.role,\n          text: dataObject.text,\n        };\n        history = memory.messages.map((msg) => ({ text: msg.text, role: msg.role }));\n      },\n    );\n\n    // Read rawPrompt from llm input only for supported adapters and create the custom event with it\n    emitter.match(\n      (event) => assertLLMWithMessagesToPromptFn(event.creator) && event.name === startEventName,\n      ({ input }: InferCallbackValue<BaseLLMEvents[typeof startEventName]>, meta) => {\n        if (assertLLMWithMessagesToPromptFn(meta.creator) && meta.trace) {\n          const rawPrompt = meta.creator.messagesToPrompt(input);\n          // create a custom path to prevent event duplication\n          const path = `${meta.path}.custom`;\n\n          const { spanId, parentSpanId } = idNameManager.getIds({\n            path,\n            id: meta.id,\n            runId: meta.trace.runId,\n            parentRunId: meta.trace.parentRunId,\n            groupId: meta.groupId,\n          });\n\n          spansMap.set(\n            spanId,\n            createSpan({\n              id: spanId,\n              name: `${meta.name}Custom`,\n              target: path,\n              startedAt: convertDateToPerformance(meta.createdAt),\n              ...(parentSpanId && { parent: { id: parentSpanId } }),\n              data: {\n                rawPrompt,\n                creator: meta.creator.createSnapshot(),\n              },\n            }),\n          );\n        }\n      },\n    );\n  };\n}\n"]}