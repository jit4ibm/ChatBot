{"version":3,"sources":["../../src/cache/fileCache.ts"],"names":["FileCache","BaseCache","constructor","input","register","source","fullPath","fromProvider","provider","fs","promises","writeFile","serialize","getProvider","exists","stat","then","r","isFile","catch","serialized","readFile","target","snapshot","Serializer","deserialize","Target","getFactory","ref","instance","fromSnapshot","TypeError","SlidingCache","size","Infinity","ttl","reload","Cache","getInstance","clear","save","set","key","value","get","finally","has","delete","result","createSnapshot","loadSnapshot","Object","assign"],"mappings":"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","file":"fileCache.cjs","sourcesContent":["/**\n * Copyright 2024 IBM Corp.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { BaseCache } from \"@/cache/base.js\";\nimport fs from \"node:fs\";\nimport { SlidingCache } from \"@/cache/slidingCache.js\";\nimport { Cache } from \"@/cache/decoratorCache.js\";\nimport { Serializer } from \"@/serializer/serializer.js\";\nimport { SerializableClass } from \"@/internals/serializable.js\";\n\ninterface Input {\n  fullPath: string;\n}\n\nexport class FileCache<T> extends BaseCache<T> {\n  constructor(protected readonly input: Input) {\n    super();\n  }\n\n  static {\n    this.register();\n  }\n\n  get source() {\n    return this.input.fullPath;\n  }\n\n  static async fromProvider<A>(provider: BaseCache<A>, input: Input) {\n    await fs.promises.writeFile(input.fullPath, provider.serialize());\n    return new FileCache<A>(input);\n  }\n\n  @Cache()\n  protected async getProvider(): Promise<BaseCache<T>> {\n    const exists = await fs.promises\n      .stat(this.input.fullPath)\n      .then((r) => r.isFile())\n      .catch(() => false);\n\n    if (exists) {\n      const serialized = await fs.promises.readFile(this.input.fullPath, \"utf8\");\n      const { target, snapshot } = await Serializer.deserialize<any>(serialized);\n      const Target = Serializer.getFactory(target).ref as SerializableClass<BaseCache<T>>;\n      const instance = Target.fromSnapshot(snapshot);\n      if (!(instance instanceof BaseCache)) {\n        throw new TypeError(\"Provided file does not serialize any instance of BaseCache class.\");\n      }\n      return instance;\n    } else {\n      return new SlidingCache({\n        size: Infinity,\n        ttl: Infinity,\n      });\n    }\n  }\n\n  async reload() {\n    // @ts-expect-error protected property\n    Cache.getInstance(this, \"getProvider\").clear();\n    void (await this.getProvider());\n  }\n\n  protected async save() {\n    const provider = await this.getProvider();\n    return await fs.promises.writeFile(this.input.fullPath, provider.serialize());\n  }\n\n  async size() {\n    const provider = await this.getProvider();\n    return provider.size();\n  }\n\n  async set(key: string, value: T) {\n    const provider = await this.getProvider();\n    await provider.set(key, value);\n    void provider.get(key).finally(() => {\n      void this.save();\n    });\n  }\n\n  async get(key: string) {\n    const provider = await this.getProvider();\n    return await provider.get(key);\n  }\n\n  async has(key: string) {\n    const provider = await this.getProvider();\n    return await provider.has(key);\n  }\n\n  async delete(key: string) {\n    const provider = await this.getProvider();\n    const result = await provider.delete(key);\n    await this.save();\n    return result;\n  }\n\n  async clear() {\n    const provider = await this.getProvider();\n    await provider.clear();\n    await this.save();\n  }\n\n  async createSnapshot() {\n    return {\n      input: { fullPath: this.input.fullPath },\n      provider: await this.getProvider(),\n    };\n  }\n\n  loadSnapshot(snapshot: Awaited<ReturnType<typeof this.createSnapshot>>): void {\n    Object.assign(this, snapshot);\n  }\n}\n"]}