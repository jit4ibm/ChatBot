import { BaseCache } from './base.js';
import fs from 'node:fs';
import { SlidingCache } from './slidingCache.js';
import { Cache } from './decoratorCache.js';
import { Serializer } from '../serializer/serializer.js';

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate, "_ts_decorate");
function _ts_metadata(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
}
__name(_ts_metadata, "_ts_metadata");
class FileCache extends BaseCache {
  static {
    __name(this, "FileCache");
  }
  input;
  constructor(input) {
    super(), this.input = input;
  }
  static {
    this.register();
  }
  get source() {
    return this.input.fullPath;
  }
  static async fromProvider(provider, input) {
    await fs.promises.writeFile(input.fullPath, provider.serialize());
    return new FileCache(input);
  }
  async getProvider() {
    const exists = await fs.promises.stat(this.input.fullPath).then((r) => r.isFile()).catch(() => false);
    if (exists) {
      const serialized = await fs.promises.readFile(this.input.fullPath, "utf8");
      const { target, snapshot } = await Serializer.deserialize(serialized);
      const Target = Serializer.getFactory(target).ref;
      const instance = Target.fromSnapshot(snapshot);
      if (!(instance instanceof BaseCache)) {
        throw new TypeError("Provided file does not serialize any instance of BaseCache class.");
      }
      return instance;
    } else {
      return new SlidingCache({
        size: Infinity,
        ttl: Infinity
      });
    }
  }
  async reload() {
    Cache.getInstance(this, "getProvider").clear();
    void await this.getProvider();
  }
  async save() {
    const provider = await this.getProvider();
    return await fs.promises.writeFile(this.input.fullPath, provider.serialize());
  }
  async size() {
    const provider = await this.getProvider();
    return provider.size();
  }
  async set(key, value) {
    const provider = await this.getProvider();
    await provider.set(key, value);
    void provider.get(key).finally(() => {
      void this.save();
    });
  }
  async get(key) {
    const provider = await this.getProvider();
    return await provider.get(key);
  }
  async has(key) {
    const provider = await this.getProvider();
    return await provider.has(key);
  }
  async delete(key) {
    const provider = await this.getProvider();
    const result = await provider.delete(key);
    await this.save();
    return result;
  }
  async clear() {
    const provider = await this.getProvider();
    await provider.clear();
    await this.save();
  }
  async createSnapshot() {
    return {
      input: {
        fullPath: this.input.fullPath
      },
      provider: await this.getProvider()
    };
  }
  loadSnapshot(snapshot) {
    Object.assign(this, snapshot);
  }
}
_ts_decorate([
  Cache(),
  _ts_metadata("design:type", Function),
  _ts_metadata("design:paramtypes", []),
  _ts_metadata("design:returntype", Promise)
], FileCache.prototype, "getProvider", null);

export { FileCache };
//# sourceMappingURL=fileCache.js.map
//# sourceMappingURL=fileCache.js.map