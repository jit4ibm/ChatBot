'use strict';

var decoratorCache_cjs = require('../cache/decoratorCache.cjs');
var utils_cjs = require('./utils.cjs');
var errors_cjs = require('./errors.cjs');
var hash_cjs = require('../internals/helpers/hash.cjs');
var utils_cjs$1 = require('../serializer/utils.cjs');
var serializable_cjs = require('../internals/serializable.cjs');
var remeda = require('remeda');

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate, "_ts_decorate");
function _ts_metadata(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
}
__name(_ts_metadata, "_ts_metadata");
class Emitter extends serializable_cjs.Serializable {
  static {
    __name(this, "Emitter");
  }
  listeners = /* @__PURE__ */ new Set();
  groupId;
  namespace;
  creator;
  context;
  trace;
  constructor(input = {}) {
    super();
    this.groupId = input?.groupId;
    this.namespace = input?.namespace ?? [];
    this.creator = input.creator ?? Object.prototype;
    this.context = input?.context ?? {};
    this.trace = input.trace;
    utils_cjs.assertValidNamespace(this.namespace);
  }
  static {
    this.register();
  }
  static get root() {
    return new Emitter({
      creator: /* @__PURE__ */ Object.create(null)
    });
  }
  child(input = {}) {
    const child = new Emitter({
      trace: input.trace ?? this.trace,
      groupId: input?.groupId ?? this.groupId,
      context: {
        ...this.context,
        ...input?.context
      },
      creator: input?.creator ?? this.creator,
      namespace: input?.namespace ? [
        ...this.namespace,
        ...input.namespace
      ] : this.namespace.slice()
    });
    child.pipe(this);
    return child;
  }
  pipe(target) {
    return this.on(
      // @ts-expect-error
      "*.*",
      utils_cjs$1.toBoundedFunction(
        // @ts-expect-error
        (...args) => target.invoke(...args),
        [
          {
            value: target,
            name: "target"
          }
        ]
      ),
      {
        isBlocking: true,
        once: false,
        persistent: true
      }
    );
  }
  destroy() {
    this.listeners.clear();
  }
  reset() {
    for (const listener of this.listeners) {
      if (!listener.options?.persistent) {
        this.listeners.delete(listener);
      }
    }
  }
  registerCallbacks(callbacks, options) {
    const listeners = [];
    Object.entries(callbacks).forEach(([key, value]) => {
      if (value) {
        listeners.push(this.on(key, value, options?.[key]));
      }
    });
    return () => listeners.forEach((cleanup) => cleanup());
  }
  on(event, callback, options) {
    return this.match(event, callback, options);
  }
  match(matcher, callback, options) {
    const listener = {
      options,
      callback,
      raw: matcher,
      match: (() => {
        if (matcher === "*") {
          return (event) => event.path === utils_cjs.createFullPath(this.namespace, event.name);
        } else if (matcher === "*.*") {
          return () => true;
        } else if (matcher instanceof RegExp) {
          return (event) => matcher.test(event.path);
        } else if (typeof matcher === "function") {
          return matcher;
        } else if (typeof matcher === "string") {
          return utils_cjs.isPath(matcher) ? (event) => event.path === matcher : (event) => event.name === matcher && event.path === utils_cjs.createFullPath(this.namespace, event.name);
        } else {
          throw new errors_cjs.EmitterError("Invalid matcher provided!");
        }
      })()
    };
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  }
  async emit(name, value) {
    utils_cjs.assertValidName(name);
    const event = this.createEvent(name);
    return await this.invoke(value, event);
  }
  async invoke(data, event) {
    const executions = [];
    for (const listener of this.listeners.values()) {
      if (!listener.match(event)) {
        continue;
      }
      if (listener.options?.once) {
        this.listeners.delete(listener);
      }
      const run = /* @__PURE__ */ __name(async () => listener.callback(data, event), "run");
      executions.push(listener.options?.isBlocking ? await run() : run());
    }
    await Promise.all(executions);
  }
  createEvent(name) {
    return {
      id: hash_cjs.createRandomHash(),
      groupId: this.groupId,
      name,
      path: utils_cjs.createFullPath(this.namespace, name),
      createdAt: /* @__PURE__ */ new Date(),
      source: this,
      creator: this.creator,
      context: Object.assign({}, this.context, {}),
      // TODO: use createInStone
      trace: utils_cjs$1.shallowCopy(this.trace)
    };
  }
  // TODO
  createSnapshot() {
    return {
      groupId: this.groupId,
      namespace: utils_cjs$1.shallowCopy(this.namespace),
      creator: this.creator,
      context: this.context,
      trace: this.trace,
      listeners: Array.from(this.listeners).map(remeda.pick([
        "raw",
        "options",
        "callback"
      ]))
    };
  }
  loadSnapshot({ listeners, ...snapshot }) {
    Object.assign(this, snapshot, {
      listeners: /* @__PURE__ */ new Set()
    });
    listeners.forEach(({ raw, callback, options }) => this.match(raw, callback, options));
  }
}
_ts_decorate([
  decoratorCache_cjs.Cache(),
  _ts_metadata("design:type", void 0),
  _ts_metadata("design:paramtypes", [])
], Emitter, "root", null);

exports.Emitter = Emitter;
//# sourceMappingURL=emitter.cjs.map
//# sourceMappingURL=emitter.cjs.map