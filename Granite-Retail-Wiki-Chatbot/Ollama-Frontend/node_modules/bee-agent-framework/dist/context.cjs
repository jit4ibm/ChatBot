'use strict';

var node_async_hooks = require('node:async_hooks');
var hash_cjs = require('./internals/helpers/hash.cjs');
var remeda = require('remeda');
var object_cjs = require('./internals/helpers/object.cjs');
var cancellation_cjs = require('./internals/helpers/cancellation.cjs');
var serializable_cjs = require('./internals/serializable.cjs');
var promise_cjs = require('./internals/helpers/promise.cjs');
var errors_cjs = require('./errors.cjs');
var utils_cjs = require('./serializer/utils.cjs');

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
class Run extends promise_cjs.LazyPromise {
  static {
    __name(this, "Run");
  }
  runContext;
  tasks;
  constructor(handler, runContext) {
    super(handler), this.runContext = runContext, this.tasks = [], this[_Symbol_toStringTag] = "Promise";
  }
  [_Symbol_toStringTag = Symbol.toStringTag];
  observe(fn) {
    this.tasks.push(async () => fn(this.runContext.emitter));
    return this;
  }
  context(value) {
    this.tasks.push(async () => {
      Object.assign(this.runContext.context, value);
      Object.assign(this.runContext.emitter.context, value);
    });
    return this;
  }
  middleware(fn) {
    this.tasks.push(async () => fn(this.runContext));
    return this;
  }
  async before() {
    await super.before();
    await promise_cjs.executeSequentially(this.tasks.splice(0, Infinity));
  }
}
class RunContext extends serializable_cjs.Serializable {
  static {
    __name(this, "RunContext");
  }
  instance;
  input;
  static #storage = new node_async_hooks.AsyncLocalStorage();
  controller;
  runId;
  groupId;
  parentId;
  emitter;
  context;
  runParams;
  createdAt;
  get signal() {
    return this.controller.signal;
  }
  abort() {
    this.controller.abort();
  }
  constructor(instance, input, parent) {
    super(), this.instance = instance, this.input = input;
    this.createdAt = /* @__PURE__ */ new Date();
    this.runParams = input.params;
    this.runId = hash_cjs.createRandomHash(5);
    this.parentId = parent?.runId;
    this.groupId = parent?.groupId ?? hash_cjs.createRandomHash();
    this.context = object_cjs.createNonOverridableObject(remeda.omit(parent?.context ?? {}, [
      "id",
      "parentId"
    ]));
    this.controller = new AbortController();
    cancellation_cjs.registerSignals(this.controller, [
      input.signal,
      parent?.signal
    ]);
    this.emitter = instance.emitter.child({
      context: this.context,
      trace: {
        id: this.groupId,
        runId: this.runId,
        parentRunId: parent?.runId
      }
    });
    if (parent) {
      this.emitter.pipe(parent.emitter);
    }
  }
  destroy() {
    this.emitter.destroy();
    this.controller.abort(new errors_cjs.FrameworkError("Context destroyed."));
  }
  static enter(instance, input, fn) {
    const parent = RunContext.#storage.getStore();
    const runContext = new RunContext(instance, input, parent);
    return new Run(async () => {
      const emitter = runContext.emitter.child({
        namespace: [
          "run"
        ],
        creator: runContext,
        context: {
          internal: true
        }
      });
      try {
        await emitter.emit("start", null);
        const result = await Promise.race([
          RunContext.#storage.run(runContext, fn, runContext),
          new Promise((_, reject) => runContext.signal.addEventListener("abort", () => setTimeout(() => reject(runContext.signal.reason), 0)))
        ]);
        await emitter.emit("success", result);
        return result;
      } catch (_e) {
        const e = errors_cjs.FrameworkError.ensure(_e);
        await emitter.emit("error", e);
        throw e;
      } finally {
        await emitter.emit("finish", null);
        runContext.destroy();
      }
    }, runContext);
  }
  static {
    this.register();
  }
  createSnapshot() {
    return {
      controller: this.controller,
      runId: this.runId,
      groupId: this.groupId,
      parentId: this.parentId,
      emitter: this.emitter,
      context: utils_cjs.shallowCopy(this.context),
      runParams: utils_cjs.shallowCopy(this.runParams),
      createdAt: new Date(this.createdAt)
    };
  }
  loadSnapshot(snapshot) {
    Object.assign(this, snapshot);
  }
}
var _Symbol_toStringTag;

exports.Run = Run;
exports.RunContext = RunContext;
//# sourceMappingURL=context.cjs.map
//# sourceMappingURL=context.cjs.map