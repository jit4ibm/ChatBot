{"version":3,"sources":["../../src/llms/base.ts"],"names":["LLMError","FrameworkError","LLMFatalError","constructor","message","errors","isRetryable","isFatal","LLMOutputError","BaseLLMOutput","Serializable","mergeImmutable","other","newInstance","clone","merge","BaseLLM","modelId","executionOptions","cache","NullCache","generate","input","options","shallowCopy","RunContext","enter","params","signal","run","cacheEntry","createCacheAccessor","emitter","emit","stream","chunks","controller","createAbortController","tokenEmitter","child","groupId","chunk","value","_stream","aborted","push","callbacks","abort","result","_mergeChunks","resolve","at","pRetry","_generate","retries","maxRetries","error","reject","middleware","INSTRUMENTATION_ENABLED","createTelemetryMiddleware","doNothing","emitterToGenerator","length","reduce","prev","cur","cast","castInput","castOutput","createSnapshot","loadSnapshot","snapshot","Object","assign","extra","key","ObjectHashKeyFn","omit","get","isNew","undefined","task","Task","set","Array","isArray","delete"],"mappings":"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","file":"base.js","sourcesContent":["/**\n * Copyright 2024 IBM Corp.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FrameworkError } from \"@/errors.js\";\nimport { Serializable } from \"@/internals/serializable.js\";\nimport { createAbortController } from \"@/internals/helpers/cancellation.js\";\nimport { OneOf } from \"@/internals/types.js\";\nimport { Emitter } from \"@/emitter/emitter.js\";\nimport { GetRunContext, RunContext } from \"@/context.js\";\nimport { Callback } from \"@/emitter/types.js\";\nimport { shallowCopy } from \"@/serializer/utils.js\";\nimport { pRetry } from \"@/internals/helpers/retry.js\";\nimport { emitterToGenerator } from \"@/internals/helpers/promise.js\";\nimport { BaseCache } from \"@/cache/base.js\";\nimport { NullCache } from \"@/cache/nullCache.js\";\nimport { ObjectHashKeyFn } from \"@/cache/decoratorCache.js\";\nimport { doNothing, omit } from \"remeda\";\nimport { Task } from \"promise-based-task\";\nimport { INSTRUMENTATION_ENABLED } from \"@/instrumentation/config.js\";\nimport { createTelemetryMiddleware } from \"@/instrumentation/create-telemetry-middleware.js\";\n\nexport interface BaseLLMEvents<TInput = any, TOutput extends BaseLLMOutput = BaseLLMOutput> {\n  newToken?: Callback<{ value: TOutput; callbacks: { abort: () => void } }>;\n  success?: Callback<{ value: TOutput }>;\n  start?: Callback<{ input: TInput; options: unknown }>;\n  error?: Callback<{ input: TInput; error: FrameworkError; options: unknown }>;\n  finish?: Callback<null>;\n}\n\n/**\n * @deprecated Use BaseLLMEvents instead\n */\nexport type GenerateCallbacks = BaseLLMEvents;\n\nexport type GuidedOptions = OneOf<\n  [\n    {\n      json?: string | Record<string, any>;\n    },\n    {\n      regex?: string;\n    },\n    {\n      choice?: string[];\n    },\n    {\n      grammar?: string;\n    },\n    {\n      decoding_backend?: string;\n    },\n    {\n      whitespace_pattern?: string;\n    },\n  ]\n>;\n\nexport interface GenerateOptions {\n  stream?: boolean;\n  signal?: AbortSignal;\n  guided?: GuidedOptions;\n}\n\nexport interface InternalGenerateOptions {\n  signal?: AbortSignal;\n}\n\nexport interface StreamGenerateOptions {\n  signal?: AbortSignal;\n  guided?: GuidedOptions;\n}\n\nexport type AsyncStream<T, T2 = any> = AsyncGenerator<T, T2, any>;\n\nexport class LLMError extends FrameworkError {}\nexport class LLMFatalError extends LLMError {\n  constructor(message: string, errors?: Error[]) {\n    super(message, errors, {\n      isRetryable: false,\n      isFatal: true,\n    });\n  }\n}\nexport class LLMOutputError extends LLMFatalError {}\n\nexport interface BaseLLMTokenizeOutput {\n  tokensCount: number;\n  tokens?: string[];\n}\n\nexport abstract class BaseLLMOutput extends Serializable {\n  mergeImmutable<T extends BaseLLMOutput>(this: T, other: T): T {\n    const newInstance = this.clone() as T;\n    newInstance.merge(other);\n    return newInstance;\n  }\n\n  abstract merge(other: BaseLLMOutput): void;\n\n  abstract getTextContent(): string;\n\n  abstract toString(): string;\n}\n\nexport interface ExecutionOptions {\n  maxRetries?: number;\n}\n\nexport interface EmbeddingOptions {\n  signal?: AbortSignal;\n}\n\nexport interface EmbeddingOutput {\n  embeddings: number[][];\n}\n\nexport interface LLMMeta {\n  tokenLimit: number;\n}\n\nexport type LLMCache<T extends BaseLLMOutput> = BaseCache<Task<T[]>>;\n\nexport abstract class BaseLLM<\n  TInput,\n  TOutput extends BaseLLMOutput,\n  TGenerateOptions extends GenerateOptions = GenerateOptions,\n> extends Serializable<any> {\n  public abstract readonly emitter: Emitter<BaseLLMEvents<unknown, TOutput>>;\n\n  constructor(\n    public readonly modelId: string,\n    public readonly executionOptions: ExecutionOptions = {},\n    public readonly cache: LLMCache<TOutput> = new NullCache(),\n  ) {\n    super();\n  }\n\n  abstract meta(): Promise<LLMMeta>;\n\n  abstract embed(input: TInput[], options?: EmbeddingOptions): Promise<EmbeddingOutput>;\n\n  abstract tokenize(input: TInput): Promise<BaseLLMTokenizeOutput>;\n\n  generate(input: TInput, options: Partial<TGenerateOptions> = {}) {\n    input = shallowCopy(input);\n    options = shallowCopy(options);\n\n    return RunContext.enter(\n      this,\n      { params: [input, options] as const, signal: options?.signal },\n      async (run) => {\n        const cacheEntry = await this.createCacheAccessor(input, options);\n\n        try {\n          await run.emitter.emit(\"start\", { input, options });\n\n          if (options?.stream) {\n            const chunks: TOutput[] = [];\n            const controller = createAbortController(options?.signal);\n\n            const tokenEmitter = run.emitter.child({ groupId: \"tokens\" });\n            for await (const chunk of cacheEntry.value ??\n              this._stream(\n                input,\n                {\n                  ...options,\n                  signal: controller.signal,\n                },\n                run,\n              )) {\n              if (controller.signal.aborted) {\n                continue;\n              }\n\n              chunks.push(chunk);\n              await tokenEmitter.emit(\"newToken\", {\n                value: chunk,\n                callbacks: { abort: () => controller.abort() },\n              });\n            }\n\n            const result = this._mergeChunks(chunks);\n            await run.emitter.emit(\"success\", { value: result });\n            cacheEntry.resolve(chunks);\n            return result;\n          }\n\n          const result: TOutput =\n            cacheEntry?.value?.at(0) ||\n            (await pRetry(() => this._generate(input, options, run), {\n              retries: this.executionOptions.maxRetries || 0,\n              ...options,\n              signal: run.signal,\n            }));\n          await run.emitter.emit(\"success\", { value: result });\n          cacheEntry.resolve([result]);\n          return result;\n        } catch (error) {\n          await run.emitter.emit(\"error\", { input, error, options });\n          await cacheEntry.reject(error);\n          if (error instanceof LLMError) {\n            throw error;\n          } else {\n            throw new LLMError(`LLM has occurred an error.`, [error]);\n          }\n        } finally {\n          await run.emitter.emit(\"finish\", null);\n        }\n      },\n    ).middleware(INSTRUMENTATION_ENABLED ? createTelemetryMiddleware() : doNothing());\n  }\n\n  async *stream(input: TInput, options: Partial<StreamGenerateOptions> = {}): AsyncStream<TOutput> {\n    input = shallowCopy(input);\n    options = shallowCopy(options);\n\n    return yield* emitterToGenerator(async ({ emit }) => {\n      return RunContext.enter(\n        this,\n        { params: [input, options] as const, signal: options?.signal },\n        async (run) => {\n          const cacheEntry = await this.createCacheAccessor(input, options);\n\n          try {\n            await run.emitter.emit(\"start\", { input, options });\n\n            const tokenEmitter = run.emitter.child({ groupId: \"tokens\" });\n            const chunks: TOutput[] = [];\n            const controller = createAbortController(options?.signal);\n\n            for await (const chunk of cacheEntry.value ||\n              this._stream(input, { ...options, signal: controller.signal }, run)) {\n              if (controller.signal.aborted) {\n                continue;\n              }\n\n              chunks.push(chunk);\n              await tokenEmitter.emit(\"newToken\", {\n                value: chunk,\n                callbacks: { abort: () => controller.abort() },\n              });\n              emit(chunk);\n            }\n            const result = this._mergeChunks(chunks);\n            await run.emitter.emit(\"success\", { value: result });\n            cacheEntry.resolve(chunks);\n          } catch (error) {\n            await run.emitter.emit(\"error\", { input, error, options });\n            await cacheEntry.reject(error);\n            if (error instanceof LLMError) {\n              throw error;\n            } else {\n              throw new LLMError(`LLM has occurred an error.`, [error]);\n            }\n          } finally {\n            await run.emitter.emit(\"finish\", null);\n          }\n        },\n      ).middleware(INSTRUMENTATION_ENABLED ? createTelemetryMiddleware() : doNothing());\n    });\n  }\n\n  protected abstract _generate(\n    input: TInput,\n    options: Partial<TGenerateOptions>,\n    run: GetRunContext<typeof this>,\n  ): Promise<TOutput>;\n\n  protected abstract _stream(\n    input: TInput,\n    options: Partial<StreamGenerateOptions>,\n    run: GetRunContext<typeof this>,\n  ): AsyncStream<TOutput, void>;\n\n  protected _mergeChunks(chunks: TOutput[]): TOutput {\n    if (chunks.length === 0) {\n      throw new LLMOutputError(\"Cannot merge empty chunks!\");\n    }\n    return chunks.reduce((prev, cur) => prev.mergeImmutable(cur));\n  }\n\n  static cast<T extends BaseLLM<unknown, BaseLLMOutput>>(\n    this: new (...args: any[]) => T,\n    value: unknown,\n  ): asserts value is T {}\n\n  static castInput<A>(\n    this: new (...args: any[]) => BaseLLM<A, BaseLLMOutput>,\n    value: unknown,\n  ): asserts value is A {}\n\n  static castOutput<T extends BaseLLM<unknown, BaseLLMOutput>>(\n    this: new (...args: any[]) => T,\n    value: BaseLLMOutput,\n  ): asserts value is InferLLMOutput<T> {}\n\n  createSnapshot() {\n    return {\n      modelId: this.modelId,\n      executionOptions: shallowCopy(this.executionOptions),\n      emitter: this.emitter,\n      cache: this.cache,\n    };\n  }\n\n  loadSnapshot(snapshot: ReturnType<typeof this.createSnapshot>) {\n    Object.assign(this, snapshot);\n  }\n\n  protected async createCacheAccessor(\n    input: TInput,\n    options: Partial<GenerateOptions> | Partial<StreamGenerateOptions>,\n    ...extra: any[]\n  ) {\n    const key = ObjectHashKeyFn(input, omit(options ?? {}, [\"signal\"]), ...extra);\n    const value = await this.cache.get(key);\n    const isNew = value === undefined;\n\n    let task: Task<TOutput[]> | null = null;\n    if (isNew) {\n      task = new Task();\n      await this.cache.set(key, task);\n    }\n\n    return {\n      key,\n      value,\n      resolve: <T2 extends TOutput>(value: T2 | T2[]) => {\n        task?.resolve?.(Array.isArray(value) ? value : [value]);\n      },\n      reject: async (error: Error) => {\n        task?.reject?.(error);\n        if (isNew) {\n          await this.cache.delete(key);\n        }\n      },\n    };\n  }\n}\n\nexport type AnyLLM<I = string, T = BaseLLMOutput> = BaseLLM<I, T extends BaseLLMOutput ? T : never>;\nexport type InferLLMOutput<T> = T extends BaseLLM<any, infer A, any> ? A : never;\n"]}