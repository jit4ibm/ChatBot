import * as ajv from 'ajv';
import { ErrorObject } from 'ajv';
import { Run, GetRunContext, RunContext } from '../context.js';
import { FrameworkError } from '../errors.js';
import { Serializable } from '../internals/serializable.js';
import { Task } from 'promise-based-task';
import { BaseCache } from '../cache/base.js';
import { FromSchemaLike, FromSchemaLikeRaw, AnyToolSchemaLike } from '../internals/helpers/schema.js';
import { ZodSchema, z } from 'zod';
import { E as Emitter, C as Callback } from '../emitter-DRfJC1TP.js';
import '../internals/helpers/promise.js';
import '../internals/types.js';
import '../internals/helpers/guards.js';
import 'zod-to-json-schema';

declare class ToolError extends FrameworkError {
}
declare class ToolInputValidationError extends ToolError {
    validationErrors: ErrorObject[];
    constructor(message: string, validationErrors?: ErrorObject[]);
}
interface RetryOptions {
    maxRetries?: number;
    factor?: number;
}
interface BaseToolOptions<TOutput = any> {
    retryOptions?: RetryOptions;
    fatalErrors?: ErrorConstructor[];
    cache?: BaseCache<Task<TOutput>> | false;
}
interface BaseToolRunOptions {
    retryOptions?: RetryOptions;
    signal?: AbortSignal;
}
declare abstract class ToolOutput extends Serializable {
    abstract getTextContent(): string;
    abstract isEmpty(): boolean;
    toString(): string;
}
declare class StringToolOutput extends ToolOutput {
    readonly result: string;
    readonly ctx?: Record<string, any> | undefined;
    constructor(result?: string, ctx?: Record<string, any> | undefined);
    isEmpty(): boolean;
    getTextContent(): string;
    createSnapshot(): {
        result: string;
        ctx: Record<string, any> | undefined;
    };
    loadSnapshot(snapshot: ReturnType<typeof this.createSnapshot>): void;
}
declare class JSONToolOutput<T> extends ToolOutput {
    readonly result: T;
    readonly ctx?: Record<string, any> | undefined;
    constructor(result: T, ctx?: Record<string, any> | undefined);
    isEmpty(): boolean;
    getTextContent(): string;
    createSnapshot(): {
        result: T;
        ctx: Record<string, any> | undefined;
    };
    loadSnapshot(snapshot: ReturnType<typeof this.createSnapshot>): void;
}
interface ToolSnapshot<TOutput extends ToolOutput, TOptions extends BaseToolOptions> {
    name: string;
    description: string;
    options: TOptions;
    cache: BaseCache<Task<TOutput>>;
    emitter: Emitter<any>;
}
type InferToolOutput<T extends AnyTool> = T extends Tool<infer A, any, any> ? A : never;
type ToolInput<T extends AnyTool> = FromSchemaLike<Awaited<ReturnType<T["inputSchema"]>>>;
type ToolInputRaw<T extends AnyTool> = FromSchemaLikeRaw<Awaited<ReturnType<T["inputSchema"]>>>;
type ToolConstructorParameters<TOptions extends BaseToolOptions> = Partial<TOptions> extends TOptions ? [options?: TOptions] : [options: TOptions];
interface ToolEvents<TInput extends Record<string, any> = Record<string, any>, TOutput extends ToolOutput = ToolOutput> {
    start: Callback<{
        input: TInput;
        options: unknown;
    }>;
    success: Callback<{
        output: TOutput;
        input: TInput;
        options: unknown;
    }>;
    error: Callback<{
        input: TInput;
        error: ToolError | ToolInputValidationError;
        options: unknown;
    }>;
    retry: Callback<{
        error: ToolError | ToolInputValidationError;
        input: TInput;
        options: unknown;
    }>;
    finish: Callback<null>;
}
/**
 * @deprecated Use ToolEmitter instead
 */
type CustomToolEmitter<A extends Record<string, any>, B extends ToolOutput, C = Record<never, never>> = Emitter<ToolEvents<A, B> & Omit<C, keyof ToolEvents>>;
type ToolEmitter<A extends Record<string, any>, B extends ToolOutput, C = Record<never, never>> = Emitter<ToolEvents<A, B> & Omit<C, keyof ToolEvents>>;
declare abstract class Tool<TOutput extends ToolOutput = ToolOutput, TOptions extends BaseToolOptions = BaseToolOptions, TRunOptions extends BaseToolRunOptions = BaseToolRunOptions> extends Serializable {
    abstract name: string;
    abstract description: string;
    readonly cache: BaseCache<Task<TOutput>>;
    readonly options: TOptions;
    static contextKeys: {
        readonly Memory: symbol;
    };
    abstract readonly emitter: Emitter<ToolEvents<any, TOutput>>;
    abstract inputSchema(): Promise<AnyToolSchemaLike> | AnyToolSchemaLike;
    constructor(...args: ToolConstructorParameters<TOptions>);
    protected toError(e: Error, context: any): ToolError;
    run(input: ToolInputRaw<this>, options?: Partial<TRunOptions>): Run<TOutput, this, readonly [FromSchemaLikeRaw<Awaited<ReturnType<this["inputSchema"]>>>, Partial<TRunOptions>]>;
    protected _runCached(input: ToolInput<this>, options: Partial<TRunOptions>, run: GetRunContext<this>): Promise<TOutput>;
    clearCache(): Promise<void>;
    protected abstract _run(arg: ToolInput<this>, options: Partial<TRunOptions>, run: GetRunContext<typeof this>): Promise<TOutput>;
    getInputJsonSchema(): Promise<ajv.SchemaObject>;
    static isTool(value: unknown): value is Tool;
    private _createRetryOptions;
    parse(input: unknown | ToolInputRaw<this> | ToolInput<this>): Promise<ToolInput<this>>;
    protected preprocessInput(rawInput: unknown): void;
    protected validateInput(schema: AnyToolSchemaLike, rawInput: unknown): asserts rawInput is ToolInput<this>;
    createSnapshot(): ToolSnapshot<TOutput, TOptions>;
    loadSnapshot(snapshot: ToolSnapshot<TOutput, TOptions>): void;
    pipe<S extends AnyTool, T extends AnyTool>(this: S, tool: T, mapper: (input: ToolInputRaw<S>, output: TOutput, options: Partial<TRunOptions>, run: RunContext<DynamicTool<TOutput, ZodSchema<ToolInput<S>>, TOptions, TRunOptions, ToolInput<S>>>) => ToolInputRaw<typeof tool>): DynamicTool<TOutput, z.ZodType<FromSchemaLike<Awaited<ReturnType<S["inputSchema"]>>>, z.ZodTypeDef, FromSchemaLike<Awaited<ReturnType<S["inputSchema"]>>>>, TOptions, TRunOptions, FromSchemaLike<Awaited<ReturnType<S["inputSchema"]>>>>;
    extend<S extends AnyTool, TS extends ZodSchema>(this: S, schema: TS, mapper: (input: z.output<TS>, options: Partial<TRunOptions>, run: RunContext<DynamicTool<TOutput, TS, TOptions, TRunOptions, z.output<TS>>>) => ToolInputRaw<S>, overrides?: {
        name?: string;
        description?: string;
    }): DynamicTool<TOutput, TS, TOptions, TRunOptions, z.output<TS>>;
}
type AnyTool = Tool<any, any, any>;
declare class DynamicTool<TOutput extends ToolOutput, TInputSchema extends AnyToolSchemaLike, TOptions extends BaseToolOptions = BaseToolOptions, TRunOptions extends BaseToolRunOptions = BaseToolRunOptions, TInput = FromSchemaLike<TInputSchema>> extends Tool<TOutput, TOptions, TRunOptions> {
    name: string;
    description: string;
    private readonly _inputSchema;
    readonly emitter: Emitter<ToolEvents<FromSchemaLike<TInputSchema>, TOutput>>;
    private readonly handler;
    inputSchema(): TInputSchema;
    constructor(fields: {
        name: string;
        description: string;
        inputSchema: TInputSchema;
        handler: (input: TInput, options: Partial<TRunOptions>, run: GetRunContext<DynamicTool<TOutput, TInputSchema, TOptions, TRunOptions, TInput>>) => Promise<TOutput>;
        options?: TOptions;
    });
    protected _run(arg: TInput, options: Partial<TRunOptions>, run: GetRunContext<DynamicTool<TOutput, TInputSchema, TOptions, TRunOptions, TInput>>): Promise<TOutput>;
    createSnapshot(): {
        handler: ((input: TInput, options: Partial<TRunOptions>, run: GetRunContext<DynamicTool<TOutput, TInputSchema, TOptions, TRunOptions, TInput>>) => Promise<TOutput>) & ((...args: unknown[]) => unknown);
        _inputSchema: TInputSchema;
        name: string;
        description: string;
        options: TOptions;
        cache: BaseCache<Task<TOutput, any>>;
        emitter: Emitter<any>;
    };
    loadSnapshot({ handler, ...snapshot }: ReturnType<typeof this.createSnapshot>): void;
}

export { type AnyTool, type BaseToolOptions, type BaseToolRunOptions, type CustomToolEmitter, DynamicTool, type InferToolOutput, JSONToolOutput, type RetryOptions, StringToolOutput, Tool, type ToolEmitter, ToolError, type ToolEvents, type ToolInput, type ToolInputRaw, ToolInputValidationError, ToolOutput, type ToolSnapshot };
