import wiki from 'wikipedia';
import { Cache } from '../../cache/decoratorCache.js';
import * as R from 'remeda';
import { keys, mapValues } from 'remeda';
import { SearchToolOutput } from './base.js';
import { asyncProperties } from '../../internals/helpers/promise.js';
import { z } from 'zod';
import { Tool } from '../base.js';
import Turndown from 'turndown';
import turndownPlugin from 'joplin-turndown-plugin-gfm';
import stringComparison from 'string-comparison';
import { Emitter } from '../../emitter/emitter.js';

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate, "_ts_decorate");
function _ts_metadata(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
}
__name(_ts_metadata, "_ts_metadata");
wiki.default.setLang("en");
class WikipediaToolOutput extends SearchToolOutput {
  static {
    __name(this, "WikipediaToolOutput");
  }
  results;
  maxSerializedLength;
  constructor(results, maxSerializedLength) {
    super(results), this.results = results, this.maxSerializedLength = maxSerializedLength;
  }
  static {
    this.register();
  }
  getTextContent() {
    if (this.isEmpty()) {
      return `No results were found. Try to reformat your query.`;
    }
    const target = this.results.length === 1 ? this.results[0] : this.results;
    const response = JSON.stringify(target);
    return this.maxSerializedLength < Infinity ? response.substring(0, this.maxSerializedLength) : response;
  }
  createSnapshot() {
    return {
      results: this.results,
      maxSerializedLength: this.maxSerializedLength
    };
  }
  loadSnapshot(snapshot) {
    Object.assign(this, snapshot);
  }
}
_ts_decorate([
  Cache(),
  _ts_metadata("design:type", Function),
  _ts_metadata("design:paramtypes", []),
  _ts_metadata("design:returntype", String)
], WikipediaToolOutput.prototype, "getTextContent", null);
class WikipediaTool extends Tool {
  static {
    __name(this, "WikipediaTool");
  }
  config;
  name;
  description;
  emitter;
  inputSchema() {
    return z.object({
      query: z.string({
        description: `Name of the wikipedia page, for example 'New York'`
      }).min(1).max(128)
    });
  }
  constructor(config = {}) {
    super(config), this.config = config, this.name = "Wikipedia", this.description = "Search factual and historical information, including biography, history, politics, geography, society, culture, science, technology, people, animal species, mathematics, and other subjects.", this.emitter = Emitter.root.child({
      namespace: [
        "tool",
        "search",
        "wikipedia"
      ],
      creator: this
    });
  }
  static {
    this.register();
  }
  get _mappers() {
    return {
      categories: /* @__PURE__ */ __name((page) => page.categories(), "categories"),
      content: /* @__PURE__ */ __name((page) => page.content(), "content"),
      html: /* @__PURE__ */ __name((page) => page.html(), "html"),
      markdown: /* @__PURE__ */ __name(async (page, runOptions) => {
        const html = await page.html().then((result) => {
          const url = new URL(page.fullurl);
          const base = `${url.protocol}//${[
            url.hostname,
            url.port
          ].filter(Boolean).join(":")}`;
          return result.replace(/(<img .*src=)"(\/\/.*)"/gm, `$1"${url.protocol}$2"`).replace(/(<a .*href=)"(\/\/.*)"/gm, `$1"${url.protocol}$2"`).replace(/(<img .*src=)"(\/.*)"/gm, `$1"${base}$2"`).replace(/(<a .*href=)"(\/.*)"/gm, `$1"${base}$2"`);
        });
        const service = new Turndown();
        service.use(turndownPlugin.gfm);
        return service.remove((node) => runOptions.extraction?.fields?.markdown?.filter?.(node) === false).turndown(html);
      }, "markdown"),
      images: /* @__PURE__ */ __name((page) => page.images(), "images"),
      intro: /* @__PURE__ */ __name((page) => page.intro(), "intro"),
      infobox: /* @__PURE__ */ __name((page) => page.infobox(), "infobox"),
      links: /* @__PURE__ */ __name((page) => page.links(), "links"),
      coordinates: /* @__PURE__ */ __name((page) => page.coordinates(), "coordinates"),
      langLinks: /* @__PURE__ */ __name((page) => page.langLinks(), "langLinks"),
      references: /* @__PURE__ */ __name((page) => page.references(), "references"),
      related: /* @__PURE__ */ __name((page) => page.related(), "related"),
      summary: /* @__PURE__ */ __name((page) => page.summary(), "summary"),
      tables: /* @__PURE__ */ __name((page) => page.tables(), "tables")
    };
  }
  get _defaultRunOptions() {
    const unwrapTags = /* @__PURE__ */ new Set([
      "a",
      "small",
      "sup"
    ]);
    const unwrapTagsSelector = Array.from(unwrapTags.values()).join(",");
    const ignoredTags = /* @__PURE__ */ new Set([
      "img",
      "link",
      "style",
      "abbr",
      "cite",
      "input",
      "sup",
      "bdi",
      "q",
      "figure",
      "audio",
      "track",
      "figcaption"
    ]);
    const ignoredClasses = /* @__PURE__ */ new Set([
      "toc",
      "reflist",
      "mw-references-wrap",
      "box-More_footnotes_needed",
      "navbox",
      "navbox-styles",
      "mw-editsection",
      "sistersitebox",
      "navbox-inner",
      "refbegin",
      "notpageimage",
      "mw-file-element",
      "box-Unreferenced_section",
      "navigation-not-searchable",
      "noexcerpt",
      "infobox-image",
      "mw-tmh-player",
      "printfooter",
      "ambox",
      "infobox"
    ]);
    const ignoredRoles = /* @__PURE__ */ new Set([
      "navigation"
    ]);
    const ignoredSelector = [
      ...ignoredTags.values(),
      Array.from(ignoredClasses.values()).map((cls) => `.${cls}`),
      Array.from(ignoredRoles.values()).map((role) => `[role="${role}"]`),
      "table>caption"
    ].join(",");
    return {
      extraction: {
        fields: {
          markdown: {
            transform: /* @__PURE__ */ __name((output) => output.replace(/([^\\])(\$)/g, `$1\\$2`), "transform"),
            filter: /* @__PURE__ */ __name((node) => {
              const tagName = node.tagName.toLowerCase();
              if (ignoredTags.has(tagName) || ignoredRoles.has(node.role ?? "")) {
                return false;
              }
              for (const cls of node.className.trim().split(" ").filter(Boolean)) {
                if (ignoredClasses.has(cls)) {
                  return false;
                }
              }
              for (const table of Array.from(node.querySelectorAll("table tr>th"))) {
                let colspan = parseInt(table.getAttribute("colspan") || "1");
                while (colspan > 1) {
                  table.insertAdjacentHTML("afterend", `<th>&nbsp;</th>`);
                  colspan--;
                }
                table.removeAttribute("colspan");
              }
              const ignoredTargets = Array.from(ignoredSelector ? node.querySelectorAll(ignoredSelector) : []);
              for (const childNode of ignoredTargets) {
                childNode.remove();
              }
              const unwrapTargets = Array.from(unwrapTagsSelector ? node.querySelectorAll(unwrapTagsSelector) : []).reverse();
              if (unwrapTags.has(tagName)) {
                unwrapTargets.push(node);
              }
              for (const childNode of unwrapTargets) {
                childNode.outerHTML = childNode.innerHTML;
              }
              return true;
            }, "filter")
          }
        }
      },
      filters: {
        minPageNameSimilarity: 0.5,
        excludeOthersOnExactMatch: true
      },
      search: {
        limit: 3,
        suggestion: true
      },
      output: {
        maxSerializedLength: 25e3,
        maxDescriptionLength: 250
      }
    };
  }
  _createRunOptions(overrides) {
    const baseKeys = [
      "filters",
      "search",
      "extraction",
      "retryOptions",
      "output"
    ];
    return R.pipe({
      ...this._defaultRunOptions
    }, R.mergeDeep(R.pick(this.options ?? {}, baseKeys)), R.mergeDeep({
      ...overrides
    }));
  }
  async _run({ query: input }, _options) {
    const runOptions = this._createRunOptions(_options);
    const { results: searchRawResults, suggestion } = await wiki.default.search(input, {
      suggestion: Boolean(_options?.search?.suggestion),
      ...runOptions.search
    });
    if (searchRawResults.length === 0 && suggestion && runOptions.search?.suggestion) {
      return await this._run({
        query: suggestion
      }, _options);
    }
    const bestCandidates = this.extractBestCandidates(input, searchRawResults, runOptions?.filters ?? {});
    const results = await Promise.all(bestCandidates.map(async ({ pageId }) => {
      const page = await wiki.default.page(pageId, {
        redirect: true,
        preload: false,
        fields: keys(runOptions.extraction?.fields ?? {}).filter((key) => key !== "markdown")
      });
      return asyncProperties({
        title: page.title,
        description: (() => {
          const length = runOptions?.output?.maxDescriptionLength ?? 0;
          return length <= 0 ? Promise.resolve("") : page.content().then((content) => content.substring(0, length));
        })(),
        url: page.fullurl,
        fields: asyncProperties(mapValues(runOptions?.extraction?.fields ?? {}, (value, key) => this._mappers[key](page, runOptions).then((response) => value.transform ? value.transform(response) : response).catch(() => null)))
      });
    }));
    return new WikipediaToolOutput(results, runOptions.output?.maxSerializedLength ?? Infinity);
  }
  extractBestCandidates(query, candidates, options) {
    const normalize = /* @__PURE__ */ __name((text) => text.normalize("NFKD").replace(/[^\w| ]/g, "").replace(/\s\s+/g, " ").trim(), "normalize");
    const bestCandidates = stringComparison.jaccardIndex.sortMatch(normalize(query), candidates.map((candidate) => normalize(candidate.title))).map((result) => ({
      pageId: candidates[result.index].pageid,
      score: result.rating
    })).filter((result) => result.score >= (options.minPageNameSimilarity ?? 0)).sort((a, b) => b.score - a.score);
    if (bestCandidates.at(0)?.score === 1 && options.excludeOthersOnExactMatch) {
      bestCandidates.length = 1;
    }
    return bestCandidates;
  }
  createSnapshot() {
    return {
      ...super.createSnapshot(),
      config: this.config
    };
  }
  loadSnapshot(snapshot) {
    super.loadSnapshot(snapshot);
  }
}
_ts_decorate([
  Cache({
    enumerable: false
  }),
  _ts_metadata("design:type", typeof Record === "undefined" ? Object : Record),
  _ts_metadata("design:paramtypes", [])
], WikipediaTool.prototype, "_mappers", null);
_ts_decorate([
  Cache({
    enumerable: false
  }),
  _ts_metadata("design:type", typeof WikipediaToolRunOptions === "undefined" ? Object : WikipediaToolRunOptions),
  _ts_metadata("design:paramtypes", [])
], WikipediaTool.prototype, "_defaultRunOptions", null);

export { WikipediaTool, WikipediaToolOutput };
//# sourceMappingURL=wikipedia.js.map
//# sourceMappingURL=wikipedia.js.map