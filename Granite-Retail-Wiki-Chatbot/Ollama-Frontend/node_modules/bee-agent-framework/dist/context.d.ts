import { E as Emitter, C as Callback } from './emitter-DRfJC1TP.js';
import { Serializable } from './internals/serializable.js';
import { LazyPromise } from './internals/helpers/promise.js';
import './internals/types.js';
import './internals/helpers/guards.js';

/**
 * Copyright 2024 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

interface RunInstance<T = any> {
    emitter: Emitter<T>;
}
interface RunContextCallbacks {
    start: Callback<null>;
    success: Callback<unknown>;
    error: Callback<Error>;
    finish: Callback<null>;
}
type GetRunContext<T, P = any> = T extends RunInstance ? RunContext<T, P> : never;
type GetRunInstance<T> = T extends RunInstance<infer P> ? P : never;
declare class Run<R, I extends RunInstance, P = any> extends LazyPromise<R> {
    protected readonly runContext: GetRunContext<I, P>;
    protected readonly tasks: (() => Promise<void>)[];
    constructor(handler: () => Promise<R>, runContext: GetRunContext<I, P>);
    readonly [Symbol.toStringTag] = "Promise";
    observe(fn: (emitter: Emitter<GetRunInstance<I>>) => void): this;
    context(value: object): this;
    middleware(fn: (context: GetRunContext<I, P>) => void): this;
    protected before(): Promise<void>;
}
interface RunContextInput<P> {
    params: P;
    signal?: AbortSignal;
}
declare class RunContext<T extends RunInstance, P = any> extends Serializable {
    #private;
    readonly instance: T;
    protected readonly input: RunContextInput<P>;
    protected readonly controller: AbortController;
    readonly runId: string;
    readonly groupId: string;
    readonly parentId?: string;
    readonly emitter: Emitter<GetRunInstance<T>>;
    readonly context: object;
    readonly runParams: P;
    readonly createdAt: Date;
    get signal(): AbortSignal;
    abort(): void;
    constructor(instance: T, input: RunContextInput<P>, parent?: RunContext<any>);
    destroy(): void;
    static enter<C2 extends RunInstance, R2, P2>(instance: C2, input: RunContextInput<P2>, fn: (context: GetRunContext<C2, P2>) => Promise<R2>): Run<R2, C2, P2>;
    createSnapshot(): {
        controller: AbortController;
        runId: string;
        groupId: string;
        parentId: string | undefined;
        emitter: Emitter<GetRunInstance<T>>;
        context: object;
        runParams: P;
        createdAt: Date;
    };
    loadSnapshot(snapshot: ReturnType<typeof this.createSnapshot>): void;
}

export { type GetRunContext, type GetRunInstance, Run, RunContext, type RunContextCallbacks, type RunContextInput, type RunInstance };
