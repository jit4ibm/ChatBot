'use strict';

var serializer_cjs = require('../serializer/serializer.cjs');
var R = require('remeda');
var utils_cjs = require('../serializer/utils.cjs');
var error_cjs = require('../serializer/error.cjs');
var decoratorCache_cjs = require('../cache/decoratorCache.cjs');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var R__namespace = /*#__PURE__*/_interopNamespace(R);

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
class Serializable {
  static {
    __name(this, "Serializable");
  }
  constructor() {
    Object.getPrototypeOf(this).constructor.register();
    decoratorCache_cjs.Cache.init(this);
  }
  static register(aliases) {
    serializer_cjs.Serializer.registerSerializable(this, void 0, aliases);
  }
  clone() {
    const snapshot = this.createSnapshot();
    const target = Object.create(this.constructor.prototype);
    target.loadSnapshot(snapshot);
    return target;
  }
  serialize() {
    const snapshot = this.createSnapshot();
    return serializer_cjs.Serializer.serialize({
      target: utils_cjs.extractClassName(this),
      snapshot
    });
  }
  deserialize(value, options) {
    const { __root } = serializer_cjs.Serializer.deserializeWithMeta(value, options?.extraClasses);
    if (!__root.target) {
      console.warn(`Serializable class must be serialized via "serialize" method and not via Serializer class. This may lead to incorrect deserialization.`);
      return __root;
    }
    const current = utils_cjs.extractClassName(this);
    if (current !== __root.target) {
      throw new error_cjs.SerializerError(`Snapshot has been created for class '${__root.target}' but you want to use it for class '${current}'.`);
    }
    return __root.snapshot;
  }
  static fromSnapshot(state) {
    const target = Object.create(this.prototype);
    target.loadSnapshot(state);
    decoratorCache_cjs.Cache.init(target);
    return target;
  }
  static fromSerialized(serialized, options = {}) {
    const target = Object.create(this.prototype);
    const state = target.deserialize(serialized, options);
    const load = target.loadSnapshot(state);
    decoratorCache_cjs.Cache.init(target);
    return R__namespace.isPromise(load) ? load.then(() => target) : target;
  }
}

exports.Serializable = Serializable;
//# sourceMappingURL=serializable.cjs.map
//# sourceMappingURL=serializable.cjs.map