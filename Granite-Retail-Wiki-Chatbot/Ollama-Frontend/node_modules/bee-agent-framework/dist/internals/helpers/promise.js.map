{"version":3,"sources":["../../../src/internals/helpers/promise.ts"],"names":["isPromiseLike","value","isPromise","isFunction","getProp","arrayFromAsync","generator","limit","Infinity","results","chunk","length","push","emitterToGenerator","fn","queue","emit","data","then","done","catch","error","Promise","resolve","setImmediate","shift","asyncProperties","obj","Object","fromEntries","all","entries","map","key","safeExecute","handler","onError","onSuccess","result","err","e","asyncExecute","LazyPromise","constructor","Symbol","toStringTag","before","onfulfilled","onrejected","undefined","finally","onfinally","signalRace","signal","onAbort","reject","aborted","reason","signalFn","addEventListener","removeEventListener","executeSequentially","tasks","task"],"mappings":";;;;;AAmBO,SAASA,cAAiBC,KAAc,EAAA;AAC7C,EAAA,OAAOC,SAAUD,CAAAA,KAAAA,CAAUE,IAAAA,UAAAA,CAAWC,QAAQH,KAAO,EAAA;AAAC,IAAA;GAAO,CAAA,CAAA;AAC/D;AAFgBD,MAAAA,CAAAA,aAAAA,EAAAA,eAAAA,CAAAA;AAIhB,eAAsBK,cAAAA,CACpBC,WACAC,KAAc,EAAA;AAEdA,EAAAA,KAAAA,GAAQA,KAASC,IAAAA,QAAAA;AACjB,EAAA,MAAMC,UAAe,EAAA;AACrB,EAAA,WAAA,MAAiBC,SAASJ,SAAW,EAAA;AACnC,IAAIG,IAAAA,OAAAA,CAAQE,UAAUJ,KAAO,EAAA;AAC3B,MAAA;AACF;AACAE,IAAAA,OAAAA,CAAQG,KAAKF,KAAAA,CAAAA;AACf;AACA,EAAOD,OAAAA,OAAAA;AACT;AAbsBJ,MAAAA,CAAAA,cAAAA,EAAAA,gBAAAA,CAAAA;AAgBtB,gBAAuBQ,mBAAyBC,EAA8B,EAAA;AAO5E,EAAA,MAAMC,QAAgB,EAAA;AACtB,EAAA,KAAKD,EAAG,CAAA;IACNE,IAAM,kBAAA,MAAA,CAAA,CAACC,IAAYF,KAAAA,KAAAA,CAAMH,IAAK,CAAA;AAAEK,MAAAA;AAAK,KAAA,CAA/B,EAAA,MAAA;AACR,GAAA,CACGC,CAAAA,IAAAA,CAAK,MAAMH,KAAAA,CAAMH,IAAK,CAAA;IAAEO,IAAM,EAAA;AAAK,GAAA,CAAA,CACnCC,CAAAA,KAAAA,CAAM,CAACC,KAAAA,KAAUN,MAAMH,IAAK,CAAA;AAAES,IAAAA,KAAAA;IAAOF,IAAM,EAAA;AAAK,GAAA,CAAA,CAAA;AAEnD,EAAA,OAAO,IAAM,EAAA;AACX,IAAOJ,OAAAA,KAAAA,CAAMJ,WAAW,CAAG,EAAA;AACzB,MAAA,MAAM,IAAIW,OAAQ,CAAA,CAACC,OAAYC,KAAAA,YAAAA,CAAaD,OAAAA,CAAAA,CAAAA;AAC9C;AAEA,IAAA,MAAM,EAAEN,IAAME,EAAAA,IAAAA,EAAME,KAAK,EAAA,GAAKN,MAAMU,KAAK,EAAA;AACzC,IAAA,IAAIJ,KAAO,EAAA;AACT,MAAMA,MAAAA,KAAAA;AACR;AACA,IAAA,IAAIF,IAAM,EAAA;AACR,MAAA;AACF;AACA,IAAMF,MAAAA,IAAAA;AACR;AACF;AA5BuBJ,MAAAA,CAAAA,kBAAAA,EAAAA,oBAAAA,CAAAA;AA8BvB,eAAsBa,gBACpBC,GAAM,EAAA;AAEN,EAAA,OAAOC,MAAOC,CAAAA,WAAAA,CACZ,MAAMP,OAAAA,CAAQQ,IAAIF,MAAOG,CAAAA,OAAAA,CAAQJ,GAAAA,CAAAA,CAAKK,GAAI,CAAA,OAAO,CAACC,GAAAA,EAAKhC,KAAAA,CAAW,KAAA;AAACgC,IAAAA,GAAAA;IAAK,MAAMhC;AAAM,GAAA,CAAA,CAAA,CAAA;AAExF;AANsByB,MAAAA,CAAAA,eAAAA,EAAAA,iBAAAA,CAAAA;AAcf,SAASQ,WAAe,CAAA,EAAEC,OAASC,EAAAA,OAAAA,EAASC,WAAkC,EAAA;AACnF,EAAI,IAAA;AACF,IAAA,MAAMC,SAASH,OAAAA,EAAAA;AACf,IAAInC,IAAAA,aAAAA,CAAiBsC,MAAAA,CAAS,EAAA;AAC5BA,MAAOpB,MAAAA,CAAAA,IAAAA,CACL,CAACoB,OAAAA,KAAWD,SAAYC,GAAAA,OAAAA,GACxB,CAACC,GAAAA,KAAQH,OAAUG,GAAAA,GAAAA,CAAAA,CAAAA;KAEhB,MAAA;AACLF,MAAAA,SAAAA,GAAYC,MAAAA,CAAAA;AACd;AACF,GAAA,CAAA,OAASE,CAAG,EAAA;AACVJ,IAAAA,OAAAA,GAAUI,CAAAA,CAAAA;AACZ;AACF;AAdgBN,MAAAA,CAAAA,WAAAA,EAAAA,aAAAA,CAAAA;AAgBT,SAASO,aAAgBN,OAAgB,EAAA;AAC9C,EAAA,OAAO,IAAIb,OAAAA,CAAQ,CAACe,SAAAA,EAAWD,OAAAA,KAAAA;AAC7BF,IAAY,WAAA,CAAA;AACVC,MAAAA,OAAAA;AACAE,MAAAA,SAAAA;AACAD,MAAAA;KACF,CAAA;GACF,CAAA;AACF;AARgBK,MAAAA,CAAAA,YAAAA,EAAAA,cAAAA,CAAAA;AAUT,MAAMC,WAAAA,CAAAA;EA7Gb;;;;AA8GEC,EAAAA,WAAAA,CAA+BR,OAA2B,EAAA;SAA3BA,OAAAA,GAAAA,OAAAA;AAErBS,IAAAA,IAAAA,CAAAA,mBAAAA,CAAsB,GAAA,SAAA;AAF2B;EAElD,CAACA,mBAAAA,GAAAA,OAAOC,WAAW;AAE5B,EAAA,MAAgBC,MAAwB,GAAA;AAAC;AAEzC5B,EAAAA,IAAAA,CACE6B,aACAC,UAC8B,EAAA;AAC9B,IAAO,OAAA,IAAA,CAAKF,MAAM,EAAA,CAAG5B,IAAK,CAAA,IAAA,CAAKiB,OAAO,CAAA,CAAEjB,IAAK6B,CAAAA,WAAAA,CAAa3B,CAAAA,KAAAA,CAAM4B,UAAAA,CAAAA;AAClE;AAEA5B,EAAAA,KAAAA,CACE4B,UACsB,EAAA;AACtB,IAAO,OAAA,IAAA,CAAKF,MAAM,EAAA,CAAG5B,IAAK,CAAA,IAAA,CAAKiB,OAAO,CAAA,CAAEjB,IAAK+B,CAAAA,KAAAA,CAAAA,CAAW7B,CAAAA,KAAAA,CAAM4B,UAAAA,CAAAA;AAChE;AAEAE,EAAAA,OAAAA,CAAQC,SAAyD,EAAA;AAC/D,IAAO,OAAA,IAAA,CAAKL,QAAS5B,CAAAA,IAAAA,CAAK,KAAKiB,OAAO,CAAA,CAAEe,QAAQC,SAAAA,CAAAA;AAClD;AACF;AAEA,eAAsBC,UAAAA,CACpBtC,EACAuC,EAAAA,MAAAA,EACAC,OAAoB,EAAA;AAEpB,EAAA,OAAO,IAAIhC,OAAAA,CAAW,CAACC,OAAAA,EAASgC,MAAAA,KAAAA;AAC9B,IAAA,IAAIF,QAAQG,OAAS,EAAA;AACnBD,MAAAA,MAAAA,CAAOF,OAAOI,MAAM,CAAA;AACpB,MAAA;AACF;AAEA,IAAA,MAAMC,2BAAW,MAAA,CAAA,MAAA;AACfJ,MAAAA,OAAAA,IAAAA;AACAC,MAAAA,MAAAA,CAAOF,QAAQI,MAAAA,CAAAA;KAFA,EAAA,UAAA,CAAA;AAIjBJ,IAAQM,MAAAA,EAAAA,gBAAAA,GAAmB,SAASD,QAAAA,CAAAA;AACpC5C,IAAAA,EAAAA,EACGI,CAAAA,IAAAA,CAAKK,OAAAA,CAAAA,CACLH,KAAMmC,CAAAA,MAAAA,CACNL,CAAAA,OAAAA,CAAQ,MAAMG,MAAAA,EAAQO,mBAAsB,GAAA,OAAA,EAASF,QAAAA,CAAAA,CAAAA;GAC1D,CAAA;AACF;AArBsBN,MAAAA,CAAAA,UAAAA,EAAAA,YAAAA,CAAAA;AAuBtB,eAAsBS,oBAAoBC,KAA6B,EAAA;AACrE,EAAA,KAAA,MAAWC,QAAQD,KAAO,EAAA;AACxB,IAAA,MAAMC,IAAAA,EAAAA;AACR;AACF;AAJsBF,MAAAA,CAAAA,mBAAAA,EAAAA,qBAAAA,CAAAA","file":"promise.js","sourcesContent":["/**\n * Copyright 2024 IBM Corp.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { isFunction, isPromise } from \"remeda\";\nimport { getProp } from \"@/internals/helpers/object.js\";\n\nexport function isPromiseLike<T>(value: unknown): value is PromiseLike<T> {\n  return isPromise(value) || isFunction(getProp(value, [\"then\"]));\n}\n\nexport async function arrayFromAsync<A, B>(\n  generator: AsyncGenerator<A, B> | AsyncIterableIterator<A> | AsyncIterable<A>,\n  limit?: number,\n) {\n  limit = limit ?? Infinity;\n  const results: A[] = [];\n  for await (const chunk of generator) {\n    if (results.length >= limit) {\n      break;\n    }\n    results.push(chunk);\n  }\n  return results;\n}\n\nexport type EmitterToGeneratorFn<T, R> = (data: { emit: (data: T) => void }) => Promise<R>;\nexport async function* emitterToGenerator<T, R>(fn: EmitterToGeneratorFn<T, R>) {\n  interface Data {\n    data?: T;\n    error?: Error;\n    done?: boolean;\n  }\n\n  const queue: Data[] = [];\n  void fn({\n    emit: (data: T) => queue.push({ data }),\n  })\n    .then(() => queue.push({ done: true }))\n    .catch((error) => queue.push({ error, done: true }));\n\n  while (true) {\n    while (queue.length === 0) {\n      await new Promise((resolve) => setImmediate(resolve));\n    }\n\n    const { data, done, error } = queue.shift()!;\n    if (error) {\n      throw error;\n    }\n    if (done) {\n      break;\n    }\n    yield data!;\n  }\n}\n\nexport async function asyncProperties<T extends NonNullable<unknown>>(\n  obj: T,\n): Promise<{ [K in keyof T]: T[K] extends Promise<infer P> ? P : T[K] }> {\n  return Object.fromEntries(\n    await Promise.all(Object.entries(obj).map(async ([key, value]) => [key, await value])),\n  );\n}\n\ninterface SafeExecuteOptions<T> {\n  handler: () => T;\n  onSuccess?: (result: T) => void;\n  onError?: (err: Error) => void;\n}\n\nexport function safeExecute<T>({ handler, onError, onSuccess }: SafeExecuteOptions<T>): void {\n  try {\n    const result = handler();\n    if (isPromiseLike<T>(result)) {\n      result.then(\n        (result) => onSuccess?.(result),\n        (err) => onError?.(err),\n      );\n    } else {\n      onSuccess?.(result);\n    }\n  } catch (e) {\n    onError?.(e);\n  }\n}\n\nexport function asyncExecute<R>(handler: () => R): Promise<R> {\n  return new Promise((onSuccess, onError) => {\n    safeExecute({\n      handler,\n      onSuccess,\n      onError,\n    });\n  });\n}\n\nexport class LazyPromise<R> implements Promise<R> {\n  constructor(protected readonly handler: () => Promise<R>) {}\n\n  readonly [Symbol.toStringTag] = \"Promise\";\n\n  protected async before(): Promise<void> {}\n\n  then<TResult1 = R, TResult2 = never>(\n    onfulfilled?: ((value: R) => PromiseLike<TResult1> | TResult1) | undefined | null,\n    onrejected?: ((reason: any) => PromiseLike<TResult2> | TResult2) | undefined | null,\n  ): Promise<TResult1 | TResult2> {\n    return this.before().then(this.handler).then(onfulfilled).catch(onrejected);\n  }\n\n  catch<TResult = never>(\n    onrejected?: ((reason: any) => PromiseLike<TResult> | TResult) | undefined | null,\n  ): Promise<R | TResult> {\n    return this.before().then(this.handler).then(undefined).catch(onrejected);\n  }\n\n  finally(onfinally?: (() => void) | undefined | null): Promise<R> {\n    return this.before().then(this.handler).finally(onfinally);\n  }\n}\n\nexport async function signalRace<R>(\n  fn: () => Promise<R>,\n  signal?: AbortSignal,\n  onAbort?: () => void,\n): Promise<R> {\n  return new Promise<R>((resolve, reject) => {\n    if (signal?.aborted) {\n      reject(signal.reason);\n      return;\n    }\n\n    const signalFn = () => {\n      onAbort?.();\n      reject(signal?.reason);\n    };\n    signal?.addEventListener?.(\"abort\", signalFn);\n    fn()\n      .then(resolve)\n      .catch(reject)\n      .finally(() => signal?.removeEventListener?.(\"abort\", signalFn));\n  });\n}\n\nexport async function executeSequentially(tasks: (() => Promise<any>)[]): Promise<void> {\n  for (const task of tasks) {\n    await task();\n  }\n}\n"]}