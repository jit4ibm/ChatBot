{"version":3,"sources":["../../../src/internals/helpers/retryable.ts"],"names":["RunStrategy","THROW_IMMEDIATELY","SETTLE_ROUND","SETTLE_ALL","Retryable","constructor","ctx","createRandomHash","executor","onReset","onError","onRetry","config","maxRetries","Math","max","runGroup","strategy","inputs","Promise","all","map","input","get","controller","AbortController","results","allSettled","groupSignal","signal","undefined","catch","err","abort","throwIfAborted","result","value","runSequence","collect","R","values","asyncProperties","mapValues","attempt","executionId","Object","defineProperty","enumerable","isResolved","state","TaskState","RESOLVED","isRejected","REJECTED","_run","task","Task","assertAborted","lastError","pRetry","retries","factor","shouldRetry","e","FrameworkError","isRetryable","aborted","onFailedAttempt","meta","then","x","resolve","reject","resolvedValue","rejectedValue","PENDING","reset"],"mappings":"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","file":"retryable.js","sourcesContent":["/**\n * Copyright 2024 IBM Corp.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as R from \"remeda\";\nimport { Task, TaskState } from \"promise-based-task\";\nimport { FrameworkError } from \"@/errors.js\";\nimport { EnumValue } from \"@/internals/types.js\";\nimport { asyncProperties } from \"@/internals/helpers/promise.js\";\nimport { createRandomHash } from \"@/internals/helpers/hash.js\";\nimport { pRetry } from \"@/internals/helpers/retry.js\";\n\nexport interface RetryableConfig {\n  maxRetries: number;\n  factor?: number;\n  signal?: AbortSignal;\n}\n\nexport const RunStrategy = {\n  /**\n   * Once a single Retryable throws, other retry ables get cancelled immediately.\n   */\n  THROW_IMMEDIATELY: \"THROW_IMMEDIATELY\",\n\n  /**\n   * Once a single Retryable throws, wait for other to completes, but prevent further retries.\n   */\n  SETTLE_ROUND: \"SETTLE_ROUND\",\n\n  /**\n   * Once a single Retryable throws, other Retryables remains to continue. Error is thrown by the end.\n   */\n  SETTLE_ALL: \"SETTLE_ALL\",\n} as const;\n\nexport interface RetryableRunConfig {\n  groupSignal: AbortSignal;\n}\n\nexport interface RetryableContext {\n  executionId: string;\n  attempt: number;\n  signal?: AbortSignal;\n}\n\nexport type RetryableHandler<T> = (ctx: RetryableContext) => Promise<T>;\nexport type ResetHandler = () => void;\nexport type ErrorHandler = (error: Error, ctx: RetryableContext) => void | Promise<void>;\nexport type RetryHandler = (ctx: RetryableContext, lastError: Error) => void | Promise<void>;\n\nexport class Retryable<T> {\n  readonly #id: string;\n  #value: Task<T, Error> | null;\n  #config: RetryableConfig;\n  #handlers;\n\n  constructor(ctx: {\n    executor: RetryableHandler<T>;\n    onReset?: ResetHandler;\n    onError?: ErrorHandler;\n    onRetry?: RetryHandler;\n    config?: Partial<RetryableConfig>;\n  }) {\n    this.#value = null;\n    this.#id = createRandomHash();\n    this.#handlers = {\n      executor: ctx.executor,\n      onReset: ctx.onReset,\n      onError: ctx.onError,\n      onRetry: ctx.onRetry,\n    } as const;\n    this.#config = {\n      ...ctx.config,\n      maxRetries: Math.max(ctx.config?.maxRetries || 0, 0),\n    };\n  }\n\n  static async runGroup<T>(\n    strategy: EnumValue<typeof RunStrategy>,\n    inputs: Retryable<T>[],\n  ): Promise<T[]> {\n    if (strategy === RunStrategy.THROW_IMMEDIATELY) {\n      return await Promise.all(inputs.map((input) => input.get()));\n    }\n\n    const controller = new AbortController();\n    const results = await Promise.allSettled(\n      inputs.map((input) =>\n        input\n          .get(strategy === RunStrategy.SETTLE_ALL ? { groupSignal: controller.signal } : undefined)\n          .catch((err) => {\n            controller.abort(err);\n            throw err;\n          }),\n      ),\n    );\n    controller.signal.throwIfAborted();\n    return results.map((result) => (result as PromiseFulfilledResult<T>).value!);\n  }\n\n  static async *runSequence<T>(inputs: readonly Retryable<T>[]): AsyncGenerator<T> {\n    for (const input of inputs) {\n      yield await input.get();\n    }\n  }\n\n  static async collect<T>(inputs: T & Record<string, Retryable<any>>) {\n    // Solve everything\n    await Promise.all(R.values(inputs).map((input) => input.get()));\n\n    // Obtain latest values\n    return await asyncProperties(\n      R.mapValues(inputs, (value) => (value as Retryable<any>).get()) as {\n        [K in keyof T]: Promise<T[K] extends Retryable<infer Q> ? Q : never>;\n      },\n    );\n  }\n\n  #getContext(attempt: number): RetryableContext {\n    const ctx: RetryableContext = {\n      attempt,\n      executionId: this.#id,\n      signal: this.#config.signal,\n    };\n    Object.defineProperty(ctx, \"signal\", {\n      enumerable: false,\n    });\n    return ctx;\n  }\n\n  get isResolved(): boolean {\n    return this.#value?.state === TaskState.RESOLVED;\n  }\n\n  get isRejected(): boolean {\n    return this.#value?.state === TaskState.REJECTED;\n  }\n\n  protected _run(config?: RetryableRunConfig) {\n    const task = new Task<T, Error>();\n\n    const assertAborted = () => {\n      this.#config.signal?.throwIfAborted?.();\n      config?.groupSignal?.throwIfAborted?.();\n    };\n\n    let lastError: Error | null = null;\n    pRetry(\n      async (attempt) => {\n        assertAborted();\n\n        const ctx = this.#getContext(attempt);\n        if (attempt > 1) {\n          await this.#handlers.onRetry?.(ctx, lastError!);\n        }\n        return await this.#handlers.executor(ctx);\n      },\n      {\n        retries: this.#config.maxRetries,\n        factor: this.#config.factor,\n        signal: this.#config.signal,\n        shouldRetry: (e) => {\n          if (!FrameworkError.isRetryable(e)) {\n            return false;\n          }\n          return !config?.groupSignal?.aborted && !this.#config.signal?.aborted;\n        },\n        onFailedAttempt: async (e, meta) => {\n          lastError = e;\n          await this.#handlers.onError?.(e, this.#getContext(meta.attempt));\n          if (!FrameworkError.isRetryable(e)) {\n            throw e;\n          }\n          assertAborted();\n        },\n      },\n    )\n      .then((x) => task.resolve(x))\n      .catch((x) => task.reject(x));\n\n    return task;\n  }\n\n  async get(config?: RetryableRunConfig): Promise<T> {\n    if (this.isResolved) {\n      return this.#value!.resolvedValue()!;\n    }\n    if (this.isRejected) {\n      throw this.#value?.rejectedValue();\n    }\n\n    if (this.#value?.state === TaskState.PENDING && !config) {\n      return this.#value;\n    }\n\n    this.#value?.catch?.(() => {});\n    this.#value = this._run(config);\n    return this.#value;\n  }\n\n  reset() {\n    this.#value?.catch?.(() => {});\n    this.#value = null;\n    this.#handlers.onReset?.();\n  }\n}\n"]}