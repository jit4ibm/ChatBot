/**
 * Copyright 2024 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
declare function isPromiseLike<T>(value: unknown): value is PromiseLike<T>;
declare function arrayFromAsync<A, B>(generator: AsyncGenerator<A, B> | AsyncIterableIterator<A> | AsyncIterable<A>, limit?: number): Promise<A[]>;
type EmitterToGeneratorFn<T, R> = (data: {
    emit: (data: T) => void;
}) => Promise<R>;
declare function emitterToGenerator<T, R>(fn: EmitterToGeneratorFn<T, R>): AsyncGenerator<Awaited<NonNullable<T>>, void, unknown>;
declare function asyncProperties<T extends NonNullable<unknown>>(obj: T): Promise<{
    [K in keyof T]: T[K] extends Promise<infer P> ? P : T[K];
}>;
interface SafeExecuteOptions<T> {
    handler: () => T;
    onSuccess?: (result: T) => void;
    onError?: (err: Error) => void;
}
declare function safeExecute<T>({ handler, onError, onSuccess }: SafeExecuteOptions<T>): void;
declare function asyncExecute<R>(handler: () => R): Promise<R>;
declare class LazyPromise<R> implements Promise<R> {
    protected readonly handler: () => Promise<R>;
    constructor(handler: () => Promise<R>);
    readonly [Symbol.toStringTag] = "Promise";
    protected before(): Promise<void>;
    then<TResult1 = R, TResult2 = never>(onfulfilled?: ((value: R) => PromiseLike<TResult1> | TResult1) | undefined | null, onrejected?: ((reason: any) => PromiseLike<TResult2> | TResult2) | undefined | null): Promise<TResult1 | TResult2>;
    catch<TResult = never>(onrejected?: ((reason: any) => PromiseLike<TResult> | TResult) | undefined | null): Promise<R | TResult>;
    finally(onfinally?: (() => void) | undefined | null): Promise<R>;
}
declare function signalRace<R>(fn: () => Promise<R>, signal?: AbortSignal, onAbort?: () => void): Promise<R>;
declare function executeSequentially(tasks: (() => Promise<any>)[]): Promise<void>;

export { type EmitterToGeneratorFn, LazyPromise, arrayFromAsync, asyncExecute, asyncProperties, emitterToGenerator, executeSequentially, isPromiseLike, safeExecute, signalRace };
