'use strict';

var R = require('remeda');
var errors_cjs = require('../../errors.cjs');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var R__namespace = /*#__PURE__*/_interopNamespace(R);

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
function assignFactory(target) {
  return (source) => {
    Object.assign(target, source);
  };
}
__name(assignFactory, "assignFactory");
const assign = /* @__PURE__ */ __name((a, b) => assignFactory(a)(b), "assign");
const omitEmptyValues = R__namespace.pickBy(R__namespace.isTruthy);
const omitUndefined = R__namespace.pickBy(R__namespace.isDefined);
function hasProp(target, key) {
  return Boolean(target) && Object.prototype.hasOwnProperty.call(target, key);
}
__name(hasProp, "hasProp");
function hasProps(keys) {
  return (target) => keys.every((key) => hasProp(target, key));
}
__name(hasProps, "hasProps");
function setProp(target, paths, value) {
  for (const entry of paths.entries()) {
    const [idx, key] = entry;
    if (!R__namespace.isPlainObject(target) && !R__namespace.isArray(target)) {
      throw new TypeError("Only plain objects and arrays are supported!");
    }
    const isLast = idx === paths.length - 1;
    const newValue = isLast ? value : target[key] ?? {};
    Object.assign(target, {
      [key]: newValue
    });
    target = target[key];
  }
}
__name(setProp, "setProp");
function getPropStrict(target, path) {
  if (!target || !(path in target)) {
    throw new TypeError(`Target does not contain key "${path}"`);
  }
  return target[path];
}
__name(getPropStrict, "getPropStrict");
function getProp(target, paths, defaultValue = void 0) {
  let value = target;
  if (!value) {
    return void 0;
  }
  for (const key of paths) {
    if (!hasProp(value, key)) {
      return defaultValue;
    }
    value = value[key];
  }
  return value;
}
__name(getProp, "getProp");
function deleteProps(target, keys) {
  keys.forEach((key) => {
    delete target[key];
  });
}
__name(deleteProps, "deleteProps");
function updateObject(old, update) {
  for (const [key, val] of Object.entries(update)) {
    const existing = old[key];
    if (existing !== void 0 && existing !== null) {
      throw new errors_cjs.FrameworkError(`Cannot update object. Key '${key}' already exists and is defined.`, [], {
        context: {
          existing,
          update: val
        }
      });
    }
    old[key] = val;
  }
}
__name(updateObject, "updateObject");
function createNonOverridableObject(target) {
  return new Proxy(target, {
    set(target2, k, v) {
      const existingValue = target2[k];
      if (existingValue === void 0 || existingValue === null) {
        target2[k] = v;
        return true;
      }
      console.error(`Property '${String(k)}' already exists. Cannot set value.`);
      return false;
    }
  });
}
__name(createNonOverridableObject, "createNonOverridableObject");
function customMerge(results, processors) {
  if (results.length === 0) {
    throw new TypeError("Cannot merge content of an empty array!");
  }
  const finalResult = {};
  for (const next of results) {
    for (const [key, value] of R__namespace.entries(next)) {
      const oldValue = finalResult[key];
      finalResult[key] = (processors[key] ?? R__namespace.takeFirstBy(1))(value, oldValue);
    }
  }
  return finalResult;
}
__name(customMerge, "customMerge");

exports.assign = assign;
exports.assignFactory = assignFactory;
exports.createNonOverridableObject = createNonOverridableObject;
exports.customMerge = customMerge;
exports.deleteProps = deleteProps;
exports.getProp = getProp;
exports.getPropStrict = getPropStrict;
exports.hasProp = hasProp;
exports.hasProps = hasProps;
exports.omitEmptyValues = omitEmptyValues;
exports.omitUndefined = omitUndefined;
exports.setProp = setProp;
exports.updateObject = updateObject;
//# sourceMappingURL=object.cjs.map
//# sourceMappingURL=object.cjs.map