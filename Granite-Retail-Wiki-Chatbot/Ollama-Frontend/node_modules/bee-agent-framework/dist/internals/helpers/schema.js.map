{"version":3,"sources":["../../../src/internals/helpers/schema.ts"],"names":["validateSchema","schema","errorOptions","ZodEffects","ValueError","toJsonSchema","options","ZodType","zodToJsonSchema","createSchemaValidator","jsonSchema","ajv","Ajv","coerceTypes","useDefaults","strict","strictSchema","strictTuples","strictNumbers","strictTypes","strictRequired","parseDate","allowDate","allowUnionTypes","addFormats","default","compile","parseBrokenJson","input","trim","JSON","parse","pair","outer","findFirstPair","jsonrepair"],"mappings":";;;;;;;;;;AA4BO,SAASA,cAAAA,CACdC,QACAC,YAAoC,EAAA;AAEpC,EAAID,IAAAA,MAAAA,IAAUA,kBAAkBE,UAAY,EAAA;AAC1C,IAAA,MAAM,IAAIC,UAAAA,CACR,sFACA,EAAA,IACAF,YAAAA,CAAAA;AAEJ;AACF;AAXgBF,MAAAA,CAAAA,cAAAA,EAAAA,gBAAAA,CAAAA;AAaT,SAASK,YAAAA,CACdJ,QACAK,OAA0B,EAAA;AAE1BN,EAAAA,cAAAA,CAAeC,MAAAA,CAAAA;AACf,EAAA,IAAIA,kBAAkBM,OAAS,EAAA;AAC7B,IAAOC,OAAAA,eAAAA,CAAgBP,QAAQK,OAAAA,CAAAA;AACjC;AACA,EAAOL,OAAAA,MAAAA;AACT;AATgBI,MAAAA,CAAAA,YAAAA,EAAAA,cAAAA,CAAAA;AAWT,SAASI,qBAAAA,CACdR,QACAK,OAAoB,EAAA;AAEpB,EAAMI,MAAAA,UAAAA,GAAaL,aAAaJ,MAAAA,CAAAA;AAEhC,EAAMU,MAAAA,GAAAA,GAAM,IAAIC,GAAI,CAAA;IAClBC,WAAa,EAAA,OAAA;IACbC,WAAa,EAAA,IAAA;IACbC,MAAQ,EAAA,KAAA;IACRC,YAAc,EAAA,KAAA;IACdC,YAAc,EAAA,IAAA;IACdC,aAAe,EAAA,IAAA;IACfC,WAAa,EAAA,IAAA;IACbC,cAAgB,EAAA,IAAA;IAChBC,SAAW,EAAA,IAAA;IACXC,SAAW,EAAA,IAAA;IACXC,eAAiB,EAAA,IAAA;IACjB,GAAGjB;GACL,CAAA;AACAkB,EAAAA,UAAAA,CAAWC,QAAQd,GAAAA,CAAAA;AACnB,EAAOA,OAAAA,GAAAA,CAAIe,QAA2BhB,UAAAA,CAAAA;AACxC;AAtBgBD,MAAAA,CAAAA,qBAAAA,EAAAA,uBAAAA,CAAAA;AA2BT,SAASkB,eAAAA,CAAgBC,OAA2BtB,OAAgC,EAAA;AACzFsB,EAASA,KAAAA,GAAAA,CAAAA,KAAAA,IAAS,KAAKC,IAAAA,EAAAA;AAEvB,EAAI,IAAA;AACF,IAAI,IAAA;AACF,MAAOC,OAAAA,IAAAA,CAAKC,MAAMH,KAAAA,CAAAA;KACZ,CAAA,MAAA;AACN,MAAA,MAAMI,OAAO1B,OAAS0B,EAAAA,IAAAA;AACtB,MAAA,IAAIA,IAAM,EAAA;AACR,QAAA,MAAM,EAAEC,KAAK,EAAA,GAAKC,aAAcN,CAAAA,KAAAA,EAAOI,IAAAA,CAAS,IAAA;UAAEC,KAAOL,EAAAA;AAAM,SAAA;AAC/D,QAAA,OAAOE,IAAKC,CAAAA,KAAAA,CAAMI,UAAWF,CAAAA,KAAAA,CAAAA,CAAAA;OACxB,MAAA;AACL,QAAA,OAAOH,IAAKC,CAAAA,KAAAA,CAAMI,UAAWP,CAAAA,KAAAA,CAAAA,CAAAA;AAC/B;AACF;GACM,CAAA,MAAA;AACN,IAAO,OAAA,IAAA;AACT;AACF;AAlBgBD,MAAAA,CAAAA,eAAAA,EAAAA,iBAAAA,CAAAA","file":"schema.js","sourcesContent":["/**\n * Copyright 2024 IBM Corp.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { TypeOf, ZodType, ZodEffects, ZodTypeAny, AnyZodObject, input } from \"zod\";\nimport { zodToJsonSchema, Options } from \"zod-to-json-schema\";\nimport { Ajv, SchemaObject, ValidateFunction, Options as AjvOptions } from \"ajv\";\nimport addFormats from \"ajv-formats\";\nimport { findFirstPair } from \"@/internals/helpers/string.js\";\nimport { FrameworkErrorOptions, ValueError } from \"@/errors.js\";\nimport { jsonrepair } from \"jsonrepair\";\nexport type AnyToolSchemaLike = AnyZodObject | SchemaObject;\nexport type AnySchemaLike = ZodTypeAny | SchemaObject;\nexport type FromSchemaLike<T> = T extends ZodTypeAny ? TypeOf<T> : unknown;\nexport type FromSchemaLikeRaw<T> = T extends ZodTypeAny ? input<T> : unknown;\n\nexport function validateSchema<T extends AnySchemaLike>(\n  schema: T | ZodEffects<any>,\n  errorOptions?: FrameworkErrorOptions,\n): asserts schema is T {\n  if (schema && schema instanceof ZodEffects) {\n    throw new ValueError(\n      \"zod effects (refine, superRefine, transform, ...) cannot be converted to JSONSchema!\",\n      [],\n      errorOptions,\n    );\n  }\n}\n\nexport function toJsonSchema<T extends AnySchemaLike>(\n  schema: T,\n  options?: Partial<Options>,\n): SchemaObject {\n  validateSchema(schema);\n  if (schema instanceof ZodType) {\n    return zodToJsonSchema(schema, options);\n  }\n  return schema;\n}\n\nexport function createSchemaValidator<T extends AnySchemaLike>(\n  schema: T,\n  options?: AjvOptions,\n): ValidateFunction<FromSchemaLike<T>> {\n  const jsonSchema = toJsonSchema(schema);\n\n  const ajv = new Ajv({\n    coerceTypes: \"array\",\n    useDefaults: true,\n    strict: false,\n    strictSchema: false,\n    strictTuples: true,\n    strictNumbers: true,\n    strictTypes: true,\n    strictRequired: true,\n    parseDate: true,\n    allowDate: true,\n    allowUnionTypes: true,\n    ...options,\n  });\n  addFormats.default(ajv);\n  return ajv.compile<FromSchemaLike<T>>(jsonSchema);\n}\n\ninterface ParseBrokenJsonOptions {\n  pair?: [string, string] | null;\n}\nexport function parseBrokenJson(input: string | undefined, options?: ParseBrokenJsonOptions) {\n  input = (input ?? \"\")?.trim();\n\n  try {\n    try {\n      return JSON.parse(input);\n    } catch {\n      const pair = options?.pair;\n      if (pair) {\n        const { outer } = findFirstPair(input, pair) ?? { outer: input };\n        return JSON.parse(jsonrepair(outer));\n      } else {\n        return JSON.parse(jsonrepair(input));\n      }\n    }\n  } catch {\n    return null;\n  }\n}\n"]}