import { FrameworkError } from '../errors.js';
import { Serializable } from './serializable.js';
import { EventSourceMessage } from '@ai-zen/node-fetch-event-source';
import { FetchEventSourceInit } from '@ai-zen/node-fetch-event-source/lib/cjs/fetch.js';
import { C as Callback, E as Emitter } from '../emitter-DRfJC1TP.js';
import './types.js';
import './helpers/guards.js';

/**
 * Copyright 2024 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare class RestfulClientError extends FrameworkError {
}
type URLParamType = string | number | boolean | null | undefined;
declare function createURLParams(data: Record<string, URLParamType | URLParamType[] | Record<string, any>>): URLSearchParams;
interface FetchInput {
    url: string;
    options: RequestInit;
}
interface StreamInput {
    url: string;
    options: FetchEventSourceInit;
}
interface RestfulClientEvents {
    fetchStart: Callback<{
        input: FetchInput;
    }>;
    fetchError: Callback<{
        error: Error;
        input: FetchInput;
    }>;
    fetchSuccess: Callback<{
        response: Response;
        data: any;
        input: FetchInput;
    }>;
    fetchDone: Callback<{
        input: FetchInput;
    }>;
    streamStart: Callback<{
        input: StreamInput;
    }>;
    streamOpen: Callback<{
        input: StreamInput;
    }>;
    streamSuccess: Callback<{
        input: StreamInput;
    }>;
    streamMessage: Callback<{
        data: EventSourceMessage;
        input: StreamInput;
    }>;
    streamError: Callback<{
        error: Error;
        input: StreamInput;
    }>;
    streamDone: Callback<{
        input: StreamInput;
    }>;
}
declare class RestfulClient<K extends Record<string, string>> extends Serializable {
    protected input: {
        baseUrl: string;
        headers: () => Promise<Headers>;
        paths: K;
    };
    readonly emitter: Emitter<RestfulClientEvents>;
    constructor(input: {
        baseUrl: string;
        headers: () => Promise<Headers>;
        paths: K;
    });
    stream(path: keyof K, init: FetchEventSourceInit): AsyncGenerator<EventSourceMessage, void, void>;
    fetch(path: keyof K, init?: RequestInit & {
        searchParams?: URLSearchParams;
    }): Promise<any>;
    createSnapshot(): {
        input: {
            baseUrl: string;
            headers: () => Promise<Headers>;
            paths: K;
        };
        emitter: Emitter<RestfulClientEvents>;
    };
    loadSnapshot(snapshot: ReturnType<typeof this.createSnapshot>): void;
}

export { RestfulClient, RestfulClientError, type RestfulClientEvents, type StreamInput, createURLParams };
