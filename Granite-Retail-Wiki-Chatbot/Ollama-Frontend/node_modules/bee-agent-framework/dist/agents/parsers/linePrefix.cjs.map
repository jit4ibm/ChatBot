{"version":3,"sources":["../../../src/agents/parsers/linePrefix.ts"],"names":["NEW_LINE_CHARACTER","trimLeftSpaces","value","replace","linesToString","lines","reduce","acc","newLine","concat","LinePrefixParser","Serializable","emitter","excludedLines","done","lastNodeKey","finalState","partialState","isDone","constructor","nodes","options","Emitter","creator","namespace","hasStartNode","hasEndNode","key","next","isStart","isEnd","entries","Boolean","nextKey","ValueError","fork","customizer","add","chunk","split","forEach","line","i","arr","isFirstLine","length","push","at","isLastLine","lastNode","isTerminationNode","parsedLine","extractLine","partial","shift","includes","endOnRepeat","end","throwWithContext","LinePrefixParserError","Reason","InvalidTransition","emitFinalUpdate","field","waitForStartNode","NotStartNode","node","write","emitPartialUpdate","getPartial","delta","raw","message","reason","extra","join","errors","context","fallback","stash","splice","Infinity","map","prefix","NoDataReceived","currentNode","NotEndNode","Promise","allSettled","Object","values","data","AlreadyCompleted","emit","get","e","ZodError","InvalidSchema","normalizedNodes","sort","_","a","__","b","lowerCasePrefix","toLowerCase","ref","trimmedLine","startsWith","substring","createSnapshot","shallowCopy","loadSnapshot","snapshot","assign"],"mappings":"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","file":"linePrefix.cjs","sourcesContent":["/**\n * Copyright 2024 IBM Corp.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Emitter } from \"@/emitter/emitter.js\";\nimport { entries } from \"remeda\";\nimport { ValueError } from \"@/errors.js\";\nimport { Serializable } from \"@/internals/serializable.js\";\nimport { shallowCopy } from \"@/serializer/utils.js\";\nimport { Cache } from \"@/cache/decoratorCache.js\";\nimport { ParserField } from \"@/agents/parsers/field.js\";\nimport { Callback, InferCallbackValue } from \"@/emitter/types.js\";\nimport { ZodError } from \"zod\";\nimport { ValueOf } from \"@/internals/types.js\";\nimport { LinePrefixParserError } from \"@/agents/parsers/errors.js\";\nexport * from \"@/agents/parsers/errors.js\";\n\nexport interface ParserNode<T extends string, P extends ParserField<any, any>> {\n  prefix: string;\n  next: readonly T[];\n  isStart?: boolean;\n  isEnd?: boolean;\n  field: P;\n}\n\ntype Customizer<T extends NonNullable<unknown>, T2 extends NonNullable<unknown> = T> = (\n  nodes: T,\n  options: Options<T>,\n) => { nodes: T2; options: Options<T2> };\n\ntype StringKey<T extends NonNullable<unknown>> = Extract<keyof T, string>;\n\ninterface Callbacks<T extends Record<string, ParserNode<StringKey<T>, ParserField<any, any>>>> {\n  update: Callback<\n    {\n      [K in StringKey<T>]: {\n        key: K;\n        value: ParserField.inferValue<T[K][\"field\"]>;\n        field: T[K][\"field\"];\n      };\n    }[StringKey<T>]\n  >;\n  partialUpdate: Callback<\n    {\n      [K in StringKey<T>]: {\n        key: K;\n        delta: string;\n        value: ParserField.inferPartialValue<T[K][\"field\"]>;\n        field: T[K][\"field\"];\n      };\n    }[StringKey<T>]\n  >;\n}\n\ninterface Line {\n  value: string;\n  newLine: boolean;\n}\n\nconst NEW_LINE_CHARACTER = \"\\n\" as const;\n\ninterface ExtractedLine<T extends NonNullable<unknown>> {\n  key: StringKey<T>;\n  value: string;\n  partial: boolean;\n}\n\nconst trimLeftSpaces = (value: string) => value.replace(/^\\s*/g, \"\");\nconst linesToString = (lines: Line[]) =>\n  lines.reduce(\n    (acc, { newLine, value }) => `${acc}${newLine ? NEW_LINE_CHARACTER.concat(value) : value}`,\n    \"\",\n  );\n\ninterface Options<T extends NonNullable<unknown>> {\n  fallback?: (value: string) => readonly { key: StringKey<T>; value: string }[];\n  endOnRepeat?: boolean;\n  waitForStartNode?: boolean;\n}\n\ntype Input<K extends string = string> = Record<string, ParserNode<K, ParserField<any, any>>>;\n\nexport class LinePrefixParser<T extends Input<StringKey<T>>> extends Serializable {\n  public readonly emitter = new Emitter<Callbacks<T>>({\n    creator: this,\n    namespace: [\"agent\", \"parser\", \"line\"],\n  });\n\n  protected readonly lines: Line[] = [];\n  protected readonly excludedLines: Line[] = [];\n  protected done = false;\n  protected lastNodeKey: StringKey<T> | null = null;\n\n  public readonly finalState = {} as LinePrefixParser.infer<T>;\n  public readonly partialState = {} as Partial<Record<StringKey<T>, string>>;\n\n  get isDone() {\n    return this.done;\n  }\n\n  constructor(\n    protected readonly nodes: T,\n    protected readonly options: Options<T> = {},\n  ) {\n    super();\n\n    let hasStartNode = false;\n    let hasEndNode = false;\n\n    for (const [key, { next, isStart, isEnd }] of entries(nodes ?? {})) {\n      hasStartNode = Boolean(hasStartNode || isStart);\n      hasEndNode = Boolean(hasEndNode || isEnd);\n\n      for (const nextKey of next) {\n        if (key === nextKey) {\n          throw new ValueError(`Node '${key}' cannot point to itself.`);\n        }\n        if (!(nextKey in nodes)) {\n          throw new ValueError(\n            `Node '${key}' contains a transition to non-existing node '${nextKey}'.`,\n          );\n        }\n      }\n    }\n\n    if (!hasStartNode) {\n      throw new ValueError(`At least one start node must be provided!`);\n    }\n    if (!hasEndNode) {\n      throw new ValueError(`At least one end node must be provided!`);\n    }\n  }\n\n  fork<R extends T = T>(customizer: Customizer<T, R>) {\n    const { nodes, options } = customizer(this.nodes, this.options);\n    return new LinePrefixParser(nodes, options);\n  }\n\n  async add(chunk: string) {\n    if (!chunk || this.done) {\n      return;\n    }\n\n    chunk.split(NEW_LINE_CHARACTER).forEach((line, i, arr) => {\n      const isFirstLine = i === 0;\n\n      if (isFirstLine) {\n        if (this.lines.length === 0) {\n          this.lines.push({ newLine: false, value: line });\n        } else {\n          this.lines.at(-1)!.value += line;\n        }\n      } else {\n        this.lines.push({ newLine: arr.length > 1, value: line });\n      }\n    });\n\n    while (this.lines.length > 0) {\n      const line = this.lines[0];\n      const isLastLine = this.lines.length === 1;\n\n      const lastNode = this.lastNodeKey ? this.nodes[this.lastNodeKey] : null;\n      const isTerminationNode = lastNode\n        ? Boolean(lastNode.isEnd && lastNode.next.length === 0)\n        : false;\n\n      const parsedLine =\n        isTerminationNode || (lastNode && !line.newLine) ? null : this.extractLine(line.value);\n\n      if (isLastLine && (parsedLine?.partial || !line.value)) {\n        break;\n      }\n      this.lines.shift();\n\n      if (parsedLine && !parsedLine.partial) {\n        if (lastNode) {\n          if (!lastNode.next.includes(parsedLine.key)) {\n            if (parsedLine.key in this.finalState && this.options.endOnRepeat && lastNode.isEnd) {\n              await this.end();\n              return;\n            }\n\n            this.throwWithContext(\n              `Transition from '${this.lastNodeKey}' to '${parsedLine.key}' does not exist!`,\n              LinePrefixParserError.Reason.InvalidTransition,\n              { line },\n            );\n          }\n\n          await this.emitFinalUpdate(this.lastNodeKey!, lastNode.field);\n        } else if (!this.nodes[parsedLine.key].isStart) {\n          if (!this.options.waitForStartNode) {\n            this.throwWithContext(\n              `Parsed text line corresponds to a node \"${parsedLine.key}\" which is not a start node!`,\n              LinePrefixParserError.Reason.NotStartNode,\n              { line },\n            );\n          }\n          this.excludedLines.push(line);\n          continue;\n        }\n\n        const node = this.nodes[parsedLine.key];\n        node.field.write(parsedLine.value);\n        await this.emitPartialUpdate({\n          key: parsedLine.key,\n          value: node.field.getPartial(),\n          delta: parsedLine.value,\n          field: node.field,\n        });\n        this.lastNodeKey = parsedLine.key;\n      } else if (this.lastNodeKey) {\n        if (!this.nodes[this.lastNodeKey].field.raw) {\n          line.value = trimLeftSpaces(line.value);\n        }\n        if (line.newLine) {\n          line.value = `${NEW_LINE_CHARACTER}${line.value}`;\n        }\n\n        const node = this.nodes[this.lastNodeKey];\n        node.field.write(line.value);\n        await this.emitPartialUpdate({\n          key: this.lastNodeKey,\n          value: node.field.getPartial(),\n          delta: line.value,\n          field: node.field,\n        });\n      } else {\n        this.excludedLines.push(line);\n      }\n    }\n  }\n\n  protected throwWithContext(\n    message: string,\n    reason: ValueOf<typeof LinePrefixParserError.Reason>,\n    extra: { line?: Line; errors?: Error[] } = {},\n  ): never {\n    throw new LinePrefixParserError(\n      [`The generated output does not adhere to the schema.`, message].join(NEW_LINE_CHARACTER),\n      extra.errors ?? [],\n      {\n        reason,\n        context: {\n          lines: linesToString(this.lines.concat(extra.line ? [extra.line] : [])),\n          excludedLines: linesToString(this.excludedLines),\n          finalState: this.finalState,\n          partialState: this.partialState,\n        },\n      },\n    );\n  }\n\n  async end() {\n    if (this.done) {\n      return this.finalState;\n    }\n\n    if (!this.lastNodeKey && this.options.fallback) {\n      const stash = linesToString([\n        ...this.excludedLines.splice(0, Infinity),\n        ...this.lines.splice(0, Infinity),\n      ]);\n\n      const nodes = this.options.fallback(stash);\n      await this.add(\n        nodes.map((node) => `${this.nodes[node.key].prefix}${node.value}`).join(NEW_LINE_CHARACTER),\n      );\n    }\n\n    this.done = true;\n\n    if (!this.lastNodeKey) {\n      this.throwWithContext(\n        \"Nothing valid has been parsed yet!\",\n        LinePrefixParserError.Reason.NoDataReceived,\n      );\n    }\n\n    const stash = linesToString(this.lines);\n    this.lines.length = 0;\n\n    const field = this.nodes[this.lastNodeKey].field!;\n    if (stash) {\n      field.write(stash);\n      await this.emitPartialUpdate({\n        key: this.lastNodeKey,\n        value: field.getPartial(),\n        delta: stash,\n        field,\n      });\n    }\n    await this.emitFinalUpdate(this.lastNodeKey, field);\n\n    const currentNode = this.nodes[this.lastNodeKey];\n    if (!currentNode.isEnd) {\n      this.throwWithContext(\n        `Node '${this.lastNodeKey}' is not an end node.`,\n        LinePrefixParserError.Reason.NotEndNode,\n      );\n    }\n\n    await Promise.allSettled(Object.values(this.nodes).map(({ field }) => field.end()));\n    return this.finalState;\n  }\n\n  protected async emitPartialUpdate(data: InferCallbackValue<Callbacks<T>[\"partialUpdate\"]>) {\n    if (data.key in this.finalState) {\n      this.throwWithContext(\n        `Cannot update partial event for completed key '${data.key}'`,\n        LinePrefixParserError.Reason.AlreadyCompleted,\n      );\n    }\n    if (!(data.key in this.partialState)) {\n      this.partialState[data.key] = \"\";\n    }\n    this.partialState[data.key] += data.delta;\n    await this.emitter.emit(\"partialUpdate\", data);\n  }\n\n  protected async emitFinalUpdate(key: StringKey<T>, field: ParserField<any, any>) {\n    if (key in this.finalState) {\n      this.throwWithContext(\n        `Duplicated key '${key}'`,\n        LinePrefixParserError.Reason.AlreadyCompleted,\n      );\n    }\n\n    try {\n      const value = field.get();\n      this.finalState[key] = value;\n      await this.emitter.emit(\"update\", {\n        key,\n        field,\n        value,\n      });\n    } catch (e) {\n      if (e instanceof ZodError) {\n        this.throwWithContext(\n          `Value for '${key}' cannot be retrieved because it's value does not adhere to the appropriate schema.`,\n          LinePrefixParserError.Reason.InvalidSchema,\n          { errors: [e] },\n        );\n      }\n      throw e;\n    }\n  }\n\n  @Cache()\n  protected get normalizedNodes() {\n    return entries(this.nodes)\n      .sort(([_, a], [__, b]) => a.prefix.length - b.prefix.length)\n      .map(([key, value]) => {\n        return [key, { lowerCasePrefix: value.prefix.toLowerCase(), ref: value }] as const;\n      });\n  }\n\n  protected extractLine(line: string): ExtractedLine<T> | null {\n    const trimmedLine = trimLeftSpaces(line);\n    if (!trimmedLine) {\n      return null;\n    }\n\n    for (const [key, node] of this.normalizedNodes) {\n      const partial = node.lowerCasePrefix.length > trimmedLine.length;\n      const [a, b] = partial\n        ? [node.lowerCasePrefix, trimmedLine]\n        : [trimmedLine, node.lowerCasePrefix];\n\n      if (a.toLowerCase().startsWith(b.toLowerCase())) {\n        return {\n          key: key as StringKey<T>,\n          value: partial ? trimmedLine : trimLeftSpaces(a.substring(b.length)),\n          partial,\n        };\n      }\n    }\n    return null;\n  }\n\n  createSnapshot() {\n    return {\n      nodes: shallowCopy(this.nodes),\n      lines: shallowCopy(this.lines),\n      emitter: this.emitter,\n      done: this.done,\n      lastNodeKey: this.lastNodeKey,\n      options: this.options,\n    };\n  }\n\n  loadSnapshot(snapshot: ReturnType<typeof this.createSnapshot>) {\n    return Object.assign(this, snapshot);\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace LinePrefixParser {\n  export type infer<T extends Record<string, ParserNode<StringKey<T>, ParserField<any, any>>>> = {\n    [K in keyof T]: ParserField.inferValue<T[K][\"field\"]>;\n  };\n  export type inferPartial<\n    T extends Record<string, ParserNode<StringKey<T>, ParserField<any, any>>>,\n  > = {\n    [K in StringKey<T>]: ParserField.inferPartialValue<T[K][\"field\"]>;\n  };\n\n  export type inferCallback<T> =\n    T extends LinePrefixParser<any> ? (T[\"emitter\"] extends Emitter<infer L> ? L : never) : never;\n\n  export type inferOutput<T> =\n    T extends LinePrefixParser<infer P> ? LinePrefixParser.infer<P> : never;\n\n  export type inferPartialOutput<T> =\n    T extends LinePrefixParser<infer P> ? LinePrefixParser.inferPartial<P> : never;\n\n  export type define<T extends Record<string, ParserField<any, any>>> = {\n    [K in StringKey<T>]: ParserNode<StringKey<T>, T[K]>;\n  };\n}\n"]}