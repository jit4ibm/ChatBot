import { E as Emitter, I as InferCallbackValue, C as Callback } from '../../emitter-DRfJC1TP.js';
import { Serializable } from '../../internals/serializable.js';
import { ParserField } from './field.js';
import { ValueOf } from '../../internals/types.js';
import { LinePrefixParserError } from './errors.js';
import '../../internals/helpers/guards.js';
import 'zod';
import '@streamparser/json';
import 'jsonrepair/stream';
import '../../errors.js';

/**
 * Copyright 2024 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

interface ParserNode<T extends string, P extends ParserField<any, any>> {
    prefix: string;
    next: readonly T[];
    isStart?: boolean;
    isEnd?: boolean;
    field: P;
}
type Customizer<T extends NonNullable<unknown>, T2 extends NonNullable<unknown> = T> = (nodes: T, options: Options<T>) => {
    nodes: T2;
    options: Options<T2>;
};
type StringKey<T extends NonNullable<unknown>> = Extract<keyof T, string>;
interface Callbacks<T extends Record<string, ParserNode<StringKey<T>, ParserField<any, any>>>> {
    update: Callback<{
        [K in StringKey<T>]: {
            key: K;
            value: ParserField.inferValue<T[K]["field"]>;
            field: T[K]["field"];
        };
    }[StringKey<T>]>;
    partialUpdate: Callback<{
        [K in StringKey<T>]: {
            key: K;
            delta: string;
            value: ParserField.inferPartialValue<T[K]["field"]>;
            field: T[K]["field"];
        };
    }[StringKey<T>]>;
}
interface Line {
    value: string;
    newLine: boolean;
}
interface ExtractedLine<T extends NonNullable<unknown>> {
    key: StringKey<T>;
    value: string;
    partial: boolean;
}
interface Options<T extends NonNullable<unknown>> {
    fallback?: (value: string) => readonly {
        key: StringKey<T>;
        value: string;
    }[];
    endOnRepeat?: boolean;
    waitForStartNode?: boolean;
}
type Input<K extends string = string> = Record<string, ParserNode<K, ParserField<any, any>>>;
declare class LinePrefixParser<T extends Input<StringKey<T>>> extends Serializable {
    protected readonly nodes: T;
    protected readonly options: Options<T>;
    readonly emitter: Emitter<Callbacks<T>>;
    protected readonly lines: Line[];
    protected readonly excludedLines: Line[];
    protected done: boolean;
    protected lastNodeKey: StringKey<T> | null;
    readonly finalState: LinePrefixParser.infer<T>;
    readonly partialState: Partial<Record<StringKey<T>, string>>;
    get isDone(): boolean;
    constructor(nodes: T, options?: Options<T>);
    fork<R extends T = T>(customizer: Customizer<T, R>): LinePrefixParser<R>;
    add(chunk: string): Promise<void>;
    protected throwWithContext(message: string, reason: ValueOf<typeof LinePrefixParserError.Reason>, extra?: {
        line?: Line;
        errors?: Error[];
    }): never;
    end(): Promise<LinePrefixParser.infer<T>>;
    protected emitPartialUpdate(data: InferCallbackValue<Callbacks<T>["partialUpdate"]>): Promise<void>;
    protected emitFinalUpdate(key: StringKey<T>, field: ParserField<any, any>): Promise<void>;
    protected get normalizedNodes(): (readonly [string, {
        readonly lowerCasePrefix: string;
        readonly ref: Required<T>[string] | Required<T>[number];
    }])[];
    protected extractLine(line: string): ExtractedLine<T> | null;
    createSnapshot(): {
        nodes: T;
        lines: Line[];
        emitter: Emitter<Callbacks<T>>;
        done: boolean;
        lastNodeKey: Extract<keyof T, string> | null;
        options: Options<T>;
    };
    loadSnapshot(snapshot: ReturnType<typeof this.createSnapshot>): this & {
        nodes: T;
        lines: Line[];
        emitter: Emitter<Callbacks<T>>;
        done: boolean;
        lastNodeKey: Extract<keyof T, string> | null;
        options: Options<T>;
    };
}
declare namespace LinePrefixParser {
    type infer<T extends Record<string, ParserNode<StringKey<T>, ParserField<any, any>>>> = {
        [K in keyof T]: ParserField.inferValue<T[K]["field"]>;
    };
    type inferPartial<T extends Record<string, ParserNode<StringKey<T>, ParserField<any, any>>>> = {
        [K in StringKey<T>]: ParserField.inferPartialValue<T[K]["field"]>;
    };
    type inferCallback<T> = T extends LinePrefixParser<any> ? (T["emitter"] extends Emitter<infer L> ? L : never) : never;
    type inferOutput<T> = T extends LinePrefixParser<infer P> ? LinePrefixParser.infer<P> : never;
    type inferPartialOutput<T> = T extends LinePrefixParser<infer P> ? LinePrefixParser.inferPartial<P> : never;
    type define<T extends Record<string, ParserField<any, any>>> = {
        [K in StringKey<T>]: ParserNode<StringKey<T>, T[K]>;
    };
}

export { LinePrefixParser, LinePrefixParserError, type ParserNode };
