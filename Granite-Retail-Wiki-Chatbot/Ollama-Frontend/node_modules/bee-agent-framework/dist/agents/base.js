import { FrameworkError } from '../errors.js';
import { Serializable } from '../internals/serializable.js';
import { RunContext } from '../context.js';
import { createTelemetryMiddleware } from '../instrumentation/create-telemetry-middleware.js';
import { INSTRUMENTATION_ENABLED } from '../instrumentation/config.js';
import { doNothing } from 'remeda';

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
class AgentError extends FrameworkError {
  static {
    __name(this, "AgentError");
  }
}
class BaseAgent extends Serializable {
  static {
    __name(this, "BaseAgent");
  }
  isRunning = false;
  run(...[input, options]) {
    if (this.isRunning) {
      throw new AgentError("Agent is already running!");
    }
    return RunContext.enter(this, {
      signal: options?.signal,
      params: [
        input,
        options
      ]
    }, async (context) => {
      try {
        return await this._run(input, options, context);
      } catch (e) {
        if (e instanceof AgentError) {
          throw e;
        } else {
          throw new AgentError(`Error has occurred!`, [
            e
          ]);
        }
      } finally {
        this.isRunning = false;
      }
    }).middleware(INSTRUMENTATION_ENABLED ? createTelemetryMiddleware() : doNothing());
  }
  destroy() {
    this.emitter.destroy();
  }
  get meta() {
    return {
      name: this.constructor.name ?? "BaseAgent",
      description: "",
      tools: []
    };
  }
  createSnapshot() {
    return {
      isRunning: false
    };
  }
  loadSnapshot(snapshot) {
    Object.assign(this, snapshot);
  }
}

export { AgentError, BaseAgent };
//# sourceMappingURL=base.js.map
//# sourceMappingURL=base.js.map