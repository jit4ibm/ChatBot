import { BaseAgent } from '../base.js';
import { BaseMessage, Role } from '../../llms/primitives/message.js';
import { Emitter } from '../../emitter/emitter.js';
import { assign } from '../../internals/helpers/object.js';
import * as R from 'remeda';
import { GraniteRunner } from './runners/granite/runner.js';
import { DefaultRunner } from './runners/default/runner.js';
import { ValueError } from '../../errors.js';

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
class BeeAgent extends BaseAgent {
  static {
    __name(this, "BeeAgent");
  }
  input;
  emitter;
  runner;
  constructor(input) {
    super(), this.input = input, this.emitter = Emitter.root.child({
      namespace: [
        "agent",
        "bee"
      ],
      creator: this
    });
    const duplicate = input.tools.find((a, i, arr) => arr.find((b, j) => i !== j && a.name.toUpperCase() === b.name.toUpperCase()));
    if (duplicate) {
      throw new ValueError(`Agent's tools must all have different names. Conflicting tool: ${duplicate.name}.`);
    }
    this.runner = this.input.llm.modelId.includes("granite") ? GraniteRunner : DefaultRunner;
  }
  static {
    this.register();
  }
  get memory() {
    return this.input.memory;
  }
  get meta() {
    const tools = this.input.tools.slice();
    if (this.input.meta) {
      return {
        ...this.input.meta,
        tools
      };
    }
    return {
      name: "Bee",
      tools,
      description: "The Bee framework demonstrates its ability to auto-correct and adapt in real-time, improving the overall reliability and resilience of the system.",
      ...tools.length > 0 && {
        extraDescription: [
          `Tools that I can use to accomplish given task.`,
          ...tools.map((tool) => `Tool '${tool.name}': ${tool.description}.`)
        ].join("\n")
      }
    };
  }
  async _run(input, options = {}, run) {
    const runner = new this.runner(this.input, {
      ...options,
      execution: options?.execution ?? {
        maxRetriesPerStep: 3,
        totalMaxRetries: 20,
        maxIterations: 10
      }
    }, run);
    await runner.init(input);
    let finalMessage;
    while (!finalMessage) {
      const { state, meta, emitter, signal } = await runner.createIteration();
      if (state.tool_name && state.tool_input) {
        const { output, success } = await runner.tool({
          state,
          emitter,
          meta,
          signal
        });
        await runner.memory.add(BaseMessage.of({
          role: Role.ASSISTANT,
          text: runner.templates.assistant.render({
            thought: [
              state.thought
            ].filter(R.isTruthy),
            toolName: [
              state.tool_name
            ].filter(R.isTruthy),
            toolInput: [
              state.tool_input
            ].filter(R.isTruthy).map((call) => JSON.stringify(call)),
            toolOutput: [
              output
            ],
            finalAnswer: [
              state.final_answer
            ].filter(R.isTruthy)
          }),
          meta: {
            success
          }
        }));
        assign(state, {
          tool_output: output
        });
        for (const key of [
          "partialUpdate",
          "update"
        ]) {
          await emitter.emit(key, {
            data: state,
            update: {
              key: "tool_output",
              value: output,
              parsedValue: output
            },
            meta: {
              success,
              ...meta
            },
            memory: runner.memory
          });
        }
      }
      if (state.final_answer) {
        finalMessage = BaseMessage.of({
          role: Role.ASSISTANT,
          text: state.final_answer,
          meta: {
            createdAt: /* @__PURE__ */ new Date()
          }
        });
        await runner.memory.add(finalMessage);
        await emitter.emit("success", {
          data: finalMessage,
          iterations: runner.iterations,
          memory: runner.memory,
          meta
        });
      }
    }
    if (input.prompt !== null) {
      await this.input.memory.add(BaseMessage.of({
        role: Role.USER,
        text: input.prompt,
        meta: {
          createdAt: run.createdAt
        }
      }));
    }
    await this.input.memory.add(finalMessage);
    return {
      result: finalMessage,
      iterations: runner.iterations,
      memory: runner.memory
    };
  }
  createSnapshot() {
    return {
      ...super.createSnapshot(),
      input: this.input,
      emitter: this.emitter,
      runner: this.runner
    };
  }
}

export { BeeAgent };
//# sourceMappingURL=agent.js.map
//# sourceMappingURL=agent.js.map