{"version":3,"sources":["../../../../../src/agents/bee/runners/default/runner.ts"],"names":["DefaultRunner","BaseRunner","register","llm","signal","meta","emitter","tempMessageKey","Retryable","onRetry","emit","onError","error","failedAttemptsCounter","use","LinePrefixParserError","reason","Reason","NoDataReceived","memory","add","BaseMessage","of","role","Role","ASSISTANT","text","templates","schemaError","render","executor","tools","input","slice","parser","parserRegex","createParser","llmOutput","generate","messages","stream","guided","regex","source","observe","llmEmitter","on","value","key","field","isDone","data","finalState","update","raw","parsedValue","success","delta","callbacks","abort","getTextContent","partialState","tool_output","undefined","end","deleteMany","filter","msg","getProp","state","config","maxRetries","options","execution","maxRetriesPerStep","get","tool","find","name","trim","toUpperCase","tool_name","AgentError","context","output","toolNotFoundError","iteration","tool_input","FrameworkError","ensure","toolOptions","shallowCopy","toolOutput","run","Tool","contextKeys","Memory","result","isEmpty","toolNoResultError","ToolInputValidationError","toolInputError","toString","ToolError","toolError","explain","renderers","self","user","message","prompt","USER","userEmpty","createdAt","Date","system","variables","Promise","all","map","description","replaceAll","replace","concat","schema","JSON","stringify","getInputJsonSchema","ignoredKeys","Set","has","SYSTEM","instructions","toISOString","initMemory","history","prevConversation","isTruthy","BeeUserEmptyPrompt","BeeUserPrompt","TokenMemory","capacityThreshold","syncThreshold","handlers","removalSelector","curMessages","prevConversationMessage","includes","last","lastMessage","length","addMany","customTemplates","BeeSystemPrompt","assistant","BeeAssistantPrompt","BeeToolErrorPrompt","BeeToolInputErrorPrompt","BeeToolNoResultsPrompt","BeeToolNotFoundPrompt","BeeSchemaErrorPrompt","RegExp","join","LinePrefixParser","thought","prefix","next","isStart","ZodParserField","z","string","min","pipeline","enum","isEnd","JSONParserField","object","passthrough","base","matchPair","final_answer","waitForStartNode","endOnRepeat","fallback","stash","enumerable"],"mappings":"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","file":"runner.cjs","sourcesContent":["/**\n * Copyright 2024 IBM Corp.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { BaseRunner, BeeRunnerLLMInput, BeeRunnerToolInput } from \"@/agents/bee/runners/base.js\";\nimport type {\n  BeeAgentRunIteration,\n  BeeAgentTemplates,\n  BeeParserInput,\n  BeeRunInput,\n} from \"@/agents/bee/types.js\";\nimport { Retryable } from \"@/internals/helpers/retryable.js\";\nimport { AgentError } from \"@/agents/base.js\";\nimport {\n  BeeAssistantPrompt,\n  BeeSchemaErrorPrompt,\n  BeeSystemPrompt,\n  BeeToolErrorPrompt,\n  BeeToolInputErrorPrompt,\n  BeeToolNoResultsPrompt,\n  BeeToolNotFoundPrompt,\n  BeeUserEmptyPrompt,\n  BeeUserPrompt,\n} from \"@/agents/bee/prompts.js\";\nimport { AnyTool, Tool, ToolError, ToolInputValidationError, ToolOutput } from \"@/tools/base.js\";\nimport { FrameworkError } from \"@/errors.js\";\nimport { isEmpty, isTruthy, last } from \"remeda\";\nimport { LinePrefixParser, LinePrefixParserError } from \"@/agents/parsers/linePrefix.js\";\nimport { JSONParserField, ZodParserField } from \"@/agents/parsers/field.js\";\nimport { z } from \"zod\";\nimport { BaseMessage, Role } from \"@/llms/primitives/message.js\";\nimport { TokenMemory } from \"@/memory/tokenMemory.js\";\nimport { getProp } from \"@/internals/helpers/object.js\";\nimport { BaseMemory } from \"@/memory/base.js\";\nimport { Cache } from \"@/cache/decoratorCache.js\";\nimport { shallowCopy } from \"@/serializer/utils.js\";\n\nexport class DefaultRunner extends BaseRunner {\n  static {\n    this.register();\n  }\n\n  async llm({ signal, meta, emitter }: BeeRunnerLLMInput): Promise<BeeAgentRunIteration> {\n    const tempMessageKey = \"tempMessage\" as const;\n\n    return new Retryable({\n      onRetry: () => emitter.emit(\"retry\", { meta }),\n      onError: async (error) => {\n        await emitter.emit(\"error\", { error, meta });\n        this.failedAttemptsCounter.use(error);\n\n        if (error instanceof LinePrefixParserError) {\n          // Prevent hanging on EOT\n          if (error.reason === LinePrefixParserError.Reason.NoDataReceived) {\n            await this.memory.add(\n              BaseMessage.of({\n                role: Role.ASSISTANT,\n                text: \"\\n\",\n                meta: {\n                  [tempMessageKey]: true,\n                },\n              }),\n            );\n          } else {\n            await this.memory.add(\n              BaseMessage.of({\n                role: Role.ASSISTANT,\n                text: this.templates.schemaError.render({}),\n                meta: {\n                  [tempMessageKey]: true,\n                },\n              }),\n            );\n          }\n        }\n      },\n      executor: async () => {\n        const tools = this.input.tools.slice();\n        await emitter.emit(\"start\", { meta, tools, memory: this.memory });\n\n        const { parser, parserRegex } = this.createParser(tools);\n        const llmOutput = await this.input.llm\n          .generate(this.memory.messages.slice(), {\n            signal,\n            stream: true,\n            guided: {\n              regex: parserRegex.source,\n            },\n          })\n          .observe((llmEmitter) => {\n            parser.emitter.on(\"update\", async ({ value, key, field }) => {\n              if (key === \"tool_output\" && parser.isDone) {\n                return;\n              }\n              await emitter.emit(\"update\", {\n                data: parser.finalState,\n                update: { key, value: field.raw, parsedValue: value },\n                meta: { success: true, ...meta },\n                memory: this.memory,\n              });\n            });\n            parser.emitter.on(\"partialUpdate\", async ({ key, delta, value }) => {\n              await emitter.emit(\"partialUpdate\", {\n                data: parser.finalState,\n                update: { key, value: delta, parsedValue: value },\n                meta: { success: true, ...meta },\n              });\n            });\n\n            llmEmitter.on(\"newToken\", async ({ value, callbacks }) => {\n              if (parser.isDone) {\n                callbacks.abort();\n                return;\n              }\n\n              await parser.add(value.getTextContent());\n              if (parser.partialState.tool_output !== undefined) {\n                callbacks.abort();\n              }\n            });\n          });\n\n        await parser.end();\n        await this.memory.deleteMany(\n          this.memory.messages.filter((msg) => getProp(msg.meta, [tempMessageKey]) === true),\n        );\n\n        return {\n          state: parser.finalState,\n          raw: llmOutput,\n        };\n      },\n      config: {\n        maxRetries: this.options.execution?.maxRetriesPerStep,\n        signal,\n      },\n    }).get();\n  }\n\n  async tool({ state, signal, meta, emitter }: BeeRunnerToolInput) {\n    const tool = this.input.tools.find(\n      (tool) => tool.name.trim().toUpperCase() == state.tool_name?.trim()?.toUpperCase(),\n    );\n    if (!tool) {\n      this.failedAttemptsCounter.use(\n        new AgentError(`Agent was trying to use non-existing tool \"${state.tool_name}\"`, [], {\n          context: { state, meta },\n        }),\n      );\n\n      return {\n        success: false,\n        output: this.templates.toolNotFoundError.render({\n          tools: this.input.tools,\n        }),\n      };\n    }\n\n    return new Retryable({\n      config: {\n        signal,\n        maxRetries: this.options.execution?.maxRetriesPerStep,\n      },\n      onError: async (error) => {\n        await emitter.emit(\"toolError\", {\n          data: {\n            iteration: state,\n            tool,\n            input: state.tool_input,\n            options: this.options,\n            error: FrameworkError.ensure(error),\n          },\n          meta,\n        });\n        this.failedAttemptsCounter.use(error);\n      },\n      executor: async () => {\n        const toolOptions = shallowCopy(this.options);\n\n        try {\n          await emitter.emit(\"toolStart\", {\n            data: {\n              tool,\n              input: state.tool_input,\n              options: toolOptions,\n              iteration: state,\n            },\n            meta,\n          });\n          const toolOutput: ToolOutput = await tool.run(state.tool_input, toolOptions).context({\n            [Tool.contextKeys.Memory]: this.memory,\n          });\n          await emitter.emit(\"toolSuccess\", {\n            data: {\n              tool,\n              input: state.tool_input,\n              options: toolOptions,\n              result: toolOutput,\n              iteration: state,\n            },\n            meta,\n          });\n\n          if (toolOutput.isEmpty()) {\n            return { output: this.templates.toolNoResultError.render({}), success: true };\n          }\n\n          return {\n            success: true,\n            output: toolOutput.getTextContent(),\n          };\n        } catch (error) {\n          await emitter.emit(\"toolError\", {\n            data: {\n              tool,\n              input: state.tool_input,\n              options: toolOptions,\n              error,\n              iteration: state,\n            },\n            meta,\n          });\n\n          if (error instanceof ToolInputValidationError) {\n            this.failedAttemptsCounter.use(error);\n\n            return {\n              success: false,\n              output: this.templates.toolInputError.render({\n                reason: error.toString(),\n              }),\n            };\n          }\n\n          if (error instanceof ToolError) {\n            this.failedAttemptsCounter.use(error);\n\n            return {\n              success: false,\n              output: this.templates.toolError.render({\n                reason: error.explain(),\n              }),\n            };\n          }\n\n          throw error;\n        }\n      },\n    }).get();\n  }\n\n  @Cache({ enumerable: false })\n  protected get renderers() {\n    const self = {\n      user: {\n        message: ({ prompt }: BeeRunInput) =>\n          prompt !== null || this.input.memory.isEmpty()\n            ? BaseMessage.of({\n                role: Role.USER,\n                text: prompt || this.templates.userEmpty.render({}),\n                meta: {\n                  createdAt: new Date(),\n                },\n              })\n            : undefined,\n      },\n      system: {\n        variables: {\n          tools: async () => {\n            return await Promise.all(\n              this.input.tools.map(async (tool) => ({\n                name: tool.name,\n                description: tool.description.replaceAll(\"\\n\", \".\").replace(/\\.$/, \"\").concat(\".\"),\n                schema: JSON.stringify(\n                  await tool.getInputJsonSchema(),\n                  (() => {\n                    const ignoredKeys = new Set([\"minLength\", \"maxLength\", \"$schema\"]);\n                    return (key, value) => (ignoredKeys.has(key) ? undefined : value);\n                  })(),\n                ),\n              })),\n            );\n          },\n        },\n        message: async () =>\n          BaseMessage.of({\n            role: Role.SYSTEM,\n            text: this.templates.system.render({\n              tools: await self.system.variables.tools(),\n              instructions: undefined,\n              createdAt: new Date().toISOString(),\n            }),\n            meta: {\n              createdAt: new Date(),\n            },\n          }),\n      },\n    };\n    return self;\n  }\n\n  protected async initMemory({ prompt }: BeeRunInput): Promise<BaseMemory> {\n    const { memory: history, llm } = this.input;\n\n    const prevConversation = [...history.messages, this.renderers.user.message({ prompt })]\n      .filter(isTruthy)\n      .map((message) => {\n        if (message.role === Role.USER) {\n          const isEmpty = !message.text.trim();\n          const text = isEmpty\n            ? (this.templates?.userEmpty ?? BeeUserEmptyPrompt).render({})\n            : (this.templates?.user ?? BeeUserPrompt).render({\n                input: message.text,\n                meta: {\n                  ...message?.meta,\n                  createdAt: message?.meta?.createdAt?.toISOString?.(),\n                },\n              });\n\n          return BaseMessage.of({\n            role: Role.USER,\n            text,\n            meta: message.meta,\n          });\n        }\n        return message;\n      });\n\n    const memory = new TokenMemory({\n      llm,\n      capacityThreshold: 0.85,\n      syncThreshold: 0.5,\n      handlers: {\n        removalSelector(curMessages) {\n          // First we remove messages from the past conversations\n          const prevConversationMessage = curMessages.find((msg) => prevConversation.includes(msg));\n          if (prevConversationMessage && prevConversationMessage !== last(prevConversation)) {\n            return prevConversationMessage;\n          }\n\n          const lastMessage =\n            curMessages.length > 3\n              ? (curMessages.find(\n                  (msg) =>\n                    msg.role === Role.ASSISTANT && getProp(msg, [\"ctx\", \"success\"]) === false,\n                ) ?? curMessages.find((msg) => msg.role === Role.ASSISTANT))\n              : null;\n\n          if (!lastMessage) {\n            throw new AgentError(\"Cannot fit the current conversation into the context window!\");\n          }\n          return lastMessage;\n        },\n      },\n    });\n    await memory.addMany([await this.renderers.system.message(), ...prevConversation]);\n    return memory;\n  }\n\n  @Cache({ enumerable: false })\n  get templates(): BeeAgentTemplates {\n    const customTemplates = this.input.templates ?? {};\n\n    return {\n      system: customTemplates.system ?? BeeSystemPrompt,\n      assistant: customTemplates.assistant ?? BeeAssistantPrompt,\n      user: customTemplates.user ?? BeeUserPrompt,\n      userEmpty: customTemplates.userEmpty ?? BeeUserEmptyPrompt,\n      toolError: customTemplates.toolError ?? BeeToolErrorPrompt,\n      toolInputError: customTemplates.toolInputError ?? BeeToolInputErrorPrompt,\n      toolNoResultError: customTemplates.toolNoResultError ?? BeeToolNoResultsPrompt,\n      toolNotFoundError: customTemplates.toolNotFoundError ?? BeeToolNotFoundPrompt,\n      schemaError: customTemplates.schemaError ?? BeeSchemaErrorPrompt,\n    };\n  }\n\n  protected createParser(tools: AnyTool[]) {\n    const parserRegex = isEmpty(tools)\n      ? new RegExp(`Thought: .+\\\\nFinal Answer: [\\\\s\\\\S]+`)\n      : new RegExp(\n          `Thought: .+\\\\n(?:Final Answer: [\\\\s\\\\S]+|Function Name: (${tools.map((tool) => tool.name).join(\"|\")})\\\\nFunction Input: \\\\{.*\\\\}\\\\nFunction Output:)`,\n        );\n\n    const parser = new LinePrefixParser<BeeParserInput>(\n      {\n        thought: {\n          prefix: \"Thought:\",\n          next: [\"tool_name\", \"final_answer\"],\n          isStart: true,\n          field: new ZodParserField(z.string().min(1)),\n        },\n        tool_name: {\n          prefix: \"Function Name:\",\n          next: [\"tool_input\"],\n          field: new ZodParserField(\n            z.pipeline(\n              z.string().trim(),\n              z.enum(tools.map((tool) => tool.name) as [string, ...string[]]),\n            ),\n          ),\n        },\n        tool_input: {\n          prefix: \"Function Input:\",\n          next: [\"tool_output\"],\n          isEnd: true,\n          field: new JSONParserField({\n            schema: z.object({}).passthrough(),\n            base: {},\n            matchPair: [\"{\", \"}\"],\n          }),\n        },\n        tool_output: {\n          prefix: \"Function Output:\",\n          next: [\"final_answer\"],\n          isEnd: true,\n          field: new ZodParserField(z.string()),\n        },\n        final_answer: {\n          prefix: \"Final Answer:\",\n          next: [],\n          isStart: true,\n          isEnd: true,\n          field: new ZodParserField(z.string().min(1)),\n        },\n      },\n      {\n        waitForStartNode: true,\n        endOnRepeat: true,\n        fallback: (stash) =>\n          stash\n            ? [\n                { key: \"thought\", value: \"I now know the final answer.\" },\n                { key: \"final_answer\", value: stash },\n              ]\n            : [],\n      },\n    );\n\n    return {\n      parser,\n      parserRegex,\n    } as const;\n  }\n}\n"]}