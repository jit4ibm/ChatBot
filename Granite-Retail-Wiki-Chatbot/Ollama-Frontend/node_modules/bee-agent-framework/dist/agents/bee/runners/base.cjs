'use strict';

var serializable_cjs = require('../../../internals/serializable.cjs');
var counter_cjs = require('../../../internals/helpers/counter.cjs');
var base_cjs = require('../../base.cjs');
var utils_cjs = require('../../../serializer/utils.cjs');

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
class BaseRunner extends serializable_cjs.Serializable {
  static {
    __name(this, "BaseRunner");
  }
  input;
  options;
  run;
  memory;
  iterations;
  failedAttemptsCounter;
  constructor(input, options, run) {
    super(), this.input = input, this.options = options, this.run = run, this.iterations = [];
    this.failedAttemptsCounter = new counter_cjs.RetryCounter(options?.execution?.totalMaxRetries, base_cjs.AgentError);
  }
  async createIteration() {
    const meta = {
      iteration: this.iterations.length + 1
    };
    const maxIterations = this.options?.execution?.maxIterations ?? Infinity;
    if (meta.iteration > maxIterations) {
      throw new base_cjs.AgentError(`Agent was not able to resolve the task in ${maxIterations} iterations.`, [], {
        isFatal: true
      });
    }
    const emitter = this.run.emitter.child({
      groupId: `iteration-${meta.iteration}`
    });
    const iteration = await this.llm({
      emitter,
      signal: this.run.signal,
      meta
    });
    this.iterations.push(iteration);
    return {
      emitter,
      state: iteration.state,
      meta,
      signal: this.run.signal
    };
  }
  async init(input) {
    this.memory = await this.initMemory(input);
  }
  createSnapshot() {
    return {
      input: utils_cjs.shallowCopy(this.input),
      options: utils_cjs.shallowCopy(this.options),
      memory: this.memory,
      failedAttemptsCounter: this.failedAttemptsCounter
    };
  }
  loadSnapshot(snapshot) {
    Object.assign(this, snapshot);
  }
}

exports.BaseRunner = BaseRunner;
//# sourceMappingURL=base.cjs.map
//# sourceMappingURL=base.cjs.map