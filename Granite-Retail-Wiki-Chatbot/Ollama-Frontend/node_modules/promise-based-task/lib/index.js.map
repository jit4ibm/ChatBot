{"version":3,"sources":["../src/error.ts","../src/Task.ts","../src/types.ts","../src/TaskMap.ts","../src/SlidingTaskMap.ts","../src/TaskQueue.ts"],"names":["TaskState"],"mappings":"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","sourcesContent":["export class TaskDestroyedException extends Error {}\n","import type { Deletable } from './types';\nimport { TaskDestroyedException } from './error';\n\nexport enum TaskState {\n  PENDING = 'pending',\n  RESOLVED = 'resolved',\n  REJECTED = 'rejected'\n}\n\nexport interface TaskInput {\n  signal?: AbortSignal\n}\n\nexport class Task<T, E = any> implements Promise<T>, Deletable {\n  private _promise: Promise<T>;\n  private _resolve!: (value: T) => void\n  private _reject!: (error: E) => void\n\n  private _state: TaskState = TaskState.PENDING\n  private _resolvedValue: Readonly<T> | undefined\n  private _rejectedValue: E | undefined\n\n  constructor(input?: TaskInput) {\n    this._promise = new Promise<T>((_resolve, _reject) => {\n      this._resolve = (...args) => {\n        if (this.state === TaskState.PENDING) {\n          this._state = TaskState.RESOLVED\n          this._resolvedValue = args.at(0)\n          _resolve(...args);\n        }\n      }\n      this._reject = (...args) => {\n        if (this.state === TaskState.PENDING) {\n          this._state = TaskState.REJECTED\n          this._rejectedValue = args.at(0)\n          _reject(...args);\n        }\n      }\n    });\n\n    this._promise.catch(() => {\n      /* Prevent \"UnhandledPromiseRejectionWarning\" */\n    });\n\n    input?.signal?.addEventListener?.(\"abort\", () => {\n      this.reject(new TaskDestroyedException(\"Task has been aborted!\") as E)\n    }, {\n      once: true,\n    })\n  }\n\n  static resolve<A>(value: A) {\n    const instance = new Task<A>()\n    instance.resolve(value)\n    return instance\n  }\n\n  resolve(value: T) {\n    this._resolve(value)\n  }\n\n  reject(reason: E) {\n    this._reject(reason)\n  }\n\n  destructor(): void {\n    this.reject(new TaskDestroyedException('Object already destroyed') as E);\n  }\n\n  then<TResult1 = T, TResult2 = never>(\n    onfulfilled?: ((value: T) => PromiseLike<TResult1> | TResult1) | undefined | null,\n    onrejected?: ((reason: any) => PromiseLike<TResult2> | TResult2) | undefined | null,\n  ): Promise<TResult1 | TResult2> {\n    return this._promise.then(onfulfilled).catch(onrejected);\n  }\n\n  catch<TResult = never>(\n    onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,\n  ): Promise<T | TResult> {\n    return this._promise.catch(onrejected);\n  }\n\n  finally(onfinally?: (() => void) | undefined | null): Promise<T> {\n    return this._promise.finally(onfinally);\n  }\n\n  get state(): TaskState {\n    return this._state\n  }\n\n  resolvedValue(): Readonly<T> | undefined {\n    return this._resolvedValue\n  }\n\n  rejectedValue(): E | undefined {\n    return this._rejectedValue\n  }\n\n  get [Symbol.toStringTag]() {\n    return Task.name\n  }\n}\n","export interface Deletable {\n  destructor: () => void;\n}\n\nexport function isDeletable(value: unknown): value is Deletable {\n  return typeof value === 'object' && value !== null && 'destructor' in value && typeof (value as Deletable).destructor === 'function';\n}\n","import { isDeletable } from './types';\n\nexport class TaskMap<K, V> extends Map<K, V> {\n  delete(key: K): boolean {\n    if (this.has(key)) {\n      const target = this.get(key);\n      if (isDeletable(target)) {\n        target.destructor();\n      }\n      return super.delete(key);\n    }\n    return false;\n  }\n\n  set(key: K, value: V): this {\n    this.delete(key);\n\n    return super.set(key, value);\n  }\n\n  clear(): void {\n    for (const key of this.keys()) {\n      this.delete(key);\n    }\n\n    super.clear();\n  }\n}\n","import { TaskMap } from './TaskMap';\n\nexport class SlidingTaskMap<K, V> extends TaskMap<K, V> {\n  private readonly keysByTime: K[] = [];\n  private readonly ttlMap: Map<K, NodeJS.Timeout> = new Map();\n\n  constructor(public readonly windowSize: number, public readonly ttl?: number) {\n    super();\n\n    if (windowSize < 1 || isNaN(windowSize)) {\n      throw new TypeError(`windowSize cannot be less than 1!`);\n    }\n    this.windowSize = Number(windowSize);\n\n    if (ttl !== undefined && ttl !== Number.POSITIVE_INFINITY) {\n      if (isNaN(ttl) || ttl < 1) {\n        throw new TypeError(`ttl cannot be less than 1!`);\n      } else {\n        this.ttl = Number(ttl);\n      }\n    }\n  }\n\n  private clearTimeout(key: K) {\n    if (this.ttlMap.has(key)) {\n      clearTimeout(this.ttlMap.get(key)!);\n      this.ttlMap.delete(key);\n    }\n  }\n\n  private setTimeout(key: K, customTTL?: number) {\n    const ttl = Number(customTTL ?? this.ttl);\n\n    if (ttl > 0 && ttl !== Number.POSITIVE_INFINITY) {\n      const timeoutId = setTimeout(() => {\n        this.delete(key);\n      }, ttl).unref();\n\n      this.ttlMap.set(key, timeoutId);\n    }\n  }\n\n  set(key: K, value: V, customTTL?: number): this {\n    if (this.has(key)) {\n      super.set(key, value);\n    } else {\n      if (this.size + 1 > this.windowSize) {\n        this.shift();\n      }\n\n      this.keysByTime.push(key);\n      super.set(key, value);\n    }\n\n    this.setTimeout(key, customTTL);\n    return this;\n  }\n\n  delete(key: K): boolean {\n    const didDelete = super.delete(key);\n    if (didDelete) {\n      this.clearTimeout(key);\n      const deleteIndex = this.keysByTime.indexOf(key);\n      this.keysByTime.splice(deleteIndex, 1);\n    }\n    return didDelete;\n  }\n\n  clear(): void {\n    super.clear();\n    this.keysByTime.length = 0;\n    this.ttlMap.clear();\n  }\n\n  pop() {\n    const key = this.keysByTime.at(-1);\n    if (key !== undefined) {\n      const item = this.get(key)\n      this.delete(key);\n      return item\n    }\n  }\n\n  shift() {\n    const key = this.keysByTime.at(0);\n    if (key !== undefined) {\n      const item = this.get(key)\n      this.delete(key);\n      return item\n    }\n  }\n}\n","import { Task } from './Task'\nimport { TaskDestroyedException } from './error';\n\ninterface IWaitingTask<T> {\n  task: Task<T>\n  resolver: () => Promise<void>\n}\n\nexport class TaskQueue<T> {\n  private _waitingQueue: Array<IWaitingTask<T>> = []\n  private _unlockQueue: Array<Task<void>> = []\n\n\n  private readonly _queueSize: number\n  private _processingCount = 0\n\n  constructor(queueSize?: number) {\n    this._queueSize = Math.max(Number(queueSize), 1)\n  }\n\n  private async _internalSync() {\n    if (this._processingCount >= this._queueSize) {\n      const waitForUnlockTask = new Task<void>()\n      this._unlockQueue.push(waitForUnlockTask)\n      await waitForUnlockTask\n    }\n\n    const task = this._waitingQueue.shift()\n    if (task) {\n      await task.resolver()\n    }\n  }\n\n  async clear() {\n    this._waitingQueue.forEach(item => item.task.reject(new TaskDestroyedException()))\n    this._unlockQueue.forEach(item => item.reject(new TaskDestroyedException()))\n\n    this._unlockQueue.length = 0\n    this._waitingQueue.length = 0\n    this._processingCount = 0\n  }\n\n  async execute(fn: () => Promise<T>): Promise<T> {\n    const task = new Task<T>()\n    this._waitingQueue.push({\n      task,\n      resolver: async () => {\n        this._processingCount++\n\n        const cleanup = () => {\n          this._processingCount--\n          const unlockTask = this._unlockQueue.shift()\n          unlockTask?.resolve()\n        }\n\n        return fn()\n          .then((res) => {\n            cleanup();\n            task.resolve(res);\n          })\n          .catch(e => {\n            cleanup();\n            task.reject(e);\n          })\n      }\n    })\n\n    this._internalSync().catch(() => {})\n\n    return task\n  }\n\n  getStats() {\n    return {\n      processingCount: this._processingCount,\n      waitingCount: this._waitingQueue.length,\n    }\n  }\n}\n"]}