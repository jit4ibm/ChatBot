import { AsyncLocalStorage } from 'node:async_hooks';
import { createRandomHash } from './internals/helpers/hash.js';
import { omit } from 'remeda';
import { createNonOverridableObject } from './internals/helpers/object.js';
import { registerSignals } from './internals/helpers/cancellation.js';
import { Serializable } from './internals/serializable.js';
import { LazyPromise, executeSequentially } from './internals/helpers/promise.js';
import { FrameworkError } from './errors.js';
import { shallowCopy } from './serializer/utils.js';

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
class Run extends LazyPromise {
  static {
    __name(this, "Run");
  }
  runContext;
  tasks;
  constructor(handler, runContext) {
    super(handler), this.runContext = runContext, this.tasks = [], this[_Symbol_toStringTag] = "Promise";
  }
  [_Symbol_toStringTag = Symbol.toStringTag];
  observe(fn) {
    this.tasks.push(async () => fn(this.runContext.emitter));
    return this;
  }
  context(value) {
    this.tasks.push(async () => {
      Object.assign(this.runContext.context, value);
      Object.assign(this.runContext.emitter.context, value);
    });
    return this;
  }
  middleware(fn) {
    this.tasks.push(async () => fn(this.runContext));
    return this;
  }
  async before() {
    await super.before();
    await executeSequentially(this.tasks.splice(0, Infinity));
  }
}
class RunContext extends Serializable {
  static {
    __name(this, "RunContext");
  }
  instance;
  input;
  static #storage = new AsyncLocalStorage();
  controller;
  runId;
  groupId;
  parentId;
  emitter;
  context;
  runParams;
  createdAt;
  get signal() {
    return this.controller.signal;
  }
  abort() {
    this.controller.abort();
  }
  constructor(instance, input, parent) {
    super(), this.instance = instance, this.input = input;
    this.createdAt = /* @__PURE__ */ new Date();
    this.runParams = input.params;
    this.runId = createRandomHash(5);
    this.parentId = parent?.runId;
    this.groupId = parent?.groupId ?? createRandomHash();
    this.context = createNonOverridableObject(omit(parent?.context ?? {}, [
      "id",
      "parentId"
    ]));
    this.controller = new AbortController();
    registerSignals(this.controller, [
      input.signal,
      parent?.signal
    ]);
    this.emitter = instance.emitter.child({
      context: this.context,
      trace: {
        id: this.groupId,
        runId: this.runId,
        parentRunId: parent?.runId
      }
    });
    if (parent) {
      this.emitter.pipe(parent.emitter);
    }
  }
  destroy() {
    this.emitter.destroy();
    this.controller.abort(new FrameworkError("Context destroyed."));
  }
  static enter(instance, input, fn) {
    const parent = RunContext.#storage.getStore();
    const runContext = new RunContext(instance, input, parent);
    return new Run(async () => {
      const emitter = runContext.emitter.child({
        namespace: [
          "run"
        ],
        creator: runContext,
        context: {
          internal: true
        }
      });
      try {
        await emitter.emit("start", null);
        const result = await Promise.race([
          RunContext.#storage.run(runContext, fn, runContext),
          new Promise((_, reject) => runContext.signal.addEventListener("abort", () => setTimeout(() => reject(runContext.signal.reason), 0)))
        ]);
        await emitter.emit("success", result);
        return result;
      } catch (_e) {
        const e = FrameworkError.ensure(_e);
        await emitter.emit("error", e);
        throw e;
      } finally {
        await emitter.emit("finish", null);
        runContext.destroy();
      }
    }, runContext);
  }
  static {
    this.register();
  }
  createSnapshot() {
    return {
      controller: this.controller,
      runId: this.runId,
      groupId: this.groupId,
      parentId: this.parentId,
      emitter: this.emitter,
      context: shallowCopy(this.context),
      runParams: shallowCopy(this.runParams),
      createdAt: new Date(this.createdAt)
    };
  }
  loadSnapshot(snapshot) {
    Object.assign(this, snapshot);
  }
}
var _Symbol_toStringTag;

export { Run, RunContext };
//# sourceMappingURL=context.js.map
//# sourceMappingURL=context.js.map