'use strict';

var base_cjs = require('../../tools/base.cjs');
var zod = require('zod');
var LCTools = require('@langchain/core/tools');
var serializer_cjs = require('../../serializer/serializer.cjs');
var remeda = require('remeda');
var schema_cjs = require('../../internals/helpers/schema.cjs');
var object_cjs = require('../../internals/helpers/object.cjs');
var emitter_cjs = require('../../emitter/emitter.cjs');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var LCTools__namespace = /*#__PURE__*/_interopNamespace(LCTools);

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
class LangChainTool extends base_cjs.Tool {
  static {
    __name(this, "LangChainTool");
  }
  tool;
  static serializedSchemaKey = "_internalJsonSchema";
  emitter;
  constructor({ tool, ...options }) {
    super(options);
    this.tool = tool;
    this.name = tool.name;
    this.description = tool.description;
    this.emitter = emitter_cjs.Emitter.root.child({
      namespace: [
        "tool",
        "langchain",
        remeda.toCamelCase(this.name)
      ],
      creator: this
    });
  }
  static {
    this.register();
    for (const Class of [
      LCTools__namespace.DynamicTool,
      LCTools__namespace.DynamicStructuredTool
    ]) {
      serializer_cjs.Serializer.register(Class, {
        toPlain: /* @__PURE__ */ __name((instance) => ({
          options: remeda.pickBy({
            ...remeda.pick(instance, [
              "name",
              "description",
              "metadata",
              "responseFormat",
              "returnDirect",
              "func"
            ]),
            schema: instance.schema instanceof zod.ZodEffects ? schema_cjs.toJsonSchema(instance.schema.sourceType()) : schema_cjs.toJsonSchema(instance.schema)
          }, remeda.isTruthy)
        }), "toPlain"),
        fromPlain: /* @__PURE__ */ __name(({ options }) => {
          return new Class({
            ...options,
            metadata: {
              ...options?.metadata,
              [LangChainTool.serializedSchemaKey]: options.schema
            }
          });
        }, "fromPlain")
      });
    }
  }
  inputSchema() {
    const { schema, metadata = {} } = this.tool;
    return object_cjs.getProp(metadata, [
      LangChainTool.serializedSchemaKey
    ], schema instanceof zod.ZodEffects ? schema.sourceType() : schema);
  }
  async _run(arg, options, run) {
    const { outputClass = base_cjs.JSONToolOutput } = this.options;
    const raw = await this.tool.invoke(arg, {
      ...options,
      signal: run.signal
    });
    return new outputClass(raw);
  }
  createSnapshot() {
    return {
      ...super.createSnapshot(),
      tool: this.tool
    };
  }
  loadSnapshot({ tool, ...snapshot }) {
    super.loadSnapshot(snapshot);
    this.tool = tool;
  }
}

exports.LangChainTool = LangChainTool;
//# sourceMappingURL=tools.cjs.map
//# sourceMappingURL=tools.cjs.map