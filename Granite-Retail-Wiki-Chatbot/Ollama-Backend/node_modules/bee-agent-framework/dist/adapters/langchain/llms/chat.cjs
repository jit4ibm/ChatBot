'use strict';

var utils_cjs = require('../../../serializer/utils.cjs');
var load = require('@langchain/core/load');
var chat_cjs = require('../../../llms/chat.cjs');
var message_cjs = require('../../../llms/primitives/message.cjs');
var messages = require('@langchain/core/messages');
var decoratorCache_cjs = require('../../../cache/decoratorCache.cjs');
var object_cjs = require('../../../internals/helpers/object.cjs');
var emitter_cjs = require('../../../emitter/emitter.cjs');
var errors_cjs = require('../../../errors.cjs');

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate, "_ts_decorate");
function _ts_metadata(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
}
__name(_ts_metadata, "_ts_metadata");
class LangChainChatLLMOutput extends chat_cjs.ChatLLMOutput {
  static {
    __name(this, "LangChainChatLLMOutput");
  }
  messages;
  meta;
  constructor(messages, meta = {}) {
    super(), this.messages = messages, this.meta = meta;
  }
  static {
    this.register();
  }
  merge(other) {
    this.messages.push(...other.messages);
    Object.assign(this.meta, object_cjs.omitUndefined(other.meta));
  }
  getTextContent() {
    return this.messages.map((msg) => msg.text).join("");
  }
  toString() {
    return this.getTextContent();
  }
  createSnapshot() {
    return {
      messages: utils_cjs.shallowCopy(this.messages),
      meta: utils_cjs.shallowCopy(this.meta)
    };
  }
  loadSnapshot(snapshot) {
    Object.assign(this, snapshot);
  }
}
class LangChainChatLLM extends chat_cjs.ChatLLM {
  static {
    __name(this, "LangChainChatLLM");
  }
  lcLLM;
  modelMeta;
  emitter;
  parameters;
  constructor(lcLLM, modelMeta, executionOptions, cache) {
    super(lcLLM._modelType(), executionOptions, cache), this.lcLLM = lcLLM, this.modelMeta = modelMeta, this.emitter = emitter_cjs.Emitter.root.child({
      namespace: [
        "langchain",
        "chat_llm"
      ],
      creator: this
    });
    this.parameters = lcLLM.invocationParams();
  }
  static {
    this.register();
  }
  async meta() {
    if (this.modelMeta) {
      return this.modelMeta;
    }
    return {
      tokenLimit: Infinity
    };
  }
  // eslint-disable-next-line unused-imports/no-unused-vars
  async embed(input, options) {
    throw new errors_cjs.NotImplementedError();
  }
  async tokenize(input) {
    return {
      tokensCount: await this.lcLLM.getNumTokens(input)
    };
  }
  get mappers() {
    const roleMapper = /* @__PURE__ */ new Map([
      [
        "system",
        message_cjs.Role.SYSTEM
      ],
      [
        "assistant",
        message_cjs.Role.ASSISTANT
      ],
      [
        "ai",
        message_cjs.Role.ASSISTANT
      ],
      [
        "generic",
        message_cjs.Role.ASSISTANT
      ],
      [
        "function",
        message_cjs.Role.ASSISTANT
      ],
      [
        "tool",
        message_cjs.Role.ASSISTANT
      ],
      [
        "human",
        message_cjs.Role.USER
      ],
      [
        "tool",
        message_cjs.Role.ASSISTANT
      ]
    ]);
    return {
      toLCMessage(message) {
        return new messages.ChatMessage({
          role: message.role,
          content: message.text,
          response_metadata: message.meta
        });
      },
      fromLCMessage(message) {
        const role = object_cjs.getProp(message, [
          "role"
        ], message._getType());
        const text = typeof message.content === "string" ? message.content : message.content.filter((msg) => msg.type === "text").map((msg) => msg.text).join("\n");
        return message_cjs.BaseMessage.of({
          role: roleMapper.has(role) ? roleMapper.get(role) : message_cjs.Role.ASSISTANT,
          text
        });
      }
    };
  }
  async _generate(input, options, run) {
    const lcMessages = input.map((msg) => this.mappers.toLCMessage(msg));
    const response = await this.lcLLM.invoke(lcMessages, {
      ...options?.lc,
      signal: run.signal
    });
    return new LangChainChatLLMOutput([
      this.mappers.fromLCMessage(response)
    ], response.response_metadata);
  }
  async *_stream(input, options, run) {
    const lcMessages = input.map((msg) => this.mappers.toLCMessage(msg));
    const response = this.lcLLM._streamResponseChunks(lcMessages, {
      ...options?.lc,
      signal: run.signal
    });
    for await (const chunk of response) {
      yield new LangChainChatLLMOutput([
        this.mappers.fromLCMessage(chunk.message)
      ], chunk.message.response_metadata);
    }
  }
  createSnapshot() {
    return {
      ...super.createSnapshot(),
      modelId: this.modelId,
      modelMeta: this.modelMeta,
      parameters: utils_cjs.shallowCopy(this.parameters),
      executionOptions: utils_cjs.shallowCopy(this.executionOptions),
      lcLLM: JSON.stringify(this.lcLLM.toJSON())
    };
  }
  async loadSnapshot({ lcLLM, ...state }) {
    super.loadSnapshot(state);
    Object.assign(this, state, {
      lcLLM: await (async () => {
        if (lcLLM.includes("@ibm-generative-ai/node-sdk")) {
          const { GenAIChatModel } = await import('@ibm-generative-ai/node-sdk/langchain');
          return GenAIChatModel.fromJSON(lcLLM);
        }
        return await load.load(lcLLM);
      })()
    });
  }
}
_ts_decorate([
  decoratorCache_cjs.Cache(),
  _ts_metadata("design:type", void 0),
  _ts_metadata("design:paramtypes", [])
], LangChainChatLLM.prototype, "mappers", null);

exports.LangChainChatLLM = LangChainChatLLM;
exports.LangChainChatLLMOutput = LangChainChatLLMOutput;
//# sourceMappingURL=chat.cjs.map
//# sourceMappingURL=chat.cjs.map