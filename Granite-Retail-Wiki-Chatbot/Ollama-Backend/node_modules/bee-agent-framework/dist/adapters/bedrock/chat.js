import { shallowCopy } from '../../serializer/utils.js';
import { ChatLLMOutput, ChatLLM } from '../../llms/chat.js';
import { BaseMessage, Role } from '../../llms/primitives/message.js';
import { Emitter } from '../../emitter/emitter.js';
import { BedrockRuntimeClient, ConverseCommand, ConverseStreamCommand } from '@aws-sdk/client-bedrock-runtime';
import { Serializer } from '../../serializer/serializer.js';
import { NotImplementedError } from '../../errors.js';

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
class ChatBedrockOutput extends ChatLLMOutput {
  static {
    __name(this, "ChatBedrockOutput");
  }
  responses;
  constructor(response) {
    super();
    this.responses = [
      response
    ];
  }
  static {
    this.register();
  }
  get messages() {
    return this.responses.flatMap((response) => {
      if ("delta" in response && response.delta?.text) {
        return [
          BaseMessage.of({
            role: Role.ASSISTANT,
            text: response.delta.text
          })
        ];
      } else if ("output" in response && response.output?.message?.content) {
        return response.output.message.content.filter((choice) => choice?.text).map((choice) => BaseMessage.of({
          role: Role.ASSISTANT,
          text: choice.text
        }));
      }
      return [];
    });
  }
  getTextContent() {
    return this.messages.map((msg) => msg.text).join("");
  }
  merge(other) {
    this.responses.push(...other.responses);
  }
  toString() {
    return this.getTextContent();
  }
  createSnapshot() {
    return {
      responses: shallowCopy(this.responses)
    };
  }
  loadSnapshot(snapshot) {
    Object.assign(this, snapshot);
  }
}
class BedrockChatLLM extends ChatLLM {
  static {
    __name(this, "BedrockChatLLM");
  }
  emitter = Emitter.root.child({
    namespace: [
      "bedrock",
      "chat_llm"
    ],
    creator: this
  });
  client;
  parameters;
  constructor({ client, modelId = "amazon.titan-text-lite-v1", region = "us-east-1", credentials, parameters = {
    temperature: 0
  }, executionOptions = {}, cache } = {}) {
    super(modelId, executionOptions, cache);
    this.client = client ?? new BedrockRuntimeClient({
      region,
      credentials
    });
    this.parameters = parameters ?? {};
  }
  static {
    this.register();
    Serializer.register(BedrockRuntimeClient, {
      toPlain: /* @__PURE__ */ __name((value) => ({
        config: {
          region: value.config.region,
          credentials: value.config.credentials
        }
      }), "toPlain"),
      fromPlain: /* @__PURE__ */ __name((value) => new BedrockRuntimeClient({
        region: value.config.region,
        credentials: value.config.credentials
      }), "fromPlain")
    });
  }
  async meta() {
    if (this.modelId.includes("titan-text-premier")) {
      return {
        tokenLimit: 3 * 1024
      };
    } else if (this.modelId.includes("titan-text-express") || this.modelId.includes("anthropic.claude-v2") || this.modelId.includes("anthropic.claude-instant-v1") || this.modelId.includes("anthropic.claude-3-sonnet") || this.modelId.includes("anthropic.claude-3-haiku") || this.modelId.includes("anthropic.claude-3-opus") || this.modelId.includes("meta.llama2") || this.modelId.includes("cohere.command-text") || this.modelId.includes("cohere.command-light")) {
      return {
        tokenLimit: 4 * 1024
      };
    } else if (this.modelId.includes("titan-text-lite") || this.modelId.includes("anthropic.claude-3-5-sonnet") || this.modelId.includes("anthropic.claude-3-5-haiku") || this.modelId.includes("meta.llama3-8b") || this.modelId.includes("meta.llama3-70b") || this.modelId.includes("ai21.j2")) {
      return {
        tokenLimit: 8 * 1024
      };
    } else if (this.modelId.includes("mistral.mistral-7b") || this.modelId.includes("mistral.mixtral-8x7b") || this.modelId.includes("mistral.mistral-small")) {
      return {
        tokenLimit: 32 * 1024
      };
    } else if (this.modelId.includes("meta.llama3-1") || this.modelId.includes("meta.llama3-2") || this.modelId.includes("mistral.mistral-large") || this.modelId.includes("cohere.command-r")) {
      return {
        tokenLimit: 128 * 1024
      };
    } else if (this.modelId.includes("ai21.jamba")) {
      return {
        tokenLimit: 256 * 1024
      };
    }
    return {
      tokenLimit: Infinity
    };
  }
  // eslint-disable-next-line unused-imports/no-unused-vars
  async embed(input, options) {
    throw new NotImplementedError();
  }
  async tokenize(input) {
    const contentLength = input.reduce((acc, msg) => acc + msg.text.length, 0);
    return {
      tokensCount: Math.ceil(contentLength / 4)
    };
  }
  async _generate(input, _options, run) {
    const { conversation, systemMessage } = this.convertToConverseMessages(input);
    const command = new ConverseCommand({
      modelId: this.modelId,
      messages: conversation,
      system: systemMessage,
      ...this.parameters
    });
    const response = await this.client.send(command, {
      abortSignal: run.signal
    });
    return new ChatBedrockOutput(response);
  }
  async *_stream(input, _options, run) {
    const { conversation, systemMessage } = this.convertToConverseMessages(input);
    const command = new ConverseStreamCommand({
      modelId: this.modelId,
      messages: conversation,
      system: systemMessage,
      ...this.parameters
    });
    const response = await this.client.send(command, {
      abortSignal: run.signal
    });
    for await (const chunk of response?.stream || []) {
      if (chunk.contentBlockDelta) {
        yield new ChatBedrockOutput(chunk.contentBlockDelta);
      }
    }
  }
  createSnapshot() {
    return {
      ...super.createSnapshot(),
      client: this.client,
      modelId: this.modelId,
      parameters: shallowCopy(this.parameters)
    };
  }
  convertToConverseMessages(messages) {
    const systemMessage = messages.filter((msg) => msg.role === Role.SYSTEM).map((msg) => ({
      text: msg.text
    }));
    const converseMessages = messages.filter((msg) => msg.role !== Role.SYSTEM).map((msg) => ({
      role: msg.role === Role.USER ? Role.USER : Role.ASSISTANT,
      content: [
        {
          text: msg.text
        }
      ]
    }));
    const conversation = converseMessages.reduce((messageList, currentMessage) => {
      const lastMessage = messageList[messageList.length - 1];
      if (lastMessage && lastMessage !== currentMessage && lastMessage.role === Role.USER) {
        lastMessage.content = lastMessage.content.concat(currentMessage.content);
      } else {
        messageList.push(currentMessage);
      }
      return messageList;
    }, []);
    return {
      conversation,
      systemMessage
    };
  }
}

export { BedrockChatLLM, ChatBedrockOutput };
//# sourceMappingURL=chat.js.map
//# sourceMappingURL=chat.js.map