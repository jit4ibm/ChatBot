{"version":3,"sources":["../../src/internals/types.ts"],"names":["narrowTo","value","fn"],"mappings":";;AAmGO,SAASA,QAAAA,CAAYC,OAAgBC,EAAqC,EAAA;AAC/E,EAAI,IAAA,OAAOA,OAAO,UAAY,EAAA;AAC5B,IAAA,OAAOA,GAAGD,KAAAA,CAAAA;AACZ;AACA,EAAOC,OAAAA,EAAAA;AACT;AALgBF,MAAAA,CAAAA,QAAAA,EAAAA,UAAAA,CAAAA","file":"types.js","sourcesContent":["/**\n * Copyright 2024 IBM Corp.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Primitive } from \"@/internals/helpers/guards.js\";\ntype ExcludeArrayLike<T> = object & Exclude<T, any[]>;\nexport type ObjectLike<K extends keyof any = string, V = any> = Record<K, V>;\nexport type PlainObject<K extends string = string, V = Primitive> = Exclude<\n  ExcludeArrayLike<Record<K & string, any extends V ? never : V>>,\n  any[]\n>;\n\nexport type ExcludeNonStringIndex<T> = {\n  [K in keyof T as string extends K ? never : number extends K ? never : K]: T[K];\n};\n\nexport type AnyFn = (...args: any[]) => any;\n\nexport type Enum<T> = Readonly<{\n  [K in keyof T]: K;\n}>;\nexport type EnumFromUnion<T extends string> = Readonly<{\n  [K in T as Uppercase<K>]: K;\n}>;\nexport type EnumValue<T> = T extends Enum<infer P> ? P[keyof P] : never;\nexport type EnumLowerCaseValue<T> = Readonly<{\n  [K in keyof T]: K extends string ? Lowercase<K> : never;\n}>[keyof T];\nexport type EmptyObject = Record<string, never>;\n\nexport type OmitType<T, O = never> = { [K in keyof T as T[K] extends O ? never : K]: T[K] };\n\nexport type Class<T = any> = new (...args: any[]) => T;\n\ntype TupleUnion<U extends string, R extends any[] = []> = {\n  [S in U]: Exclude<U, S> extends never ? [...R, S] : TupleUnion<Exclude<U, S>, [...R, S]>;\n}[U];\nexport type ArrayKeys<T> = TupleUnion<Extract<keyof T, string>>;\nexport type Common<A, B> = {\n  [P in keyof A & keyof B]: A[P] | B[P];\n};\nexport type ValueOf<T extends NonNullable<unknown>> = T[keyof T];\n\nexport type Head<T> = T extends [infer A, ...any] ? A : never;\nexport type Tail<T> = T extends [any, ...infer B] ? B : never;\nexport type RequiredExcept<T, K extends keyof T> = Omit<Required<T>, K> & Pick<Partial<T>, K>;\nexport type OptionalExcept<T, K extends keyof T> = Pick<Required<T>, K> & Omit<Partial<T>, K>;\nexport type NonUndefined<T, K extends keyof T = keyof T> = Pick<Required<T>, K> & Omit<T, K>;\n\nexport type RequiredAll<T> = {\n  [P in keyof T]-?: NonNullable<T[P]>;\n};\n\nexport type RequiredNested<T> = {\n  [P in keyof T]-?: Required<T[P]>;\n};\n\nexport type OmitEmpty<T> = OmitType<T, never | void>;\nexport type NonEmptyArray<T> = [T, ...T[]];\nexport type Unwrap<T> = T extends (infer X)[] ? X : T;\nexport type Constructable<T> = new (...args: any[]) => T;\nexport type AbstractConstructable = abstract new (...args: any[]) => any;\nexport type AnyConstructable = Constructable<any>;\n\nexport type Constructor<T extends new (...args: any) => any> = T extends new (\n  ...args: infer A\n) => infer R\n  ? new (...args: A) => R\n  : never;\n\nexport interface ClassConstructor<T = any> {\n  name: string;\n  new (...args: any[]): T;\n}\nexport type AbstractClassConstructor<T = any> = abstract new (...args: any[]) => T;\nexport interface NamedFunction<T = any> {\n  name: string;\n  (...args: any[]): T;\n}\n\nexport type PromiseOrPlain<T, Decider extends AnyFn> =\n  ReturnType<Decider> extends Promise<unknown> ? Promise<T> : T;\n\nexport type NoPromise<T> = T extends Promise<unknown> ? never : T;\n\nexport type TypedFn<P extends any[], R> = (...args: P) => R;\n\nexport function narrowTo<T>(value: unknown, fn: boolean | ((value: T) => boolean)): value is T {\n  if (typeof fn === \"function\") {\n    return fn(value as T);\n  }\n  return fn;\n}\n\ntype Without<T, U> = Partial<Record<Exclude<keyof T, keyof U>, never>>;\nexport type XOR<T, U> = T | U extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;\nexport type OneOf<T extends any[]> = T extends [infer Only]\n  ? Only\n  : T extends [infer A, infer B, ...infer Rest]\n    ? OneOf<[XOR<A, B>, ...Rest]>\n    : never;\n\nexport type AnyVoid = Promise<unknown> | unknown;\n\nexport type OmitPrivateKeys<T> = {\n  [K in keyof T as K extends `_${string}` ? never : K]: T[K];\n};\n"]}