import { Task } from 'promise-based-task';
import { EnumValue } from '../types.js';
import './guards.js';

/**
 * Copyright 2024 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

interface RetryableConfig {
    maxRetries: number;
    factor?: number;
    signal?: AbortSignal;
}
declare const RunStrategy: {
    /**
     * Once a single Retryable throws, other retry ables get cancelled immediately.
     */
    readonly THROW_IMMEDIATELY: "THROW_IMMEDIATELY";
    /**
     * Once a single Retryable throws, wait for other to completes, but prevent further retries.
     */
    readonly SETTLE_ROUND: "SETTLE_ROUND";
    /**
     * Once a single Retryable throws, other Retryables remains to continue. Error is thrown by the end.
     */
    readonly SETTLE_ALL: "SETTLE_ALL";
};
interface RetryableRunConfig {
    groupSignal: AbortSignal;
}
interface RetryableContext {
    executionId: string;
    attempt: number;
    signal?: AbortSignal;
}
type RetryableHandler<T> = (ctx: RetryableContext) => Promise<T>;
type ResetHandler = () => void;
type ErrorHandler = (error: Error, ctx: RetryableContext) => void | Promise<void>;
type RetryHandler = (ctx: RetryableContext, lastError: Error) => void | Promise<void>;
declare class Retryable<T> {
    #private;
    constructor(ctx: {
        executor: RetryableHandler<T>;
        onReset?: ResetHandler;
        onError?: ErrorHandler;
        onRetry?: RetryHandler;
        config?: Partial<RetryableConfig>;
    });
    static runGroup<T>(strategy: EnumValue<typeof RunStrategy>, inputs: Retryable<T>[]): Promise<T[]>;
    static runSequence<T>(inputs: readonly Retryable<T>[]): AsyncGenerator<T>;
    static collect<T>(inputs: T & Record<string, Retryable<any>>): Promise<{ [K_1 in keyof { [K in keyof T]: Promise<T[K] extends Retryable<infer Q> ? Q : never>; }]: { [K in keyof T]: Promise<T[K] extends Retryable<infer Q> ? Q : never>; }[K_1] extends Promise<infer P> ? P : { [K in keyof T]: Promise<T[K] extends Retryable<infer Q> ? Q : never>; }[K_1]; }>;
    get isResolved(): boolean;
    get isRejected(): boolean;
    protected _run(config?: RetryableRunConfig): Task<T, Error>;
    get(config?: RetryableRunConfig): Promise<T>;
    reset(): void;
}

export { type ErrorHandler, type ResetHandler, type RetryHandler, Retryable, type RetryableConfig, type RetryableContext, type RetryableHandler, type RetryableRunConfig, RunStrategy };
