import { isPromise, isFunction } from 'remeda';
import { getProp } from './object.js';

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
function isPromiseLike(value) {
  return isPromise(value) || isFunction(getProp(value, [
    "then"
  ]));
}
__name(isPromiseLike, "isPromiseLike");
async function arrayFromAsync(generator, limit) {
  limit = limit ?? Infinity;
  const results = [];
  for await (const chunk of generator) {
    if (results.length >= limit) {
      break;
    }
    results.push(chunk);
  }
  return results;
}
__name(arrayFromAsync, "arrayFromAsync");
async function* emitterToGenerator(fn) {
  const queue = [];
  void fn({
    emit: /* @__PURE__ */ __name((data) => queue.push({
      data
    }), "emit")
  }).then(() => queue.push({
    done: true
  })).catch((error) => queue.push({
    error,
    done: true
  }));
  while (true) {
    while (queue.length === 0) {
      await new Promise((resolve) => setImmediate(resolve));
    }
    const { data, done, error } = queue.shift();
    if (error) {
      throw error;
    }
    if (done) {
      break;
    }
    yield data;
  }
}
__name(emitterToGenerator, "emitterToGenerator");
async function asyncProperties(obj) {
  return Object.fromEntries(await Promise.all(Object.entries(obj).map(async ([key, value]) => [
    key,
    await value
  ])));
}
__name(asyncProperties, "asyncProperties");
function safeExecute({ handler, onError, onSuccess }) {
  try {
    const result = handler();
    if (isPromiseLike(result)) {
      result.then((result2) => onSuccess?.(result2), (err) => onError?.(err));
    } else {
      onSuccess?.(result);
    }
  } catch (e) {
    onError?.(e);
  }
}
__name(safeExecute, "safeExecute");
function asyncExecute(handler) {
  return new Promise((onSuccess, onError) => {
    safeExecute({
      handler,
      onSuccess,
      onError
    });
  });
}
__name(asyncExecute, "asyncExecute");
class LazyPromise {
  static {
    __name(this, "LazyPromise");
  }
  handler;
  constructor(handler) {
    this.handler = handler;
    this[_Symbol_toStringTag] = "Promise";
  }
  [_Symbol_toStringTag = Symbol.toStringTag];
  async before() {
  }
  then(onfulfilled, onrejected) {
    return this.before().then(this.handler).then(onfulfilled).catch(onrejected);
  }
  catch(onrejected) {
    return this.before().then(this.handler).then(void 0).catch(onrejected);
  }
  finally(onfinally) {
    return this.before().then(this.handler).finally(onfinally);
  }
}
async function signalRace(fn, signal, onAbort) {
  return new Promise((resolve, reject) => {
    if (signal?.aborted) {
      reject(signal.reason);
      return;
    }
    const signalFn = /* @__PURE__ */ __name(() => {
      onAbort?.();
      reject(signal?.reason);
    }, "signalFn");
    signal?.addEventListener?.("abort", signalFn);
    fn().then(resolve).catch(reject).finally(() => signal?.removeEventListener?.("abort", signalFn));
  });
}
__name(signalRace, "signalRace");
async function executeSequentially(tasks) {
  for (const task of tasks) {
    await task();
  }
}
__name(executeSequentially, "executeSequentially");
var _Symbol_toStringTag;

export { LazyPromise, arrayFromAsync, asyncExecute, asyncProperties, emitterToGenerator, executeSequentially, isPromiseLike, safeExecute, signalRace };
//# sourceMappingURL=promise.js.map
//# sourceMappingURL=promise.js.map