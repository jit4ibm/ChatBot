{"version":3,"sources":["../../../src/internals/helpers/string.ts"],"names":["splitString","text","options","recursiveSplitString","trim","separators","mergeStrings","chunks","sep","tmpChunks","tmpOverlap","toDoc","parts","join","chunk","length","size","doc","overlap","tmp","shift","push","Error","goodSplits","separator","remainingSeparators","unique","split","filter","Boolean","Comparator","EQ","GT","GTE","LT","LTE","compareVersion","a","comparator","b","diff","replace","localeCompare","undefined","numeric","sensitivity","diffNormalized","Math","min","max","R","isIncludedIn","isJsonLikeString","value","startsWith","endsWith","halveString","seq","includeSeq","index","indexOf","slice","countSharedStartEndLetters","isString","ValueError","minLength","i","at","findFirstPair","pair","opening","closing","balance","startIndex","pairOverlap","allowOverlap","isSame","substring","inner","start","end","innerEnd","innerSize","outer"],"mappings":"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","file":"string.cjs","sourcesContent":["/**\n * Copyright 2024 IBM Corp.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ValueOf } from \"@/internals/types.js\";\nimport * as R from \"remeda\";\nimport { ValueError } from \"@/errors.js\";\nimport { isString, unique } from \"remeda\";\n\nexport function* splitString(\n  text: string,\n  options: { size: number; overlap: number; trim?: boolean },\n) {\n  yield* recursiveSplitString(text, { ...options, trim: options?.trim ?? false, separators: [] });\n}\n\nexport function* mergeStrings(\n  chunks: string[],\n  sep: string,\n  options: { size: number; overlap: number; trim?: boolean },\n) {\n  const tmpChunks: string[] = [];\n  let tmpOverlap = 0;\n\n  const toDoc = (parts: string[]) => {\n    const text = parts.join(sep);\n    return options.trim ? text.trim() : text;\n  };\n\n  for (const chunk of chunks) {\n    if (tmpOverlap + chunk.length + tmpChunks.length * sep.length > options.size) {\n      if (tmpChunks.length > 0) {\n        const doc = toDoc(tmpChunks);\n        if (doc) {\n          yield doc;\n        }\n\n        while (\n          tmpOverlap > options.overlap ||\n          (tmpOverlap + chunk.length + tmpChunks.length * sep.length > options.size &&\n            tmpOverlap > 0)\n        ) {\n          const tmp = tmpChunks.shift()!;\n          tmpOverlap -= tmp.length;\n        }\n      }\n    }\n    tmpChunks.push(chunk);\n    tmpOverlap += chunk.length;\n  }\n\n  const doc = toDoc(tmpChunks);\n  if (doc) {\n    yield doc;\n  }\n}\n\nexport function* recursiveSplitString(\n  text: string,\n  options: { size: number; overlap: number; separators: string[]; trim?: boolean },\n): Generator<string> {\n  if (options.size <= 0 || options.overlap < 0) {\n    throw new Error(\"size must be positive and overlap must be non-negative\");\n  }\n  if (options.overlap >= options.size) {\n    throw new Error(\"overlap must be less than size\");\n  }\n\n  const goodSplits: string[] = [];\n  const [separator, ...remainingSeparators] = unique([...(options.separators ?? []), \"\"]);\n\n  for (const chunk of text.split(separator).filter(Boolean)) {\n    if (chunk.length < options.size) {\n      goodSplits.push(chunk);\n      continue;\n    }\n\n    if (goodSplits.length > 0) {\n      yield* mergeStrings(goodSplits, separator, options);\n      goodSplits.length = 0;\n    }\n\n    if (remainingSeparators.length === 0) {\n      yield chunk;\n    } else {\n      yield* recursiveSplitString(chunk, { ...options, separators: remainingSeparators });\n    }\n  }\n\n  if (goodSplits.length > 0) {\n    yield* mergeStrings(goodSplits, separator, options);\n  }\n}\n\nexport const Comparator = {\n  EQ: [0] as const,\n  GT: [1] as const,\n  GTE: [0, 1] as const,\n  LT: [-1] as const,\n  LTE: [-1, 0] as const,\n} as const;\n\nexport function compareVersion(\n  a: string,\n  comparator: ValueOf<typeof Comparator>,\n  b: string,\n): boolean {\n  const diff = a.replace(\"v\", \"\").trim().localeCompare(b.replace(\"v\", \"\").trim(), undefined, {\n    numeric: true,\n    sensitivity: \"base\",\n  });\n  const diffNormalized = Math.min(1, Math.max(-1, diff));\n  return R.isIncludedIn(diffNormalized, comparator);\n}\n\nexport function isJsonLikeString(value: string | undefined): value is string {\n  if (!value) {\n    return false;\n  }\n  return value.startsWith(\"{\") && value.endsWith(\"}\");\n}\n\nexport function halveString(\n  value: string,\n  seq: string,\n  includeSeq = false,\n): [string] | [string, string] {\n  if (seq === \"\") {\n    return [value];\n  }\n\n  const index = value.indexOf(seq);\n  if (index === -1) {\n    return [value];\n  } else {\n    return [value.slice(0, index), value.slice(index + (includeSeq ? 0 : seq.length))];\n  }\n}\n\nexport function countSharedStartEndLetters(a: string, b: string): number {\n  if (!isString(a) || !isString(b)) {\n    throw new ValueError(\"Provided values must be all strings.\");\n  }\n\n  const minLength = Math.min(a.length, b.length);\n  for (let i = 0; i < minLength; i++) {\n    if (a.at((i + 1) * -1) !== b.at(i)) {\n      return i;\n    }\n  }\n  return minLength;\n}\n\nexport function findFirstPair(\n  text: string,\n  pair: [string, string],\n  options: { allowOverlap?: boolean } = {},\n) {\n  const [opening, closing] = pair || [];\n  if (!pair || !opening || !closing) {\n    throw new ValueError(`The \"pair\" parameter is required and must be non-empty!`);\n  }\n\n  let balance = 0;\n  let startIndex = -1;\n  const pairOverlap = options.allowOverlap ? countSharedStartEndLetters(opening, closing) : 0;\n\n  const isSame = opening === closing;\n  for (let index = 0; index < text.length; index++) {\n    if (text.substring(index, index + opening.length) === opening && (!isSame || balance === 0)) {\n      if (balance === 0) {\n        startIndex = index;\n      }\n      balance++;\n      if (!options.allowOverlap) {\n        index += opening.length - 1;\n      }\n    } else if (text.substring(index, index + closing.length) === closing) {\n      if (balance > 0) {\n        balance--;\n        if (balance === 0) {\n          const inner = {\n            start: startIndex + opening.length,\n            get end() {\n              let innerEnd = index;\n              const innerSize = innerEnd - this.start;\n\n              if (innerSize < 0) {\n                innerEnd = this.start;\n              } else {\n                innerEnd += pairOverlap;\n              }\n\n              return innerEnd;\n            },\n          };\n\n          return {\n            start: startIndex,\n            end: index + closing.length,\n            pair,\n            inner: text.substring(inner.start, inner.end),\n            outer: text.substring(startIndex, index + closing.length),\n          };\n        }\n      }\n      if (!options.allowOverlap) {\n        index += closing.length - 1;\n      }\n    }\n  }\n\n  return null;\n}\n"]}