import { Serializable } from '../../../internals/serializable.js';
import { RetryCounter } from '../../../internals/helpers/counter.js';
import { AgentError } from '../../base.js';
import { shallowCopy } from '../../../serializer/utils.js';

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
class BaseRunner extends Serializable {
  static {
    __name(this, "BaseRunner");
  }
  input;
  options;
  run;
  memory;
  iterations;
  failedAttemptsCounter;
  constructor(input, options, run) {
    super(), this.input = input, this.options = options, this.run = run, this.iterations = [];
    this.failedAttemptsCounter = new RetryCounter(options?.execution?.totalMaxRetries, AgentError);
  }
  async createIteration() {
    const meta = {
      iteration: this.iterations.length + 1
    };
    const maxIterations = this.options?.execution?.maxIterations ?? Infinity;
    if (meta.iteration > maxIterations) {
      throw new AgentError(`Agent was not able to resolve the task in ${maxIterations} iterations.`, [], {
        isFatal: true
      });
    }
    const emitter = this.run.emitter.child({
      groupId: `iteration-${meta.iteration}`
    });
    const iteration = await this.llm({
      emitter,
      signal: this.run.signal,
      meta
    });
    this.iterations.push(iteration);
    return {
      emitter,
      state: iteration.state,
      meta,
      signal: this.run.signal
    };
  }
  async init(input) {
    this.memory = await this.initMemory(input);
  }
  createSnapshot() {
    return {
      input: shallowCopy(this.input),
      options: shallowCopy(this.options),
      memory: this.memory,
      failedAttemptsCounter: this.failedAttemptsCounter
    };
  }
  loadSnapshot(snapshot) {
    Object.assign(this, snapshot);
  }
}

export { BaseRunner };
//# sourceMappingURL=base.js.map
//# sourceMappingURL=base.js.map