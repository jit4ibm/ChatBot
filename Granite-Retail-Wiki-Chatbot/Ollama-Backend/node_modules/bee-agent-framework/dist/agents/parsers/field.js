import { setProp } from '../../internals/helpers/object.js';
import { ValueError } from '../../errors.js';
import { Serializable } from '../../internals/serializable.js';
import { JSONParser } from '@streamparser/json';
import { jsonrepairTransform } from 'jsonrepair/stream';
import { Cache, SingletonCacheKeyFn } from '../../cache/decoratorCache.js';
import { shallowCopy } from '../../serializer/utils.js';
import { parseBrokenJson } from '../../internals/helpers/schema.js';
import { findFirstPair } from '../../internals/helpers/string.js';

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate, "_ts_decorate");
function _ts_metadata(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
}
__name(_ts_metadata, "_ts_metadata");
class ParserField extends Serializable {
  static {
    __name(this, "ParserField");
  }
  raw = "";
  write(chunk) {
    this.raw += chunk;
  }
  async end() {
  }
  createSnapshot() {
    return {
      raw: this.raw
    };
  }
  loadSnapshot(snapshot) {
    Object.assign(this, snapshot);
  }
}
class ZodParserField extends ParserField {
  static {
    __name(this, "ZodParserField");
  }
  schema;
  static {
    this.register();
  }
  constructor(schema) {
    super(), this.schema = schema;
  }
  get() {
    return this.schema.parse(this.raw);
  }
  getPartial() {
    return this.raw;
  }
  createSnapshot() {
    return {
      ...super.createSnapshot(),
      schema: this.schema
    };
  }
}
class JSONParserField extends ParserField {
  static {
    __name(this, "JSONParserField");
  }
  input;
  stream;
  jsonParser;
  errored;
  ref;
  constructor(input) {
    super(), this.input = input, this.errored = false;
    if (input.base === void 0) {
      throw new ValueError(`Base must be defined!`);
    }
    this.init();
  }
  init() {
    this.ref = {
      value: shallowCopy(this.input.base)
    };
    this.jsonParser = new JSONParser({
      emitPartialTokens: false,
      emitPartialValues: true
    });
    this.stream = jsonrepairTransform();
    this.stream.on("data", (chunk) => {
      if (this.errored) {
        return;
      }
      try {
        this.jsonParser.write(chunk.toString());
      } catch {
        this.errored = true;
      }
    });
    this.jsonParser.onValue = ({ value, key, stack }) => {
      const keys = stack.map((s) => s.key).concat(key).filter((s) => s !== void 0).map(String);
      if (keys.length === 0 && value === void 0) {
        return;
      }
      const prefix = "value";
      setProp(this.ref, [
        prefix,
        ...keys
      ], value);
    };
  }
  write(chunk) {
    if (this.input.matchPair) {
      if (!this.raw) {
        const startChar = this.input.matchPair[0];
        const index = chunk.indexOf(startChar);
        if (index === -1) {
          return;
        }
        chunk = chunk.substring(index);
      } else {
        const merged = this.raw.concat(chunk);
        const match = findFirstPair(merged, this.input.matchPair);
        if (match) {
          if (match.end < this.raw.length) {
            return;
          }
          chunk = merged.substring(this.raw.length, match.end);
        }
      }
    }
    super.write(chunk);
    try {
      this.stream.push(chunk);
    } catch {
      this.errored = true;
    }
  }
  get() {
    const inputToParse = this.errored ? parseBrokenJson(this.raw, {
      pair: this.input.matchPair
    }) : this.ref.value;
    return this.input.schema.parse(inputToParse);
  }
  getPartial() {
    return this.ref.value;
  }
  async end() {
    if (this.stream.closed || this.jsonParser.isEnded || this.errored) {
      return;
    }
    return new Promise((resolve, reject) => {
      this.jsonParser.onEnd = resolve;
      this.jsonParser.onError = reject;
      this.stream.push(null);
      this.jsonParser.end();
    });
  }
  createSnapshot() {
    return {
      ...super.createSnapshot(),
      input: this.input,
      errored: this.errored
    };
  }
  loadSnapshot({ raw, ...snapshot }) {
    Object.assign(this, {
      raw: "",
      ...snapshot
    });
    this.init();
    this.write(raw);
  }
}
_ts_decorate([
  Cache({
    cacheKey: SingletonCacheKeyFn
  }),
  _ts_metadata("design:type", Function),
  _ts_metadata("design:paramtypes", []),
  _ts_metadata("design:returntype", void 0)
], JSONParserField.prototype, "init", null);

export { JSONParserField, ParserField, ZodParserField };
//# sourceMappingURL=field.js.map
//# sourceMappingURL=field.js.map