import { Emitter } from '../../emitter/emitter.js';
import { entries } from 'remeda';
import { ValueError } from '../../errors.js';
import { Serializable } from '../../internals/serializable.js';
import { shallowCopy } from '../../serializer/utils.js';
import { Cache } from '../../cache/decoratorCache.js';
import { ZodError } from 'zod';
import { LinePrefixParserError } from './errors.js';
export * from './errors.js';

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate, "_ts_decorate");
function _ts_metadata(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
}
__name(_ts_metadata, "_ts_metadata");
const NEW_LINE_CHARACTER = "\n";
const trimLeftSpaces = /* @__PURE__ */ __name((value) => value.replace(/^\s*/g, ""), "trimLeftSpaces");
const linesToString = /* @__PURE__ */ __name((lines) => lines.reduce((acc, { newLine, value }) => `${acc}${newLine ? NEW_LINE_CHARACTER.concat(value) : value}`, ""), "linesToString");
class LinePrefixParser extends Serializable {
  static {
    __name(this, "LinePrefixParser");
  }
  nodes;
  options;
  emitter;
  lines;
  excludedLines;
  done;
  lastNodeKey;
  finalState;
  partialState;
  get isDone() {
    return this.done;
  }
  constructor(nodes, options = {}) {
    super(), this.nodes = nodes, this.options = options, this.emitter = new Emitter({
      creator: this,
      namespace: [
        "agent",
        "parser",
        "line"
      ]
    }), this.lines = [], this.excludedLines = [], this.done = false, this.lastNodeKey = null, this.finalState = {}, this.partialState = {};
    let hasStartNode = false;
    let hasEndNode = false;
    for (const [key, { next, isStart, isEnd }] of entries(nodes ?? {})) {
      hasStartNode = Boolean(hasStartNode || isStart);
      hasEndNode = Boolean(hasEndNode || isEnd);
      for (const nextKey of next) {
        if (key === nextKey) {
          throw new ValueError(`Node '${key}' cannot point to itself.`);
        }
        if (!(nextKey in nodes)) {
          throw new ValueError(`Node '${key}' contains a transition to non-existing node '${nextKey}'.`);
        }
      }
    }
    if (!hasStartNode) {
      throw new ValueError(`At least one start node must be provided!`);
    }
    if (!hasEndNode) {
      throw new ValueError(`At least one end node must be provided!`);
    }
  }
  fork(customizer) {
    const { nodes, options } = customizer(this.nodes, this.options);
    return new LinePrefixParser(nodes, options);
  }
  async add(chunk) {
    if (!chunk || this.done) {
      return;
    }
    chunk.split(NEW_LINE_CHARACTER).forEach((line, i, arr) => {
      const isFirstLine = i === 0;
      if (isFirstLine) {
        if (this.lines.length === 0) {
          this.lines.push({
            newLine: false,
            value: line
          });
        } else {
          this.lines.at(-1).value += line;
        }
      } else {
        this.lines.push({
          newLine: arr.length > 1,
          value: line
        });
      }
    });
    while (this.lines.length > 0) {
      const line = this.lines[0];
      const isLastLine = this.lines.length === 1;
      const lastNode = this.lastNodeKey ? this.nodes[this.lastNodeKey] : null;
      const isTerminationNode = lastNode ? Boolean(lastNode.isEnd && lastNode.next.length === 0) : false;
      const parsedLine = isTerminationNode || lastNode && !line.newLine ? null : this.extractLine(line.value);
      if (isLastLine && (parsedLine?.partial || !line.value)) {
        break;
      }
      this.lines.shift();
      if (parsedLine && !parsedLine.partial) {
        if (lastNode) {
          if (!lastNode.next.includes(parsedLine.key)) {
            if (parsedLine.key in this.finalState && this.options.endOnRepeat && lastNode.isEnd) {
              await this.end();
              return;
            }
            this.throwWithContext(`Transition from '${this.lastNodeKey}' to '${parsedLine.key}' does not exist!`, LinePrefixParserError.Reason.InvalidTransition, {
              line
            });
          }
          await this.emitFinalUpdate(this.lastNodeKey, lastNode.field);
        } else if (!this.nodes[parsedLine.key].isStart) {
          if (!this.options.waitForStartNode) {
            this.throwWithContext(`Parsed text line corresponds to a node "${parsedLine.key}" which is not a start node!`, LinePrefixParserError.Reason.NotStartNode, {
              line
            });
          }
          this.excludedLines.push(line);
          continue;
        }
        const node = this.nodes[parsedLine.key];
        node.field.write(parsedLine.value);
        await this.emitPartialUpdate({
          key: parsedLine.key,
          value: node.field.getPartial(),
          delta: parsedLine.value,
          field: node.field
        });
        this.lastNodeKey = parsedLine.key;
      } else if (this.lastNodeKey) {
        if (!this.nodes[this.lastNodeKey].field.raw) {
          line.value = trimLeftSpaces(line.value);
        }
        if (line.newLine) {
          line.value = `${NEW_LINE_CHARACTER}${line.value}`;
        }
        const node = this.nodes[this.lastNodeKey];
        node.field.write(line.value);
        await this.emitPartialUpdate({
          key: this.lastNodeKey,
          value: node.field.getPartial(),
          delta: line.value,
          field: node.field
        });
      } else {
        this.excludedLines.push(line);
      }
    }
  }
  throwWithContext(message, reason, extra = {}) {
    throw new LinePrefixParserError([
      `The generated output does not adhere to the schema.`,
      message
    ].join(NEW_LINE_CHARACTER), extra.errors ?? [], {
      reason,
      context: {
        lines: linesToString(this.lines.concat(extra.line ? [
          extra.line
        ] : [])),
        excludedLines: linesToString(this.excludedLines),
        finalState: this.finalState,
        partialState: this.partialState
      }
    });
  }
  async end() {
    if (this.done) {
      return this.finalState;
    }
    if (!this.lastNodeKey && this.options.fallback) {
      const stash2 = linesToString([
        ...this.excludedLines.splice(0, Infinity),
        ...this.lines.splice(0, Infinity)
      ]);
      const nodes = this.options.fallback(stash2);
      await this.add(nodes.map((node) => `${this.nodes[node.key].prefix}${node.value}`).join(NEW_LINE_CHARACTER));
    }
    this.done = true;
    if (!this.lastNodeKey) {
      this.throwWithContext("Nothing valid has been parsed yet!", LinePrefixParserError.Reason.NoDataReceived);
    }
    const stash = linesToString(this.lines);
    this.lines.length = 0;
    const field = this.nodes[this.lastNodeKey].field;
    if (stash) {
      field.write(stash);
      await this.emitPartialUpdate({
        key: this.lastNodeKey,
        value: field.getPartial(),
        delta: stash,
        field
      });
    }
    await this.emitFinalUpdate(this.lastNodeKey, field);
    const currentNode = this.nodes[this.lastNodeKey];
    if (!currentNode.isEnd) {
      this.throwWithContext(`Node '${this.lastNodeKey}' is not an end node.`, LinePrefixParserError.Reason.NotEndNode);
    }
    await Promise.allSettled(Object.values(this.nodes).map(({ field: field2 }) => field2.end()));
    return this.finalState;
  }
  async emitPartialUpdate(data) {
    if (data.key in this.finalState) {
      this.throwWithContext(`Cannot update partial event for completed key '${data.key}'`, LinePrefixParserError.Reason.AlreadyCompleted);
    }
    if (!(data.key in this.partialState)) {
      this.partialState[data.key] = "";
    }
    this.partialState[data.key] += data.delta;
    await this.emitter.emit("partialUpdate", data);
  }
  async emitFinalUpdate(key, field) {
    if (key in this.finalState) {
      this.throwWithContext(`Duplicated key '${key}'`, LinePrefixParserError.Reason.AlreadyCompleted);
    }
    try {
      const value = field.get();
      this.finalState[key] = value;
      await this.emitter.emit("update", {
        key,
        field,
        value
      });
    } catch (e) {
      if (e instanceof ZodError) {
        this.throwWithContext(`Value for '${key}' cannot be retrieved because it's value does not adhere to the appropriate schema.`, LinePrefixParserError.Reason.InvalidSchema, {
          errors: [
            e
          ]
        });
      }
      throw e;
    }
  }
  get normalizedNodes() {
    return entries(this.nodes).sort(([_, a], [__, b]) => a.prefix.length - b.prefix.length).map(([key, value]) => {
      return [
        key,
        {
          lowerCasePrefix: value.prefix.toLowerCase(),
          ref: value
        }
      ];
    });
  }
  extractLine(line) {
    const trimmedLine = trimLeftSpaces(line);
    if (!trimmedLine) {
      return null;
    }
    for (const [key, node] of this.normalizedNodes) {
      const partial = node.lowerCasePrefix.length > trimmedLine.length;
      const [a, b] = partial ? [
        node.lowerCasePrefix,
        trimmedLine
      ] : [
        trimmedLine,
        node.lowerCasePrefix
      ];
      if (a.toLowerCase().startsWith(b.toLowerCase())) {
        return {
          key,
          value: partial ? trimmedLine : trimLeftSpaces(a.substring(b.length)),
          partial
        };
      }
    }
    return null;
  }
  createSnapshot() {
    return {
      nodes: shallowCopy(this.nodes),
      lines: shallowCopy(this.lines),
      emitter: this.emitter,
      done: this.done,
      lastNodeKey: this.lastNodeKey,
      options: this.options
    };
  }
  loadSnapshot(snapshot) {
    return Object.assign(this, snapshot);
  }
}
_ts_decorate([
  Cache(),
  _ts_metadata("design:type", void 0),
  _ts_metadata("design:paramtypes", [])
], LinePrefixParser.prototype, "normalizedNodes", null);

export { LinePrefixParser };
//# sourceMappingURL=linePrefix.js.map
//# sourceMappingURL=linePrefix.js.map