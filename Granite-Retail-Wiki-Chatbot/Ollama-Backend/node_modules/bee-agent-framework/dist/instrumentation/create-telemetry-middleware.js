import { getSerializedObjectSafe } from './helpers/get-serialized-object-safe.js';
import { createSpan } from './helpers/create-span.js';
import { IdNameManager } from './helpers/id-name-manager.js';
import { getErrorSafe } from './helpers/get-error-safe.js';
import { findLast, isEmpty, isDeepEqual } from 'remeda';
import { FrameworkError } from '../errors.js';
import { Version } from '../version.js';
import { Role } from '../llms/primitives/message.js';
import { activeTracesMap, buildTraceTree } from './tracer.js';
import { traceSerializer } from './helpers/trace-serializer.js';
import { INSTRUMENTATION_IGNORED_KEYS } from './config.js';
import { createFullPath } from '../emitter/utils.js';
import { instrumentationLogger } from './logger.js';
import { BaseAgent } from '../agents/base.js';
import { assertLLMWithMessagesToPromptFn } from './helpers/utils.js';

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
function createTelemetryMiddleware() {
  return (context) => {
    if (!context.emitter?.trace?.id) {
      throw new FrameworkError(`Fatal error. Missing traceId`, [], {
        context
      });
    }
    const traceId = context.emitter?.trace?.id;
    if (activeTracesMap.has(traceId)) {
      return;
    }
    activeTracesMap.set(traceId, context.instance.constructor.name);
    instrumentationLogger.debug({
      source: context.instance.constructor.name,
      traceId
    }, "createTelemetryMiddleware");
    const { emitter, runParams, instance } = context;
    const basePath = createFullPath(emitter.namespace, "");
    let prompt = null;
    if (instance instanceof BaseAgent) {
      prompt = runParams[0].prompt;
    }
    const spansMap = /* @__PURE__ */ new Map();
    const parentIdsMap = /* @__PURE__ */ new Map();
    const spansToDeleteMap = /* @__PURE__ */ new Map();
    let generatedMessage = void 0;
    let history = void 0;
    const groupIterations = [];
    const idNameManager = new IdNameManager();
    const newTokenEventName = `newToken`;
    const partialUpdateEventName = "partialUpdate";
    const successEventName = `success`;
    const finishEventName = `finish`;
    const startEventName = `start`;
    const errorEventName = `error`;
    const eventsIterationsMap = /* @__PURE__ */ new Map();
    const startTimeDate = (/* @__PURE__ */ new Date()).getTime();
    const startTimePerf = performance.now();
    function convertDateToPerformance(date) {
      return date.getTime() - startTimeDate + startTimePerf;
    }
    __name(convertDateToPerformance, "convertDateToPerformance");
    const serializer = traceSerializer({
      ignored_keys: INSTRUMENTATION_IGNORED_KEYS
    });
    function cleanSpanSources({ spanId }) {
      const parentId = spansMap.get(spanId)?.parent_id;
      if (!parentId) {
        return;
      }
      const spanCount = parentIdsMap.get(parentId);
      if (!spanCount) {
        return;
      }
      if (spanCount > 1) {
        parentIdsMap.set(parentId, spanCount - 1);
      } else if (spanCount === 1) {
        parentIdsMap.delete(parentId);
        if (spansToDeleteMap.has(parentId)) {
          spansMap.delete(parentId);
          spansToDeleteMap.delete(parentId);
        }
      }
    }
    __name(cleanSpanSources, "cleanSpanSources");
    emitter.match((event) => event.path === `${basePath}.run.${finishEventName}`, async (_, meta) => {
      try {
        instrumentationLogger.debug({
          path: meta.path,
          traceId
        }, "run finish event");
        if (!prompt && instance instanceof BaseAgent) {
          prompt = findLast(instance.memory.messages, (message) => message.role === Role.USER)?.text;
          if (!prompt) {
            throw new FrameworkError("The prompt must be defined for the Agent's run", [], {
              context
            });
          }
        }
        buildTraceTree({
          prompt,
          history,
          generatedMessage,
          spans: JSON.parse(serializer(Array.from(spansMap.values()))),
          traceId,
          version: Version,
          runErrorSpanKey: `${basePath}.run.${errorEventName}`,
          startTime: startTimePerf,
          endTime: performance.now(),
          source: activeTracesMap.get(traceId)
        });
      } catch (e) {
        instrumentationLogger.warn(e, "Instrumentation error");
      } finally {
        activeTracesMap.delete(traceId);
      }
    });
    emitter.match("*.*", (data, meta) => {
      if (meta.path.includes(".run.") && meta.path !== `${basePath}.run.${errorEventName}`) {
        return;
      }
      if (!meta.trace?.runId) {
        throw new FrameworkError(`Fatal error. Missing runId for event: ${meta.path}`, [], {
          context
        });
      }
      if (meta.groupId && !meta.trace.parentRunId && !groupIterations.includes(meta.groupId)) {
        spansMap.set(meta.groupId, createSpan({
          id: meta.groupId,
          name: meta.groupId,
          target: "groupId",
          startedAt: convertDateToPerformance(meta.createdAt)
        }));
        groupIterations.push(meta.groupId);
      }
      const { spanId, parentSpanId } = idNameManager.getIds({
        path: meta.path,
        id: meta.id,
        runId: meta.trace.runId,
        parentRunId: meta.trace.parentRunId,
        groupId: meta.groupId
      });
      const serializedData = getSerializedObjectSafe(data);
      if (meta.name === partialUpdateEventName && isEmpty(serializedData)) {
        return;
      }
      const span = createSpan({
        id: spanId,
        name: meta.name,
        target: meta.path,
        ...parentSpanId && {
          parent: {
            id: parentSpanId
          }
        },
        ctx: getSerializedObjectSafe(meta.context),
        data: serializedData,
        error: getErrorSafe(data),
        startedAt: convertDateToPerformance(meta.createdAt)
      });
      const lastIteration = groupIterations[groupIterations.length - 1];
      const lastIterationOnNewTokenSpanId = eventsIterationsMap.get(lastIteration)?.get(meta.name);
      if (lastIterationOnNewTokenSpanId && meta.name === newTokenEventName) {
        cleanSpanSources({
          spanId: lastIterationOnNewTokenSpanId
        });
        spansMap.delete(lastIterationOnNewTokenSpanId);
      }
      const lastIterationEventSpanId = eventsIterationsMap.get(lastIteration)?.get(meta.name);
      if (lastIterationEventSpanId && partialUpdateEventName === meta.name && spansMap.has(lastIterationEventSpanId)) {
        const { attributes, context: context2 } = spansMap.get(lastIterationEventSpanId);
        if (isDeepEqual(serializedData, attributes.data)) {
          if (parentIdsMap.has(context2.span_id)) {
            spansToDeleteMap.set(lastIterationEventSpanId, void 0);
          } else {
            cleanSpanSources({
              spanId: lastIterationEventSpanId
            });
            spansMap.delete(lastIterationEventSpanId);
          }
        }
      }
      spansMap.set(span.context.span_id, span);
      if (span.parent_id) {
        parentIdsMap.set(span.parent_id, (parentIdsMap.get(span.parent_id) || 0) + 1);
      }
      if (groupIterations.length > 0) {
        if (eventsIterationsMap.has(lastIteration)) {
          eventsIterationsMap.get(lastIteration).set(meta.name, span.context.span_id);
        } else {
          eventsIterationsMap.set(lastIteration, (/* @__PURE__ */ new Map()).set(meta.name, span.context.span_id));
        }
      }
    });
    emitter.match((event) => event.name === successEventName && event.creator instanceof BaseAgent, (data) => {
      const { data: dataObject, memory } = data;
      generatedMessage = {
        role: dataObject.role,
        text: dataObject.text
      };
      history = memory.messages.map((msg) => ({
        text: msg.text,
        role: msg.role
      }));
    });
    emitter.match((event) => assertLLMWithMessagesToPromptFn(event.creator) && event.name === startEventName, ({ input }, meta) => {
      if (assertLLMWithMessagesToPromptFn(meta.creator) && meta.trace) {
        const rawPrompt = meta.creator.messagesToPrompt(input);
        const path = `${meta.path}.custom`;
        const { spanId, parentSpanId } = idNameManager.getIds({
          path,
          id: meta.id,
          runId: meta.trace.runId,
          parentRunId: meta.trace.parentRunId,
          groupId: meta.groupId
        });
        spansMap.set(spanId, createSpan({
          id: spanId,
          name: `${meta.name}Custom`,
          target: path,
          startedAt: convertDateToPerformance(meta.createdAt),
          ...parentSpanId && {
            parent: {
              id: parentSpanId
            }
          },
          data: {
            rawPrompt,
            creator: meta.creator.createSnapshot()
          }
        }));
      }
    });
  };
}
__name(createTelemetryMiddleware, "createTelemetryMiddleware");

export { createTelemetryMiddleware };
//# sourceMappingURL=create-telemetry-middleware.js.map
//# sourceMappingURL=create-telemetry-middleware.js.map