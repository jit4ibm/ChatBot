import { SerializableClass, Serializable } from './internals/serializable.cjs';
import { ClassConstructor, NamedFunction, AnyFn, AnyConstructable } from './internals/types.cjs';

/**
 * Copyright 2024 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare const SerializerSelfRefIdentifier = "__self_ref";
declare const SerializerRefIdentifier = "__ref";
declare class RefPlaceholder<T = unknown> {
    protected readonly node: SerializerNode;
    protected readonly factory: SerializeFactory<T>;
    private static EmptyPlaceholder;
    private partialResult;
    constructor(node: SerializerNode, factory: SerializeFactory<T>);
    get value(): T;
    get final(): T;
}
interface SerializerNode {
    __class: string;
    __ref: string;
    __value: unknown;
    __serializer: true;
}
declare function isSerializerNode(data: unknown): data is SerializerNode;
interface RootNode<T = any> {
    __version: string;
    __root: T;
}
declare function isRootNode<T>(data: unknown): data is RootNode<T>;
declare const extractClassName: (value: unknown) => string;
declare function primitiveToSerializableClass(value: unknown): SymbolConstructor | ObjectConstructor | FunctionConstructor | BooleanConstructor | StringConstructor | NumberConstructor | BigIntConstructor | {
    new (): {};
} | {
    new (): {};
};
type TraverseObjectFn = (el: {
    key: string;
    path: readonly string[];
    value: any;
}) => void;
declare function traverseObject(obj: unknown, handler: TraverseObjectFn, stopFn?: (_obj: unknown) => boolean): void;
declare function isSerializationRequired(factory: ClassConstructor | NamedFunction): boolean;
declare function traverseWithUpdate<T = unknown>(_obj: unknown): Generator<{
    value: T;
    update: (value: T) => void;
}>;
declare function shallowCopy<T>(value: T): T;
type Bounded = {
    name: string;
    value: any;
} | AnyConstructable;
declare function toBoundedFunction<T extends AnyFn>(fn: T, binds: [Bounded, ...Bounded[]]): T;
declare namespace toBoundedFunction {
    var symbol: symbol;
}
declare function getFunctionBinds<T extends Function>(fn: T): Bounded[];

/**
 * Copyright 2024 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

interface SerializeFactory<A = unknown, B = unknown> {
    ref: ClassConstructor<A> | NamedFunction<A>;
    createEmpty?: () => A;
    updateInstance?: (instance: A, update: A) => void;
    toPlain: (value: A) => B;
    fromPlain: (value: B) => A;
}
declare class Serializer {
    private static factories;
    static registerSerializable<A>(ref: SerializableClass<A>, processors?: Partial<Omit<SerializeFactory<Serializable<A>, A>, "ref">>, aliases?: string[]): void;
    static deregister(ref: ClassConstructor | NamedFunction): void;
    static register<A, B = unknown>(ref: ClassConstructor<A> | NamedFunction<A>, processors: Omit<SerializeFactory<A, B>, "ref">, aliases?: string[]): void;
    static getFactory(clsName: string): SerializeFactory;
    static findFactory(value: unknown): {
        targetClass: string;
        factory: SerializeFactory<unknown, unknown>;
        isSelfRef: boolean;
    } | {
        targetClass: string;
        factory: SerializeFactory<any, any>;
        isSelfRef: boolean;
    };
    static hasFactory(clsName: string): boolean;
    static serialize<T>(rawData: T): string;
    /** @internal */
    static deserializeWithMeta<T = any>(raw: string, extraClasses?: SerializableClass<unknown>[]): RootNode<T>;
    static deserialize<T = any>(raw: string, extraClasses?: SerializableClass<unknown>[]): T;
    protected static _createOutputBuilder<T>(): {
        _container: T;
        get(): T;
        update(path: readonly string[], value: any): void;
        toJSON(): string;
    };
}

export { RefPlaceholder as R, type SerializeFactory as S, Serializer as a, SerializerSelfRefIdentifier as b, SerializerRefIdentifier as c, type SerializerNode as d, type RootNode as e, isRootNode as f, extractClassName as g, isSerializationRequired as h, isSerializerNode as i, traverseWithUpdate as j, toBoundedFunction as k, getFunctionBinds as l, primitiveToSerializableClass as p, shallowCopy as s, traverseObject as t };
