'use strict';

var schema_cjs = require('../../internals/helpers/schema.cjs');
var base_cjs = require('../base.cjs');
var message_cjs = require('../primitives/message.cjs');
var retryable_cjs = require('../../internals/helpers/retryable.cjs');
var template_cjs = require('../../template.cjs');
var zod = require('zod');
var serializable_cjs = require('../../internals/serializable.cjs');

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
class BaseDriver extends serializable_cjs.Serializable {
  static {
    __name(this, "BaseDriver");
  }
  llm;
  errorTemplate;
  constructor(llm) {
    super(), this.llm = llm, this.errorTemplate = new template_cjs.PromptTemplate({
      schema: zod.z.object({
        errors: zod.z.string(),
        expected: zod.z.string(),
        received: zod.z.string()
      }),
      template: `Generated response does not match the expected schema!
Validation Errors: "{{errors}}"`
    });
  }
  // eslint-disable-next-line unused-imports/no-unused-vars
  guided(schema) {
    return void 0;
  }
  async generate(schema, input, { maxRetries = 3, options } = {}) {
    const jsonSchema = schema_cjs.toJsonSchema(schema);
    const validator = schema_cjs.createSchemaValidator(jsonSchema);
    const schemaString = await this.schemaToString(jsonSchema);
    const messages = [
      message_cjs.BaseMessage.of({
        role: message_cjs.Role.SYSTEM,
        text: this.template.render({
          schema: schemaString
        })
      }),
      ...input
    ];
    return new retryable_cjs.Retryable({
      executor: /* @__PURE__ */ __name(async () => {
        const raw = await this.llm.generate(messages, {
          guided: this.guided(jsonSchema),
          ...options
        });
        const textResponse = raw.getTextContent();
        let parsed;
        try {
          parsed = this.parseResponse(textResponse);
        } catch (error) {
          throw new base_cjs.LLMError(`Failed to parse the generated response.`, [], {
            isFatal: false,
            isRetryable: true,
            context: {
              error: error.message,
              received: textResponse
            }
          });
        }
        const success = validator(parsed);
        if (!success) {
          const context = {
            expected: schemaString,
            received: textResponse,
            errors: JSON.stringify(validator.errors ?? [])
          };
          messages.push(message_cjs.BaseMessage.of({
            role: message_cjs.Role.USER,
            text: this.errorTemplate.render(context)
          }));
          throw new base_cjs.LLMError("Failed to generate a structured response adhering to the provided schema.", [], {
            isFatal: false,
            isRetryable: true,
            context
          });
        }
        return {
          raw,
          parsed,
          messages
        };
      }, "executor"),
      config: {
        signal: options?.signal,
        maxRetries
      }
    }).get();
  }
  createSnapshot() {
    return {
      template: this.template,
      errorTemplate: this.errorTemplate
    };
  }
  loadSnapshot(snapshot) {
    Object.assign(this, snapshot);
  }
}

exports.BaseDriver = BaseDriver;
//# sourceMappingURL=base.cjs.map
//# sourceMappingURL=base.cjs.map