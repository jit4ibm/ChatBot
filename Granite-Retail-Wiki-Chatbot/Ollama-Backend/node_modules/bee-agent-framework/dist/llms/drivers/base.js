import { toJsonSchema, createSchemaValidator } from '../../internals/helpers/schema.js';
import { LLMError } from '../base.js';
import { BaseMessage, Role } from '../primitives/message.js';
import { Retryable } from '../../internals/helpers/retryable.js';
import { PromptTemplate } from '../../template.js';
import { z } from 'zod';
import { Serializable } from '../../internals/serializable.js';

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
class BaseDriver extends Serializable {
  static {
    __name(this, "BaseDriver");
  }
  llm;
  errorTemplate;
  constructor(llm) {
    super(), this.llm = llm, this.errorTemplate = new PromptTemplate({
      schema: z.object({
        errors: z.string(),
        expected: z.string(),
        received: z.string()
      }),
      template: `Generated response does not match the expected schema!
Validation Errors: "{{errors}}"`
    });
  }
  // eslint-disable-next-line unused-imports/no-unused-vars
  guided(schema) {
    return void 0;
  }
  async generate(schema, input, { maxRetries = 3, options } = {}) {
    const jsonSchema = toJsonSchema(schema);
    const validator = createSchemaValidator(jsonSchema);
    const schemaString = await this.schemaToString(jsonSchema);
    const messages = [
      BaseMessage.of({
        role: Role.SYSTEM,
        text: this.template.render({
          schema: schemaString
        })
      }),
      ...input
    ];
    return new Retryable({
      executor: /* @__PURE__ */ __name(async () => {
        const raw = await this.llm.generate(messages, {
          guided: this.guided(jsonSchema),
          ...options
        });
        const textResponse = raw.getTextContent();
        let parsed;
        try {
          parsed = this.parseResponse(textResponse);
        } catch (error) {
          throw new LLMError(`Failed to parse the generated response.`, [], {
            isFatal: false,
            isRetryable: true,
            context: {
              error: error.message,
              received: textResponse
            }
          });
        }
        const success = validator(parsed);
        if (!success) {
          const context = {
            expected: schemaString,
            received: textResponse,
            errors: JSON.stringify(validator.errors ?? [])
          };
          messages.push(BaseMessage.of({
            role: Role.USER,
            text: this.errorTemplate.render(context)
          }));
          throw new LLMError("Failed to generate a structured response adhering to the provided schema.", [], {
            isFatal: false,
            isRetryable: true,
            context
          });
        }
        return {
          raw,
          parsed,
          messages
        };
      }, "executor"),
      config: {
        signal: options?.signal,
        maxRetries
      }
    }).get();
  }
  createSnapshot() {
    return {
      template: this.template,
      errorTemplate: this.errorTemplate
    };
  }
  loadSnapshot(snapshot) {
    Object.assign(this, snapshot);
  }
}

export { BaseDriver };
//# sourceMappingURL=base.js.map
//# sourceMappingURL=base.js.map