'use strict';

var base_cjs = require('./base.cjs');
var fs = require('node:fs');
var slidingCache_cjs = require('./slidingCache.cjs');
var decoratorCache_cjs = require('./decoratorCache.cjs');
var serializer_cjs = require('../serializer/serializer.cjs');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var fs__default = /*#__PURE__*/_interopDefault(fs);

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate, "_ts_decorate");
function _ts_metadata(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
}
__name(_ts_metadata, "_ts_metadata");
class FileCache extends base_cjs.BaseCache {
  static {
    __name(this, "FileCache");
  }
  input;
  constructor(input) {
    super(), this.input = input;
  }
  static {
    this.register();
  }
  get source() {
    return this.input.fullPath;
  }
  static async fromProvider(provider, input) {
    await fs__default.default.promises.writeFile(input.fullPath, provider.serialize());
    return new FileCache(input);
  }
  async getProvider() {
    const exists = await fs__default.default.promises.stat(this.input.fullPath).then((r) => r.isFile()).catch(() => false);
    if (exists) {
      const serialized = await fs__default.default.promises.readFile(this.input.fullPath, "utf8");
      const { target, snapshot } = await serializer_cjs.Serializer.deserialize(serialized);
      const Target = serializer_cjs.Serializer.getFactory(target).ref;
      const instance = Target.fromSnapshot(snapshot);
      if (!(instance instanceof base_cjs.BaseCache)) {
        throw new TypeError("Provided file does not serialize any instance of BaseCache class.");
      }
      return instance;
    } else {
      return new slidingCache_cjs.SlidingCache({
        size: Infinity,
        ttl: Infinity
      });
    }
  }
  async reload() {
    decoratorCache_cjs.Cache.getInstance(this, "getProvider").clear();
    void await this.getProvider();
  }
  async save() {
    const provider = await this.getProvider();
    return await fs__default.default.promises.writeFile(this.input.fullPath, provider.serialize());
  }
  async size() {
    const provider = await this.getProvider();
    return provider.size();
  }
  async set(key, value) {
    const provider = await this.getProvider();
    await provider.set(key, value);
    void provider.get(key).finally(() => {
      void this.save();
    });
  }
  async get(key) {
    const provider = await this.getProvider();
    return await provider.get(key);
  }
  async has(key) {
    const provider = await this.getProvider();
    return await provider.has(key);
  }
  async delete(key) {
    const provider = await this.getProvider();
    const result = await provider.delete(key);
    await this.save();
    return result;
  }
  async clear() {
    const provider = await this.getProvider();
    await provider.clear();
    await this.save();
  }
  async createSnapshot() {
    return {
      input: {
        fullPath: this.input.fullPath
      },
      provider: await this.getProvider()
    };
  }
  loadSnapshot(snapshot) {
    Object.assign(this, snapshot);
  }
}
_ts_decorate([
  decoratorCache_cjs.Cache(),
  _ts_metadata("design:type", Function),
  _ts_metadata("design:paramtypes", []),
  _ts_metadata("design:returntype", Promise)
], FileCache.prototype, "getProvider", null);

exports.FileCache = FileCache;
//# sourceMappingURL=fileCache.cjs.map
//# sourceMappingURL=fileCache.cjs.map