import * as R from 'remeda';
import { Serializable } from '../internals/serializable.js';
import { SafeWeakMap, SafeWeakSet } from '../internals/helpers/weakRef.js';
import { serializeError, deserializeError } from 'serialize-error';
import { Version } from '../version.js';
import { extractClassName, traverseObject, isRootNode, isSerializerNode, SerializerRefIdentifier, primitiveToSerializableClass, isSerializationRequired, SerializerSelfRefIdentifier, traverseWithUpdate, RefPlaceholder, getFunctionBinds, toBoundedFunction } from './utils.js';
import { Task, SlidingTaskMap, TaskState } from 'promise-based-task';
import { setProp, getProp } from '../internals/helpers/object.js';
import { halveString } from '../internals/helpers/string.js';
import { traversePrototypeChain } from '../internals/helpers/prototype.js';
import { CacheFn } from '../cache/decoratorCache.js';
import { SerializerError } from './error.js';
import { ZodType } from 'zod';
import { toJsonSchema } from '../internals/helpers/schema.js';
import { createAbortController } from '../internals/helpers/cancellation.js';
import { hasMinLength } from '../internals/helpers/array.js';

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
class Serializer {
  static {
    __name(this, "Serializer");
  }
  static factories = /* @__PURE__ */ new Map();
  static registerSerializable(ref, processors, aliases) {
    return Serializer.register(ref, {
      toPlain: /* @__PURE__ */ __name((value) => value.createSnapshot(), "toPlain"),
      fromPlain: /* @__PURE__ */ __name((value) => ref.fromSnapshot(value), "fromPlain"),
      createEmpty: /* @__PURE__ */ __name(() => Object.create(ref.prototype), "createEmpty"),
      updateInstance: /* @__PURE__ */ __name((instance, update) => instance.loadSnapshot(update), "updateInstance"),
      ...R.pickBy(processors ?? {}, R.isDefined)
    }, aliases);
  }
  static deregister(ref) {
    const className = extractClassName(ref);
    Serializer.factories.delete(className);
  }
  static register(ref, processors, aliases) {
    const className = extractClassName(ref);
    const oldFactory = Serializer.factories.get(className);
    const newFactory = {
      ref,
      ...processors
    };
    if (oldFactory) {
      if (oldFactory.ref !== ref) {
        throw new SerializerError(`Factory for class "${className}" already exists!`);
      }
      for (const [key, value] of Serializer.factories.entries()) {
        if (value === oldFactory) {
          Serializer.factories.set(key, newFactory);
        }
      }
    }
    Serializer.factories.set(className, newFactory);
    aliases?.forEach((alias) => {
      const aliasTarget = Serializer.factories.get(alias);
      if (!aliasTarget) {
        this.factories.set(alias, newFactory);
      } else if (aliasTarget !== newFactory) {
        throw new SerializerError(`Factory for class "${className}" already exists! Cannot add alias.`);
      }
    });
  }
  static getFactory(clsName) {
    const factory = Serializer.factories.get(clsName);
    if (!factory) {
      throw new SerializerError(`Class "${clsName}" was not found!`);
    }
    return factory;
  }
  static findFactory(value) {
    let targetClass = extractClassName(value);
    if (!Serializer.hasFactory(targetClass) && R.isFunction(value)) {
      targetClass = Function.name;
    }
    if (Serializer.hasFactory(targetClass)) {
      const factory = Serializer.getFactory(targetClass);
      return {
        targetClass,
        factory,
        isSelfRef: factory.ref === value
      };
    }
    const excluded = /* @__PURE__ */ new Set([
      null,
      Object.prototype
    ]);
    for (const proto of traversePrototypeChain(value, excluded)) {
      const targetClass2 = extractClassName(proto);
      const factory = this.factories.get(targetClass2);
      if (factory) {
        return {
          targetClass: targetClass2,
          factory,
          isSelfRef: false
        };
      }
    }
    throw new SerializerError(`Class "${targetClass}" was not found!`);
  }
  static hasFactory(clsName) {
    return Serializer.factories.has(clsName);
  }
  static serialize(rawData) {
    const output = Serializer._createOutputBuilder();
    const getRefId = /* @__PURE__ */ (() => {
      let id = 0;
      return () => {
        id += 1;
        return id;
      };
    })();
    const seen = new SafeWeakMap();
    const assertValidSnapshot = /* @__PURE__ */ (() => {
      const allowedTypes = /* @__PURE__ */ new Set([
        "Number",
        "String",
        "Object",
        "Array",
        "Undefined",
        "Null",
        "Boolean"
      ]);
      return (snapshot, factory) => {
        const className = extractClassName(snapshot);
        if (!allowedTypes.has(className)) {
          throw new SerializerError(`Cannot serialize '${className}' as a top level property. "toPlain" function in "${extractClassName(factory.ref)}" should return an ${Array.from(allowedTypes.values()).join(",")}.`);
        }
      };
    })();
    const toSerializable = /* @__PURE__ */ __name((rawValue) => {
      if (seen.has(rawValue)) {
        return seen.get(rawValue);
      }
      if (rawValue instanceof Serializable && !this.hasFactory(extractClassName(rawValue))) {
        const Class = rawValue.constructor;
        Serializer.registerSerializable(Class);
      }
      const { targetClass, factory, isSelfRef } = Serializer.findFactory(rawValue);
      if (!isSerializationRequired(factory.ref)) {
        return rawValue;
      }
      const snapshot = isSelfRef ? SerializerSelfRefIdentifier : factory.toPlain(rawValue);
      assertValidSnapshot(snapshot, factory);
      const result = {
        __serializer: true,
        __class: targetClass,
        __ref: getRefId().toString(),
        __value: snapshot
      };
      seen.set(rawValue, result);
      for (const node of traverseWithUpdate(snapshot)) {
        const newValue = toSerializable(node.value);
        if (newValue !== node.value) {
          node.update(newValue);
        }
      }
      return result;
    }, "toSerializable");
    const root = {
      __version: Version,
      __root: rawData
    };
    traverseObject(root, ({ value, path }) => {
      const content = toSerializable(value);
      output.update(path, content);
    });
    return output.toJSON();
  }
  /** @internal */
  static deserializeWithMeta(raw, extraClasses) {
    extraClasses?.forEach((ref) => Serializer.registerSerializable(ref));
    const output = Serializer._createOutputBuilder();
    const instances = /* @__PURE__ */ new Map();
    const toDeserialize = /* @__PURE__ */ __name((contentRaw) => {
      if (isSerializerNode(contentRaw)) {
        const clsName = String(contentRaw.__class);
        const factory = Serializer.getFactory(clsName);
        const rawData = contentRaw.__value;
        if (rawData === SerializerSelfRefIdentifier) {
          return factory.ref;
        }
        if (rawData === SerializerRefIdentifier) {
          if (!instances.has(contentRaw.__ref)) {
            throw new SerializerError(`Missing reference "${contentRaw.__ref}"!`);
          }
          const data = instances.get(contentRaw.__ref);
          if (data instanceof RefPlaceholder) {
            return data.value;
          }
          return data;
        }
        const traverseNested = /* @__PURE__ */ __name(() => {
          for (const node of traverseWithUpdate(rawData)) {
            const newValue = toDeserialize(node.value);
            if (newValue !== node.value) {
              node.update(newValue);
            }
          }
        }, "traverseNested");
        const placeholder = new RefPlaceholder(contentRaw, factory);
        instances.set(contentRaw.__ref, placeholder);
        traverseNested();
        instances.set(contentRaw.__ref, placeholder.final);
        return placeholder.final;
      }
      return contentRaw;
    }, "toDeserialize");
    const root = JSON.parse(raw);
    if (!isRootNode(root)) {
      throw new SerializerError("Provided data cannot be deserialized due to malformed format!");
    }
    traverseObject(root, ({ value: contentRaw, path }) => {
      output.update(path, toDeserialize(contentRaw));
    }, (_obj) => isSerializerNode(_obj));
    return output.get();
  }
  static deserialize(raw, extraClasses) {
    const response = Serializer.deserializeWithMeta(raw, extraClasses);
    return response.__root;
  }
  static _createOutputBuilder() {
    return {
      _container: {},
      get() {
        return this._container;
      },
      update(path, value) {
        setProp(this._container, path, value);
      },
      toJSON() {
        const seen = new SafeWeakSet();
        return JSON.stringify(this._container, (key, value) => {
          if (seen.has(value) && isSerializerNode(value)) {
            const updated = {
              ...value,
              __value: SerializerRefIdentifier
            };
            return updated;
          }
          seen.add(value);
          return value;
        });
      }
    };
  }
}
Serializer.register(Task, {
  toPlain: /* @__PURE__ */ __name((task) => ({
    value: task.resolvedValue(),
    state: task.state
  }), "toPlain"),
  fromPlain: /* @__PURE__ */ __name(({ state, value }) => {
    const task = new Task();
    if (state === TaskState.RESOLVED) {
      task.resolve(value);
    } else if (state === TaskState.REJECTED) {
      task.reject(value);
    } else {
      task.reject(new SerializerError("Task cannot be solved due to serialization."));
    }
    task.resolve(value);
    return task;
  }, "fromPlain"),
  createEmpty: /* @__PURE__ */ __name(() => new Task(), "createEmpty"),
  updateInstance: /* @__PURE__ */ __name((instance, value) => {
    instance.resolve(value);
  }, "updateInstance")
});
Serializer.register(SlidingTaskMap, {
  toPlain: /* @__PURE__ */ __name((value) => ({
    config: {
      windowSize: value.windowSize,
      ttl: value.ttl
    },
    entries: Array.from(value.entries()).filter(([_, task]) => {
      if (task instanceof Task) {
        return task.state === TaskState.RESOLVED;
      }
      return true;
    })
  }), "toPlain"),
  fromPlain: /* @__PURE__ */ __name(({ entries, config }) => {
    const instance = new SlidingTaskMap(config.windowSize, config.ttl);
    for (const [key, value] of entries) {
      instance.set(key, value);
    }
    return instance;
  }, "fromPlain"),
  createEmpty: /* @__PURE__ */ __name(() => new SlidingTaskMap(1, 1e3), "createEmpty"),
  updateInstance: /* @__PURE__ */ __name((instance, newInstance) => {
    Object.assign(instance, {
      windowSize: newInstance.windowSize,
      ttl: newInstance.ttl
    });
    newInstance.forEach((value, key) => instance.set(key, value));
  }, "updateInstance")
});
Serializer.register(Map, {
  toPlain: /* @__PURE__ */ __name((value) => Array.from(value.entries()), "toPlain"),
  fromPlain: /* @__PURE__ */ __name((value) => new Map(value), "fromPlain"),
  createEmpty: /* @__PURE__ */ __name(() => /* @__PURE__ */ new Map(), "createEmpty"),
  updateInstance: /* @__PURE__ */ __name((instance, update) => {
    update.forEach(([key, value]) => instance.set(key, value));
  }, "updateInstance")
});
Serializer.register(Set, {
  toPlain: /* @__PURE__ */ __name((value) => Array.from(value.values()), "toPlain"),
  fromPlain: /* @__PURE__ */ __name((value) => new Set(value), "fromPlain"),
  createEmpty: /* @__PURE__ */ __name(() => /* @__PURE__ */ new Set(), "createEmpty"),
  updateInstance: /* @__PURE__ */ __name((instance, update) => {
    update.forEach((value) => instance.add(value));
  }, "updateInstance")
});
Serializer.register(Array, {
  toPlain: /* @__PURE__ */ __name((value) => value.slice(), "toPlain"),
  fromPlain: /* @__PURE__ */ __name((value) => value.slice(), "fromPlain"),
  createEmpty: /* @__PURE__ */ __name(() => [], "createEmpty"),
  updateInstance: /* @__PURE__ */ __name((value, update) => {
    value.push(...update);
  }, "updateInstance")
});
Serializer.register(Object, {
  toPlain: /* @__PURE__ */ __name((value) => Object.assign({}, value), "toPlain"),
  fromPlain: /* @__PURE__ */ __name((value) => Object.assign({}, value), "fromPlain"),
  createEmpty: /* @__PURE__ */ __name(() => ({}), "createEmpty"),
  updateInstance: /* @__PURE__ */ __name((value, update) => Object.assign(value, update), "updateInstance")
});
Serializer.register(Number, {
  toPlain: /* @__PURE__ */ __name((value) => Number(value).toString(), "toPlain"),
  fromPlain: /* @__PURE__ */ __name((value) => Number(value), "fromPlain")
});
Serializer.register(String, {
  toPlain: /* @__PURE__ */ __name((value) => String(value), "toPlain"),
  fromPlain: /* @__PURE__ */ __name((value) => String(value), "fromPlain")
});
Serializer.register(Boolean, {
  toPlain: /* @__PURE__ */ __name((value) => Boolean(value), "toPlain"),
  fromPlain: /* @__PURE__ */ __name((value) => Boolean(value), "fromPlain")
});
Serializer.register(BigInt, {
  toPlain: /* @__PURE__ */ __name((value) => String(value), "toPlain"),
  fromPlain: /* @__PURE__ */ __name((value) => BigInt(value), "fromPlain")
});
Serializer.register(Symbol, {
  toPlain: /* @__PURE__ */ __name((value) => value.description, "toPlain"),
  fromPlain: /* @__PURE__ */ __name((value) => Symbol(value), "fromPlain")
});
Serializer.register(Date, {
  toPlain: /* @__PURE__ */ __name((value) => value.toISOString(), "toPlain"),
  fromPlain: /* @__PURE__ */ __name((value) => new Date(value), "fromPlain")
});
Serializer.register(CacheFn, {
  toPlain: /* @__PURE__ */ __name((value) => value.createSnapshot(), "toPlain"),
  fromPlain: /* @__PURE__ */ __name((value) => CacheFn.create(value.fn, value.options), "fromPlain")
});
Serializer.register(Function, {
  toPlain: /* @__PURE__ */ __name((value) => {
    const isNative = getProp(global, [
      value.name
    ]) === value;
    function isConstructor(obj) {
      return obj && !!obj.prototype && !!obj.prototype.constructor.name;
    }
    __name(isConstructor, "isConstructor");
    return {
      name: value.name,
      binds: getFunctionBinds(value).map((bound) => ({
        name: isConstructor(bound) ? Serializer.findFactory(bound).targetClass : bound.name,
        value: "value" in bound ? bound.value : null
      })),
      fn: isNative ? "" : String(value),
      isNative
    };
  }, "toPlain"),
  fromPlain: /* @__PURE__ */ __name((value) => {
    if (value.isNative) {
      return getProp(global, [
        value.name
      ]);
    }
    const toParsableForm = /* @__PURE__ */ __name(() => {
      let fn2 = value.fn;
      if (fn2.match(/^\s*function.*?\(/)) {
        return fn2;
      }
      const [a, b, c] = [
        fn2.indexOf("=>"),
        fn2.indexOf("("),
        fn2.indexOf("{")
      ];
      if (a > -1) {
        if (b === -1 || b > a || c === -1 && c > a) {
          const [p, p2] = halveString(fn2, "=>", false);
          fn2 = `(${p.replace("async", "").replace("*", "").trim()})=>${p2}`;
          fn2 = [
            p.includes("async") && "async ",
            p.includes("*") && "*",
            fn2
          ].filter(Boolean).join(" ");
        }
      }
      const arrowStart = fn2.indexOf("=>");
      const bracketStart = fn2.indexOf("(");
      const [fnPrefix, fnContent = ""] = bracketStart === -1 || bracketStart > arrowStart ? halveString(fn2, "{", true) : halveString(fn2, "(", true);
      const nonReservedSymbols = fnPrefix.trim().split(" ").map((x) => x.trim()).filter(Boolean).every((content) => [
        "async",
        "*"
      ].includes(content));
      if (nonReservedSymbols) {
        return fn2;
      }
      const name = value.name && fnPrefix.includes(value.name) ? value.name : "";
      let parameters = "";
      if (!fnContent.startsWith("(")) {
        if (fnPrefix.includes("(")) {
          parameters = (fnPrefix.match(/\((.+)\)/) ?? [
            null,
            ""
          ])[1];
        } else {
          parameters = fnPrefix.replace("=>", "").replace("async", "").replace("*", "");
        }
      }
      return [
        fnPrefix.includes("async") && "async ",
        "function",
        fnPrefix.includes("*") && "*",
        name && ` ${name}`,
        parameters && `(${parameters})`,
        fnContent
      ].filter(Boolean).join("");
    }, "toParsableForm");
    const binds = value?.binds ?? [];
    const fn = Function(...binds.map((b) => b.name), `return ${toParsableForm()}`)(...binds.map((b) => b.value ? b.value : Serializer.getFactory(b.name).ref));
    if (value.name) {
      Object.defineProperty(fn, "name", Object.assign({}, Object.getOwnPropertyDescriptor(Object.getPrototypeOf(fn), "name"), {
        value: value.name
      }));
    }
    Object.defineProperty(fn, "toString", Object.assign({}, Object.getOwnPropertyDescriptor(Object.getPrototypeOf(fn), "name"), {
      value: /* @__PURE__ */ __name(() => value.fn, "value")
    }));
    return hasMinLength(binds, 1) ? toBoundedFunction(fn, binds) : fn;
  }, "fromPlain")
});
Serializer.register(Error, {
  toPlain: /* @__PURE__ */ __name((value) => serializeError(value), "toPlain"),
  fromPlain: /* @__PURE__ */ __name((value) => deserializeError(value), "fromPlain")
});
Serializer.register(RegExp, {
  toPlain: /* @__PURE__ */ __name((value) => ({
    source: value.source,
    flags: value.flags
  }), "toPlain"),
  fromPlain: /* @__PURE__ */ __name((value) => new RegExp(value.source, value.flags), "fromPlain")
});
Serializer.register(WeakSet, {
  toPlain: /* @__PURE__ */ __name(() => {
  }, "toPlain"),
  fromPlain: /* @__PURE__ */ __name(() => /* @__PURE__ */ new WeakSet(), "fromPlain"),
  createEmpty: /* @__PURE__ */ __name(() => /* @__PURE__ */ new WeakSet(), "createEmpty"),
  updateInstance: /* @__PURE__ */ __name(() => {
  }, "updateInstance")
});
Serializer.register(WeakMap, {
  toPlain: /* @__PURE__ */ __name(() => {
  }, "toPlain"),
  fromPlain: /* @__PURE__ */ __name(() => /* @__PURE__ */ new WeakMap(), "fromPlain"),
  createEmpty: /* @__PURE__ */ __name(() => /* @__PURE__ */ new WeakMap(), "createEmpty"),
  updateInstance: /* @__PURE__ */ __name(() => {
  }, "updateInstance")
});
Serializer.register(WeakRef, {
  toPlain: /* @__PURE__ */ __name(() => {
  }, "toPlain"),
  fromPlain: /* @__PURE__ */ __name(() => new WeakRef({}), "fromPlain")
});
Serializer.register(primitiveToSerializableClass(void 0), {
  toPlain: /* @__PURE__ */ __name(() => void 0, "toPlain"),
  fromPlain: /* @__PURE__ */ __name(() => void 0, "fromPlain")
});
Serializer.register(primitiveToSerializableClass(null), {
  toPlain: /* @__PURE__ */ __name(() => null, "toPlain"),
  fromPlain: /* @__PURE__ */ __name(() => null, "fromPlain")
});
Serializer.register(ZodType, {
  toPlain: /* @__PURE__ */ __name((value) => toJsonSchema(value), "toPlain"),
  fromPlain: /* @__PURE__ */ __name(() => {
    throw new Error("JSONSchema cannot be converted to zod!");
  }, "fromPlain")
});
Serializer.register(Buffer, {
  toPlain: /* @__PURE__ */ __name((value) => value.toString("base64"), "toPlain"),
  fromPlain: /* @__PURE__ */ __name((data) => Buffer.from(data, "base64"), "fromPlain")
});
Serializer.register(AbortSignal, {
  toPlain: /* @__PURE__ */ __name((value) => ({
    aborted: value.aborted,
    reason: value.reason
  }), "toPlain"),
  fromPlain: /* @__PURE__ */ __name((data) => {
    const controller = createAbortController();
    if (data.aborted) {
      controller.abort(data.reason);
    }
    return controller.signal;
  }, "fromPlain")
});
Serializer.register(AbortController, {
  toPlain: /* @__PURE__ */ __name((value) => ({
    signal: value.signal
  }), "toPlain"),
  fromPlain: /* @__PURE__ */ __name((data) => createAbortController(data.signal), "fromPlain")
});

export { Serializer };
//# sourceMappingURL=serializer.js.map
//# sourceMappingURL=serializer.js.map