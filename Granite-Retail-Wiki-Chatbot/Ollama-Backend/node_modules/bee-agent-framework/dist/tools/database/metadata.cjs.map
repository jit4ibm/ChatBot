{"version":3,"sources":["../../../src/tools/database/metadata.ts"],"names":["getMetadata","sequelize","provider","schema","query","getMetadataQuery","metadata","tableMap","Map","forEach","tableName","columnName","dataType","has","set","get","push","Array","from","values","map","columns","join","error","ToolError","isRetryable","schemaName","getDefaultSchema","isFatal"],"mappings":";;;;;;AA2BA,eAAsBA,WAAAA,CACpBC,SACAC,EAAAA,QAAAA,EACAC,MAAe,EAAA;AAEf,EAAI,IAAA;AACF,IAAMC,MAAAA,KAAAA,GAAQC,gBAAiBH,CAAAA,QAAAA,EAAUC,MAAAA,CAAAA;AAEzC,IAAA,MAAM,CAACG,QAAAA,CAAAA,GAAa,MAAML,SAAAA,CAAUG,MAAMA,KAAAA,CAAAA;AAE1C,IAAMG,MAAAA,QAAAA,uBAAeC,GAAAA,EAAAA;AAErBF,IAAAA,QAAAA,CAASG,QAAQ,CAAC,EAAEC,SAAWC,EAAAA,UAAAA,EAAYC,UAAU,KAAA;AACnD,MAAA,IAAI,CAACL,QAAAA,CAASM,GAAIH,CAAAA,SAAAA,CAAY,EAAA;AAC5BH,QAAAA,QAAAA,CAASO,IAAIJ,SAAW,EAAA;AAAC,UAAA,CAAA,OAAA,EAAUA,SAAAA,CAAAA,gBAAAA,EAA4BC,UAAAA,CAAAA,EAAAA,EAAeC,QAAAA,CAAAA,CAAAA;AAAY,SAAA,CAAA;OACrF,MAAA;AACLL,QAASQ,QAAAA,CAAAA,GAAAA,CAAIL,SAAAA,CAAYM,CAAAA,IAAAA,CAAK,GAAGL,UAAAA,CAAAA,EAAAA,EAAeC,QAAAA,CAAW,CAAA,CAAA,CAAA;AAC7D;KACF,CAAA;AAEA,IAAA,OAAOK,KAAMC,CAAAA,IAAAA,CAAKX,QAASY,CAAAA,MAAAA,EAAM,CAC9BC,CAAAA,GAAAA,CAAI,CAACC,OAAAA,KAAYA,QAAQC,IAAK,CAAA,IAAA,CAAA,CAAA,CAC9BA,KAAK,IAAA,CAAA;AACV,GAAA,CAAA,OAASC,KAAO,EAAA;AACd,IAAA,MAAM,IAAIC,kBAAU,CAAA,CAAA,6BAAA,EAAgCD,KAAAA,CAAAA,CAAAA,EAAS,EAAI,EAAA;MAC/DE,WAAa,EAAA;KACf,CAAA;AACF;AACF;AA5BsBzB,MAAAA,CAAAA,WAAAA,EAAAA,aAAAA,CAAAA;AA8BtB,SAASK,gBAAAA,CAAiBH,UAAoBC,MAAe,EAAA;AAC3D,EAAMuB,MAAAA,UAAAA,GAAavB,MAAUwB,IAAAA,gBAAAA,CAAiBzB,QAAAA,CAAAA;AAE9C,EAAA,QAAQA,QAAAA;IACN,KAAK,OAAA;IACL,KAAK,SAAA;AACH,MAAO,OAAA;;;;;;;IAQT,KAAK,UAAA;AACH,MAAO,OAAA;;;;;0CAK6BwB,UAAAA,CAAAA;;IAGtC,KAAK,OAAA;AACH,MAAO,OAAA;;;;;;;;sCAQyBA,UAAAA,CAAAA;;IAGlC,KAAK,KAAA;AACH,MAAO,OAAA;;;;;uCAK0BA,UAAAA,CAAAA;;IAGnC,KAAK,QAAA;AACH,MAAO,OAAA;;;;;;;;;IAUT,KAAK,QAAA;AACH,MAAO,OAAA;;;;;mCAKsBA,UAAAA,CAAAA;;AAG/B,IAAA;AACE,MAAA,MAAM,IAAIF,kBAAU,CAAA,CAAA,SAAA,EAAYtB,QAAAA,CAAAA,iBAAAA,CAAAA,EAA6B,EAAI,EAAA;QAC/D0B,OAAS,EAAA,IAAA;QACTH,WAAa,EAAA;OACf,CAAA;AACJ;AACF;AAtESpB,MAAAA,CAAAA,gBAAAA,EAAAA,kBAAAA,CAAAA;AAwET,SAASsB,iBAAiBzB,QAAkB,EAAA;AAC1C,EAAA,QAAQA,QAAAA;IACN,KAAK,UAAA;AACH,MAAO,OAAA,QAAA;IACT,KAAK,OAAA;AACH,MAAO,OAAA,KAAA;IACT,KAAK,KAAA;IACL,KAAK,QAAA;AACH,MAAA,MAAM,IAAIsB,kBAAU,CAAA,CAAA,4BAAA,EAA+BtB,QAAAA,CAAAA,CAAAA,EAAY,EAAI,EAAA;QACjEuB,WAAa,EAAA,KAAA;QACbG,OAAS,EAAA;OACX,CAAA;AACF,IAAA;AACE,MAAO,OAAA,EAAA;AACX;AACF;AAfSD,MAAAA,CAAAA,gBAAAA,EAAAA,kBAAAA,CAAAA","file":"metadata.cjs","sourcesContent":["/**\n * Copyright 2024 IBM Corp.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ToolError } from \"@/tools/base.js\";\nimport { Sequelize } from \"sequelize\";\n\nexport type Provider = \"mysql\" | \"mariadb\" | \"postgres\" | \"mssql\" | \"db2\" | \"sqlite\" | \"oracle\";\n\nexport interface Metadata {\n  tableName: string;\n  columnName: string;\n  dataType: string;\n}\n\nexport async function getMetadata(\n  sequelize: Sequelize,\n  provider: Provider,\n  schema?: string,\n): Promise<string> {\n  try {\n    const query = getMetadataQuery(provider, schema);\n\n    const [metadata] = (await sequelize.query(query)) as [Metadata[], any];\n\n    const tableMap = new Map<string, string[]>();\n\n    metadata.forEach(({ tableName, columnName, dataType }) => {\n      if (!tableMap.has(tableName)) {\n        tableMap.set(tableName, [`Table '${tableName}' with columns: ${columnName} (${dataType})`]);\n      } else {\n        tableMap.get(tableName)!.push(`${columnName} (${dataType})`);\n      }\n    });\n\n    return Array.from(tableMap.values())\n      .map((columns) => columns.join(\", \"))\n      .join(\"; \");\n  } catch (error) {\n    throw new ToolError(`Error initializing metadata: ${error}`, [], {\n      isRetryable: false,\n    });\n  }\n}\n\nfunction getMetadataQuery(provider: Provider, schema?: string): string {\n  const schemaName = schema ?? getDefaultSchema(provider);\n\n  switch (provider) {\n    case \"mysql\":\n    case \"mariadb\":\n      return `\n          SELECT t.table_name AS tableName, c.column_name AS columnName, \n                 c.data_type AS dataType\n          FROM information_schema.tables t\n          JOIN information_schema.columns c ON t.table_name = c.table_name\n          WHERE t.table_schema = DATABASE();\n        `;\n\n    case \"postgres\":\n      return `\n          SELECT t.table_name AS \"tableName\", c.column_name AS \"columnName\", \n                 c.data_type AS \"dataType\"\n          FROM information_schema.tables t\n          JOIN information_schema.columns c ON t.table_name = c.table_name\n          WHERE t.table_schema = lower('${schemaName}');\n        `;\n\n    case \"mssql\":\n      return `\n          SELECT t.name AS tableName, c.name AS columnName,\n                 ty.name AS dataType\n           FROM sys.tables t\n           JOIN sys.columns c ON t.object_id = c.object_id\n           JOIN sys.types ty ON c.user_type_id = ty.user_type_id\n           JOIN sys.schemas s ON t.schema_id = s.schema_id\n           WHERE t.is_ms_shipped = 0 AND t.type = 'U'\n                AND s.name = lower('${schemaName}');\n        `;\n\n    case \"db2\":\n      return `\n          SELECT t.tabname AS \"tableName\", c.colname AS \"columnName\", \n                 c.typename AS \"dataType\"\n          FROM SYSCAT.TABLES t\n          JOIN SYSCAT.COLUMNS c ON t.tabname = c.tabname\n          WHERE t.tabschema = upper('${schemaName}');\n        `;\n\n    case \"sqlite\":\n      return `\n          SELECT tbl_name AS \"tableName\", name AS \"columnName\", type AS \"dataType\"\n            FROM (\n                SELECT name AS tbl_name\n                FROM sqlite_master\n                WHERE type = 'table'\n            )\n            JOIN pragma_table_xinfo(tbl_name);\n        `;\n\n    case \"oracle\":\n      return `\n          SELECT t.table_name AS \"tableName\", c.column_name AS \"columnName\", \n                 c.data_type AS \"dataType\"\n          FROM all_tables t\n          JOIN all_tab_columns c ON t.table_name = c.table_name\n          WHERE t.owner = upper('${schemaName}');\n        `;\n\n    default:\n      throw new ToolError(`Provider ${provider} is not supported`, [], {\n        isFatal: true,\n        isRetryable: false,\n      });\n  }\n}\n\nfunction getDefaultSchema(provider: Provider): string {\n  switch (provider) {\n    case \"postgres\":\n      return \"public\";\n    case \"mssql\":\n      return \"dbo\";\n    case \"db2\":\n    case \"oracle\":\n      throw new ToolError(`Schema name is required for ${provider}`, [], {\n        isRetryable: false,\n        isFatal: true,\n      });\n    default:\n      return \"\";\n  }\n}\n"]}