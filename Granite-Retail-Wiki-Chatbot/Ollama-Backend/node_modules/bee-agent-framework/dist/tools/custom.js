import { Tool, StringToolOutput } from './base.js';
import { createGrpcTransport } from '@connectrpc/connect-node';
import { createPromiseClient } from '@connectrpc/connect';
import { FrameworkError } from '../errors.js';
import { z } from 'zod';
import { validate } from '../internals/helpers/general.js';
import { CodeInterpreterService } from 'bee-proto/code_interpreter/v1/code_interpreter_service_connect';
import { Emitter } from '../emitter/emitter.js';

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
class CustomToolCreateError extends FrameworkError {
  static {
    __name(this, "CustomToolCreateError");
  }
}
class CustomToolExecuteError extends FrameworkError {
  static {
    __name(this, "CustomToolExecuteError");
  }
}
const toolOptionsSchema = z.object({
  codeInterpreter: z.object({
    url: z.string().url(),
    connectionOptions: z.any().optional()
  }),
  sourceCode: z.string().min(1),
  name: z.string().min(1),
  description: z.string().min(1),
  inputSchema: z.any(),
  executorId: z.string().nullable().optional()
}).passthrough();
function createCodeInterpreterClient(codeInterpreter) {
  return createPromiseClient(CodeInterpreterService, createGrpcTransport({
    baseUrl: codeInterpreter.url,
    httpVersion: "2",
    nodeOptions: codeInterpreter.connectionOptions
  }));
}
__name(createCodeInterpreterClient, "createCodeInterpreterClient");
class CustomTool extends Tool {
  static {
    __name(this, "CustomTool");
  }
  name;
  description;
  emitter = Emitter.root.child({
    namespace: [
      "tool",
      "custom"
    ],
    creator: this
  });
  inputSchema() {
    return this.options.inputSchema;
  }
  client;
  static {
    this.register();
  }
  constructor(options, client) {
    validate(options, toolOptionsSchema);
    super(options);
    this.client = client || createCodeInterpreterClient(options.codeInterpreter);
    this.name = options.name;
    this.description = options.description;
  }
  async _run(input, _options, run) {
    const { response } = await this.client.executeCustomTool({
      executorId: this.options.executorId || "default",
      toolSourceCode: this.options.sourceCode,
      toolInputJson: JSON.stringify(input)
    }, {
      signal: run.signal
    });
    if (response.case === "error") {
      throw new CustomToolExecuteError(response.value.stderr);
    }
    return new StringToolOutput(response.value.toolOutputJson);
  }
  loadSnapshot(snapshot) {
    super.loadSnapshot(snapshot);
    this.client = createCodeInterpreterClient(this.options.codeInterpreter);
  }
  static async fromSourceCode(codeInterpreter, sourceCode, executorId) {
    const client = createCodeInterpreterClient(codeInterpreter);
    const response = await client.parseCustomTool({
      toolSourceCode: sourceCode
    });
    if (response.response.case === "error") {
      throw new CustomToolCreateError(response.response.value.errorMessages.join("\n"));
    }
    const { toolName, toolDescription, toolInputSchemaJson } = response.response.value;
    return new CustomTool({
      codeInterpreter,
      sourceCode,
      name: toolName,
      description: toolDescription,
      inputSchema: JSON.parse(toolInputSchemaJson),
      executorId
    }, client);
  }
}

export { CustomTool, CustomToolCreateError, CustomToolExecuteError };
//# sourceMappingURL=custom.js.map
//# sourceMappingURL=custom.js.map