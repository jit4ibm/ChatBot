{"version":3,"sources":["../../../src/tools/weather/openMeteo.ts"],"names":["OpenMeteoToolOutput","JSONToolOutput","OpenMeteoTool","Tool","name","description","inputSchema","z","object","location","union","string","min","country","optional","language","default","strip","latitude","coerce","number","longitude","start_date","date","describe","end_date","temperature_unit","enum","emitter","Emitter","root","child","namespace","creator","register","options","responseFilter","excludedKeys","preprocessInput","rawInput","fixDate","key","value","getProp","setProp","substring","_run","startDate","endDate","input","_options","run","apiKey","prepareParams","extractLocation","response","_geocode","signal","pick","validateAndSetDates","startDateStr","endDateStr","now","Date","start","UTC","getFullYear","getMonth","getDate","end","ToolInputValidationError","toDateString","toISOString","split","createURLParams","pickBy","v","isNullish","current","daily","hourly","timezone","params","fetch","headers","Authorization","ok","ToolError","Error","text","data","json","omit","format","count","results","length"],"mappings":"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","file":"openMeteo.js","sourcesContent":["/**\n * Copyright 2024 IBM Corp.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  BaseToolOptions,\n  BaseToolRunOptions,\n  ToolEmitter,\n  JSONToolOutput,\n  Tool,\n  ToolError,\n  ToolInput,\n  ToolInputValidationError,\n} from \"@/tools/base.js\";\nimport { z } from \"zod\";\nimport { createURLParams } from \"@/internals/fetcher.js\";\nimport { isNullish, omit, pick, pickBy } from \"remeda\";\nimport { Cache } from \"@/cache/decoratorCache.js\";\nimport { RunContext } from \"@/context.js\";\nimport { getProp, setProp } from \"@/internals/helpers/object.js\";\nimport { Emitter } from \"@/emitter/emitter.js\";\n\nexport interface ResponseFilter {\n  excludedKeys: (keyof OpenMeteoToolResponse)[];\n}\n\ninterface ToolOptions extends BaseToolOptions {\n  apiKey?: string;\n  responseFilter?: ResponseFilter;\n}\n\ntype ToolRunOptions = BaseToolRunOptions;\n\ninterface Location {\n  latitude: number;\n  longitude: number;\n}\n\ninterface LocationSearch {\n  name: string;\n  country?: string;\n  language?: string;\n}\n\nexport interface OpenMeteoToolResponse {\n  latitude?: number;\n  longitude?: number;\n  generationtime_ms?: number;\n  utc_offset_seconds?: number;\n  timezone?: string;\n  timezone_abbreviation?: string;\n  elevation?: number;\n  current_units?: Record<string, string>;\n  current?: Record<string, string>;\n  hourly_units?: Record<string, string>;\n  hourly?: Record<string, any[]>;\n  daily_units?: Record<string, string>;\n  daily?: Record<string, any[]>;\n}\n\nexport class OpenMeteoToolOutput extends JSONToolOutput<OpenMeteoToolResponse> {}\n\nexport class OpenMeteoTool extends Tool<OpenMeteoToolOutput, ToolOptions, ToolRunOptions> {\n  name = \"OpenMeteo\";\n  description = `Retrieve current, past, or future weather forecasts for a location.`;\n\n  inputSchema() {\n    return z\n      .object({\n        location: z.union([\n          z\n            .object({\n              name: z.string().min(1),\n              country: z.string().optional(),\n              language: z.string().default(\"English\"),\n            })\n            .strip(),\n          z\n            .object({\n              latitude: z.coerce.number(),\n              longitude: z.coerce.number(),\n            })\n            .strip(),\n        ]),\n        start_date: z\n          .string()\n          .date()\n          .describe(\"Start date for the weather forecast in the format YYYY-MM-DD (UTC)\"),\n        end_date: z\n          .string()\n          .date()\n          .describe(\"End date for the weather forecast in the format YYYY-MM-DD (UTC)\")\n          .optional(),\n        temperature_unit: z.enum([\"celsius\", \"fahrenheit\"]).default(\"celsius\"),\n      })\n      .strip();\n  }\n\n  public readonly emitter: ToolEmitter<ToolInput<this>, OpenMeteoToolOutput> = Emitter.root.child({\n    namespace: [\"tool\", \"weather\", \"openMeteo\"],\n    creator: this,\n  });\n\n  static {\n    this.register();\n  }\n\n  public constructor(options: Partial<ToolOptions> = {}) {\n    super({\n      ...options,\n      responseFilter: options?.responseFilter ?? {\n        excludedKeys: [\n          \"latitude\",\n          \"longitude\",\n          \"generationtime_ms\",\n          \"utc_offset_seconds\",\n          \"timezone\",\n          \"timezone_abbreviation\",\n          \"elevation\",\n          \"hourly\",\n          \"hourly_units\",\n        ],\n      },\n    });\n  }\n\n  protected preprocessInput(rawInput: unknown) {\n    super.preprocessInput(rawInput);\n\n    const fixDate = (key: keyof ToolInput<this>) => {\n      const value = getProp(rawInput, [key]);\n      if (value) {\n        setProp(rawInput, [key], value.substring(0, 10));\n      }\n    };\n\n    fixDate(\"start_date\");\n    fixDate(\"end_date\");\n  }\n\n  protected async _run(\n    { location, start_date: startDate, end_date: endDate, ...input }: ToolInput<this>,\n    _options: Partial<BaseToolRunOptions>,\n    run: RunContext<this>,\n  ) {\n    const { apiKey } = this.options;\n\n    const prepareParams = async () => {\n      const extractLocation = async (): Promise<Location> => {\n        if (\"name\" in location) {\n          const response = await this._geocode(location, run.signal);\n          return pick(response, [\"latitude\", \"longitude\"]);\n        }\n        return location;\n      };\n\n      function validateAndSetDates(\n        startDateStr: string,\n        endDateStr?: string,\n      ): { start: Date; end: Date } {\n        const now = new Date();\n        const start = startDateStr\n          ? new Date(startDateStr)\n          : new Date(Date.UTC(now.getFullYear(), now.getMonth(), now.getDate()));\n\n        if (endDateStr) {\n          const end = new Date(endDateStr);\n          if (end < start) {\n            throw new ToolInputValidationError(\n              `The 'end_date' (${endDateStr}) has to occur on or after the 'start_date' (${startDateStr}).`,\n            );\n          }\n          return { start: start, end: end };\n        } else {\n          // If endDate is undefined, set it to the start date\n          return { start: start, end: new Date(start) };\n        }\n      }\n\n      const { start, end } = validateAndSetDates(startDate, endDate);\n\n      const toDateString = (date: Date) => date.toISOString().split(\"T\")[0];\n\n      return createURLParams({\n        ...pickBy(input, (v) => !isNullish(v) && v !== \"\"),\n        ...(await extractLocation()),\n        start_date: toDateString(start),\n        end_date: toDateString(end),\n        current: [\"temperature_2m\", \"rain\", \"relative_humidity_2m\", \"wind_speed_10m\"],\n        daily: [\"temperature_2m_max\", \"temperature_2m_min\", \"rain_sum\"],\n        hourly: [\"temperature_2m\", \"relative_humidity_2m\", \"rain\"],\n        timezone: \"UTC\",\n      });\n    };\n\n    const params = await prepareParams();\n    const response = await fetch(`https://api.open-meteo.com/v1/forecast?${params}`, {\n      headers: {\n        ...(apiKey && {\n          Authorization: `Bearer ${apiKey}`,\n        }),\n      },\n      signal: run.signal,\n    });\n\n    if (!response.ok) {\n      throw new ToolError(\"Request to OpenMeteo API has failed!\", [\n        new Error(await response.text()),\n      ]);\n    }\n\n    let data: OpenMeteoToolResponse = await response.json();\n\n    if (this.options?.responseFilter?.excludedKeys) {\n      data = omit(data, this.options.responseFilter.excludedKeys);\n    }\n\n    return new OpenMeteoToolOutput(data);\n  }\n\n  @Cache()\n  protected async _geocode(location: LocationSearch, signal: AbortSignal) {\n    const { apiKey } = this.options;\n\n    const params = createURLParams({\n      name: location.name,\n      language: location.language,\n      country: location.country,\n      format: \"json\",\n      count: 1,\n    });\n    const response = await fetch(`https://geocoding-api.open-meteo.com/v1/search?${params}`, {\n      headers: {\n        ...(apiKey && {\n          Authorization: `Bearer ${apiKey}`,\n        }),\n      },\n      signal,\n    });\n    if (!response.ok) {\n      throw new ToolError(`Failed to GeoCode provided location (${location.name}).`, [\n        new Error(await response.text()),\n      ]);\n    }\n\n    const { results } = await response.json();\n    if (!results || results.length === 0) {\n      throw new ToolError(`Location '${location.name}' was not found.`);\n    }\n    return results[0];\n  }\n}\n"]}