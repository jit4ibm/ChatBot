'use strict';

var base_cjs = require('./base.cjs');
var connectNode = require('@connectrpc/connect-node');
var connect = require('@connectrpc/connect');
var errors_cjs = require('../errors.cjs');
var zod = require('zod');
var general_cjs = require('../internals/helpers/general.cjs');
var code_interpreter_service_connect = require('bee-proto/code_interpreter/v1/code_interpreter_service_connect');
var emitter_cjs = require('../emitter/emitter.cjs');

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
class CustomToolCreateError extends errors_cjs.FrameworkError {
  static {
    __name(this, "CustomToolCreateError");
  }
}
class CustomToolExecuteError extends errors_cjs.FrameworkError {
  static {
    __name(this, "CustomToolExecuteError");
  }
}
const toolOptionsSchema = zod.z.object({
  codeInterpreter: zod.z.object({
    url: zod.z.string().url(),
    connectionOptions: zod.z.any().optional()
  }),
  sourceCode: zod.z.string().min(1),
  name: zod.z.string().min(1),
  description: zod.z.string().min(1),
  inputSchema: zod.z.any(),
  executorId: zod.z.string().nullable().optional()
}).passthrough();
function createCodeInterpreterClient(codeInterpreter) {
  return connect.createPromiseClient(code_interpreter_service_connect.CodeInterpreterService, connectNode.createGrpcTransport({
    baseUrl: codeInterpreter.url,
    httpVersion: "2",
    nodeOptions: codeInterpreter.connectionOptions
  }));
}
__name(createCodeInterpreterClient, "createCodeInterpreterClient");
class CustomTool extends base_cjs.Tool {
  static {
    __name(this, "CustomTool");
  }
  name;
  description;
  emitter = emitter_cjs.Emitter.root.child({
    namespace: [
      "tool",
      "custom"
    ],
    creator: this
  });
  inputSchema() {
    return this.options.inputSchema;
  }
  client;
  static {
    this.register();
  }
  constructor(options, client) {
    general_cjs.validate(options, toolOptionsSchema);
    super(options);
    this.client = client || createCodeInterpreterClient(options.codeInterpreter);
    this.name = options.name;
    this.description = options.description;
  }
  async _run(input, _options, run) {
    const { response } = await this.client.executeCustomTool({
      executorId: this.options.executorId || "default",
      toolSourceCode: this.options.sourceCode,
      toolInputJson: JSON.stringify(input)
    }, {
      signal: run.signal
    });
    if (response.case === "error") {
      throw new CustomToolExecuteError(response.value.stderr);
    }
    return new base_cjs.StringToolOutput(response.value.toolOutputJson);
  }
  loadSnapshot(snapshot) {
    super.loadSnapshot(snapshot);
    this.client = createCodeInterpreterClient(this.options.codeInterpreter);
  }
  static async fromSourceCode(codeInterpreter, sourceCode, executorId) {
    const client = createCodeInterpreterClient(codeInterpreter);
    const response = await client.parseCustomTool({
      toolSourceCode: sourceCode
    });
    if (response.response.case === "error") {
      throw new CustomToolCreateError(response.response.value.errorMessages.join("\n"));
    }
    const { toolName, toolDescription, toolInputSchemaJson } = response.response.value;
    return new CustomTool({
      codeInterpreter,
      sourceCode,
      name: toolName,
      description: toolDescription,
      inputSchema: JSON.parse(toolInputSchemaJson),
      executorId
    }, client);
  }
}

exports.CustomTool = CustomTool;
exports.CustomToolCreateError = CustomToolCreateError;
exports.CustomToolExecuteError = CustomToolExecuteError;
//# sourceMappingURL=custom.cjs.map
//# sourceMappingURL=custom.cjs.map