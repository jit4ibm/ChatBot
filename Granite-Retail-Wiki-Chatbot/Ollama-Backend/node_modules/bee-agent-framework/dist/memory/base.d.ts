import { BaseMessage } from '../llms/primitives/message.js';
import { FrameworkError, FrameworkErrorOptions } from '../errors.js';
import { Serializable } from '../internals/serializable.js';
import '../internals/types.js';
import '../internals/helpers/guards.js';

/**
 * Copyright 2024 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare class MemoryError extends FrameworkError {
}
declare class MemoryFatalError extends MemoryError {
    constructor(message: string, errors?: Error[], options?: FrameworkErrorOptions);
}
declare abstract class BaseMemory<TState = unknown> extends Serializable<TState> {
    abstract get messages(): readonly BaseMessage[];
    abstract add(message: BaseMessage, index?: number): Promise<void>;
    abstract delete(message: BaseMessage): Promise<boolean>;
    abstract reset(): void;
    addMany(messages: Iterable<BaseMessage> | AsyncIterable<BaseMessage>, start?: number): Promise<void>;
    deleteMany(messages: Iterable<BaseMessage> | AsyncIterable<BaseMessage>): Promise<void>;
    splice(start: number, deleteCount: number, ...items: BaseMessage[]): Promise<BaseMessage[]>;
    isEmpty(): boolean;
    asReadOnly(): ReadOnlyMemory<this>;
    [Symbol.iterator](): ArrayIterator<BaseMessage>;
    abstract loadSnapshot(state: TState): void;
    abstract createSnapshot(): TState;
}
declare class ReadOnlyMemory<T extends BaseMemory = BaseMemory> extends BaseMemory<{
    source: T;
}> {
    readonly source: T;
    constructor(source: T);
    add(message: BaseMessage, index?: number): Promise<void>;
    delete(message: BaseMessage): Promise<boolean>;
    get messages(): readonly BaseMessage[];
    reset(): void;
    createSnapshot(): {
        source: T;
    };
    loadSnapshot(state: {
        source: T;
    }): void;
}

export { BaseMemory, MemoryError, MemoryFatalError, ReadOnlyMemory };
