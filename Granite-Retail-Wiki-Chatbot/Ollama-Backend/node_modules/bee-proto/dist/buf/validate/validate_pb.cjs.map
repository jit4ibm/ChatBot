{"version":3,"sources":["../../../gen/typescript/buf/validate/validate_pb.ts"],"sourcesContent":["// Copyright 2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// @generated by protoc-gen-es v1.10.0 with parameter \"target=ts\"\n// @generated from file buf/validate/validate.proto (package buf.validate, syntax proto3)\n/* eslint-disable */\n// @ts-nocheck\n\nimport type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from \"@bufbuild/protobuf\";\nimport { Duration, FieldOptions, Message, MessageOptions, OneofOptions, proto3, Timestamp } from \"@bufbuild/protobuf\";\nimport { Constraint } from \"./expression_pb.js\";\n\n/**\n * Specifies how FieldConstraints.ignore behaves. See the documentation for\n * FieldConstraints.required for definitions of \"populated\" and \"nullable\".\n *\n * @generated from enum buf.validate.Ignore\n */\nexport enum Ignore {\n  /**\n   * Validation is only skipped if it's an unpopulated nullable fields.\n   *\n   * ```proto\n   * syntax=\"proto3\";\n   *\n   * message Request {\n   *   // The uri rule applies to any value, including the empty string.\n   *   string foo = 1 [\n   *     (buf.validate.field).string.uri = true\n   *   ];\n   *\n   *   // The uri rule only applies if the field is set, including if it's\n   *   // set to the empty string.\n   *   optional string bar = 2 [\n   *     (buf.validate.field).string.uri = true\n   *   ];\n   *\n   *   // The min_items rule always applies, even if the list is empty.\n   *   repeated string baz = 3 [\n   *     (buf.validate.field).repeated.min_items = 3\n   *   ];\n   *\n   *   // The custom CEL rule applies only if the field is set, including if\n   *   // it's the \"zero\" value of that message.\n   *   SomeMessage quux = 4 [\n   *     (buf.validate.field).cel = {/* ... *\\/}\n   *   ];\n   * }\n   * ```\n   *\n   * @generated from enum value: IGNORE_UNSPECIFIED = 0;\n   */\n  UNSPECIFIED = 0,\n\n  /**\n   * Validation is skipped if the field is unpopulated. This rule is redundant\n   * if the field is already nullable. This value is equivalent behavior to the\n   * deprecated ignore_empty rule.\n   *\n   * ```proto\n   * syntax=\"proto3\n   *\n   * message Request {\n   *   // The uri rule applies only if the value is not the empty string.\n   *   string foo = 1 [\n   *     (buf.validate.field).string.uri = true,\n   *     (buf.validate.field).ignore = IGNORE_IF_UNPOPULATED\n   *   ];\n   *\n   *   // IGNORE_IF_UNPOPULATED is equivalent to IGNORE_UNSPECIFIED in this\n   *   // case: the uri rule only applies if the field is set, including if\n   *   // it's set to the empty string.\n   *   optional string bar = 2 [\n   *     (buf.validate.field).string.uri = true,\n   *     (buf.validate.field).ignore = IGNORE_IF_UNPOPULATED\n   *   ];\n   *\n   *   // The min_items rule only applies if the list has at least one item.\n   *   repeated string baz = 3 [\n   *     (buf.validate.field).repeated.min_items = 3,\n   *     (buf.validate.field).ignore = IGNORE_IF_UNPOPULATED\n   *   ];\n   *\n   *   // IGNORE_IF_UNPOPULATED is equivalent to IGNORE_UNSPECIFIED in this\n   *   // case: the custom CEL rule applies only if the field is set, including\n   *   // if it's the \"zero\" value of that message.\n   *   SomeMessage quux = 4 [\n   *     (buf.validate.field).cel = {/* ... *\\/},\n   *     (buf.validate.field).ignore = IGNORE_IF_UNPOPULATED\n   *   ];\n   * }\n   * ```\n   *\n   * @generated from enum value: IGNORE_IF_UNPOPULATED = 1;\n   */\n  IF_UNPOPULATED = 1,\n\n  /**\n   * Validation is skipped if the field is unpopulated or if it is a nullable\n   * field populated with its default value. This is typically the zero or\n   * empty value, but proto2 scalars support custom defaults. For messages, the\n   * default is a non-null message with all its fields unpopulated.\n   *\n   * ```proto\n   * syntax=\"proto3\n   *\n   * message Request {\n   *   // IGNORE_IF_DEFAULT_VALUE is equivalent to IGNORE_IF_UNPOPULATED in\n   *   // this case; the uri rule applies only if the value is not the empty\n   *   // string.\n   *   string foo = 1 [\n   *     (buf.validate.field).string.uri = true,\n   *     (buf.validate.field).ignore = IGNORE_IF_DEFAULT_VALUE\n   *   ];\n   *\n   *   // The uri rule only applies if the field is set to a value other than\n   *   // the empty string.\n   *   optional string bar = 2 [\n   *     (buf.validate.field).string.uri = true,\n   *     (buf.validate.field).ignore = IGNORE_IF_DEFAULT_VALUE\n   *   ];\n   *\n   *   // IGNORE_IF_DEFAULT_VALUE is equivalent to IGNORE_IF_UNPOPULATED in\n   *   // this case; the min_items rule only applies if the list has at least\n   *   // one item.\n   *   repeated string baz = 3 [\n   *     (buf.validate.field).repeated.min_items = 3,\n   *     (buf.validate.field).ignore = IGNORE_IF_DEFAULT_VALUE\n   *   ];\n   *\n   *   // The custom CEL rule only applies if the field is set to a value other\n   *   // than an empty message (i.e., fields are unpopulated).\n   *   SomeMessage quux = 4 [\n   *     (buf.validate.field).cel = {/* ... *\\/},\n   *     (buf.validate.field).ignore = IGNORE_IF_DEFAULT_VALUE\n   *   ];\n   * }\n   * ```\n   *\n   * This rule is affected by proto2 custom default values:\n   *\n   * ```proto\n   * syntax=\"proto2\";\n   *\n   * message Request {\n   *   // The gt rule only applies if the field is set and it's value is not\n   *   the default (i.e., not -42). The rule even applies if the field is set\n   *   to zero since the default value differs.\n   *   optional int32 value = 1 [\n   *     default = -42,\n   *     (buf.validate.field).int32.gt = 0,\n   *     (buf.validate.field).ignore = IGNORE_IF_DEFAULT_VALUE\n   *   ];\n   * }\n   *\n   * @generated from enum value: IGNORE_IF_DEFAULT_VALUE = 2;\n   */\n  IF_DEFAULT_VALUE = 2,\n\n  /**\n   * The validation rules of this field will be skipped and not evaluated. This\n   * is useful for situations that necessitate turning off the rules of a field\n   * containing a message that may not make sense in the current context, or to\n   * temporarily disable constraints during development.\n   *\n   * ```proto\n   * message MyMessage {\n   *   // The field's rules will always be ignored, including any validation's\n   *   // on value's fields.\n   *   MyOtherMessage value = 1 [\n   *     (buf.validate.field).ignore = IGNORE_ALWAYS];\n   * }\n   * ```\n   *\n   * @generated from enum value: IGNORE_ALWAYS = 3;\n   */\n  ALWAYS = 3,\n\n  /**\n   * Deprecated: Use IGNORE_IF_UNPOPULATED instead. TODO: Remove this value pre-v1.\n   *\n   * @generated from enum value: IGNORE_EMPTY = 1 [deprecated = true];\n   * @deprecated\n   */\n  EMPTY = 1,\n\n  /**\n   * Deprecated: Use IGNORE_IF_DEFAULT_VALUE. TODO: Remove this value pre-v1.\n   *\n   * @generated from enum value: IGNORE_DEFAULT = 2 [deprecated = true];\n   * @deprecated\n   */\n  DEFAULT = 2,\n}\n// Retrieve enum metadata with: proto3.getEnumType(Ignore)\nproto3.util.setEnumType(Ignore, \"buf.validate.Ignore\", [\n  { no: 0, name: \"IGNORE_UNSPECIFIED\" },\n  { no: 1, name: \"IGNORE_IF_UNPOPULATED\" },\n  { no: 2, name: \"IGNORE_IF_DEFAULT_VALUE\" },\n  { no: 3, name: \"IGNORE_ALWAYS\" },\n  { no: 1, name: \"IGNORE_EMPTY\" },\n  { no: 2, name: \"IGNORE_DEFAULT\" },\n]);\n\n/**\n * WellKnownRegex contain some well-known patterns.\n *\n * @generated from enum buf.validate.KnownRegex\n */\nexport enum KnownRegex {\n  /**\n   * @generated from enum value: KNOWN_REGEX_UNSPECIFIED = 0;\n   */\n  UNSPECIFIED = 0,\n\n  /**\n   * HTTP header name as defined by [RFC 7230](https://tools.ietf.org/html/rfc7230#section-3.2).\n   *\n   * @generated from enum value: KNOWN_REGEX_HTTP_HEADER_NAME = 1;\n   */\n  HTTP_HEADER_NAME = 1,\n\n  /**\n   * HTTP header value as defined by [RFC 7230](https://tools.ietf.org/html/rfc7230#section-3.2.4).\n   *\n   * @generated from enum value: KNOWN_REGEX_HTTP_HEADER_VALUE = 2;\n   */\n  HTTP_HEADER_VALUE = 2,\n}\n// Retrieve enum metadata with: proto3.getEnumType(KnownRegex)\nproto3.util.setEnumType(KnownRegex, \"buf.validate.KnownRegex\", [\n  { no: 0, name: \"KNOWN_REGEX_UNSPECIFIED\" },\n  { no: 1, name: \"KNOWN_REGEX_HTTP_HEADER_NAME\" },\n  { no: 2, name: \"KNOWN_REGEX_HTTP_HEADER_VALUE\" },\n]);\n\n/**\n * MessageConstraints represents validation rules that are applied to the entire message.\n * It includes disabling options and a list of Constraint messages representing Common Expression Language (CEL) validation rules.\n *\n * @generated from message buf.validate.MessageConstraints\n */\nexport class MessageConstraints extends Message<MessageConstraints> {\n  /**\n   * `disabled` is a boolean flag that, when set to true, nullifies any validation rules for this message.\n   * This includes any fields within the message that would otherwise support validation.\n   *\n   * ```proto\n   * message MyMessage {\n   *   // validation will be bypassed for this message\n   *   option (buf.validate.message).disabled = true;\n   * }\n   * ```\n   *\n   * @generated from field: optional bool disabled = 1;\n   */\n  disabled?: boolean;\n\n  /**\n   * `cel` is a repeated field of type Constraint. Each Constraint specifies a validation rule to be applied to this message.\n   * These constraints are written in Common Expression Language (CEL) syntax. For more information on\n   * CEL, [see our documentation](https://github.com/bufbuild/protovalidate/blob/main/docs/cel.md).\n   *\n   *\n   * ```proto\n   * message MyMessage {\n   *   // The field `foo` must be greater than 42.\n   *   option (buf.validate.message).cel = {\n   *     id: \"my_message.value\",\n   *     message: \"value must be greater than 42\",\n   *     expression: \"this.foo > 42\",\n   *   };\n   *   optional int32 foo = 1;\n   * }\n   * ```\n   *\n   * @generated from field: repeated buf.validate.Constraint cel = 3;\n   */\n  cel: Constraint[] = [];\n\n  constructor(data?: PartialMessage<MessageConstraints>) {\n    super();\n    proto3.util.initPartial(data, this);\n  }\n\n  static readonly runtime: typeof proto3 = proto3;\n  static readonly typeName = \"buf.validate.MessageConstraints\";\n  static readonly fields: FieldList = proto3.util.newFieldList(() => [\n    { no: 1, name: \"disabled\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, opt: true },\n    { no: 3, name: \"cel\", kind: \"message\", T: Constraint, repeated: true },\n  ]);\n\n  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MessageConstraints {\n    return new MessageConstraints().fromBinary(bytes, options);\n  }\n\n  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MessageConstraints {\n    return new MessageConstraints().fromJson(jsonValue, options);\n  }\n\n  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MessageConstraints {\n    return new MessageConstraints().fromJsonString(jsonString, options);\n  }\n\n  static equals(a: MessageConstraints | PlainMessage<MessageConstraints> | undefined, b: MessageConstraints | PlainMessage<MessageConstraints> | undefined): boolean {\n    return proto3.util.equals(MessageConstraints, a, b);\n  }\n}\n\n/**\n * The `OneofConstraints` message type enables you to manage constraints for\n * oneof fields in your protobuf messages.\n *\n * @generated from message buf.validate.OneofConstraints\n */\nexport class OneofConstraints extends Message<OneofConstraints> {\n  /**\n   * If `required` is true, exactly one field of the oneof must be present. A\n   * validation error is returned if no fields in the oneof are present. The\n   * field itself may still be a default value; further constraints\n   * should be placed on the fields themselves to ensure they are valid values,\n   * such as `min_len` or `gt`.\n   *\n   * ```proto\n   * message MyMessage {\n   *   oneof value {\n   *     // Either `a` or `b` must be set. If `a` is set, it must also be\n   *     // non-empty; whereas if `b` is set, it can still be an empty string.\n   *     option (buf.validate.oneof).required = true;\n   *     string a = 1 [(buf.validate.field).string.min_len = 1];\n   *     string b = 2;\n   *   }\n   * }\n   * ```\n   *\n   * @generated from field: optional bool required = 1;\n   */\n  required?: boolean;\n\n  constructor(data?: PartialMessage<OneofConstraints>) {\n    super();\n    proto3.util.initPartial(data, this);\n  }\n\n  static readonly runtime: typeof proto3 = proto3;\n  static readonly typeName = \"buf.validate.OneofConstraints\";\n  static readonly fields: FieldList = proto3.util.newFieldList(() => [\n    { no: 1, name: \"required\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, opt: true },\n  ]);\n\n  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OneofConstraints {\n    return new OneofConstraints().fromBinary(bytes, options);\n  }\n\n  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OneofConstraints {\n    return new OneofConstraints().fromJson(jsonValue, options);\n  }\n\n  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OneofConstraints {\n    return new OneofConstraints().fromJsonString(jsonString, options);\n  }\n\n  static equals(a: OneofConstraints | PlainMessage<OneofConstraints> | undefined, b: OneofConstraints | PlainMessage<OneofConstraints> | undefined): boolean {\n    return proto3.util.equals(OneofConstraints, a, b);\n  }\n}\n\n/**\n * FieldConstraints encapsulates the rules for each type of field. Depending on\n * the field, the correct set should be used to ensure proper validations.\n *\n * @generated from message buf.validate.FieldConstraints\n */\nexport class FieldConstraints extends Message<FieldConstraints> {\n  /**\n   * `cel` is a repeated field used to represent a textual expression\n   * in the Common Expression Language (CEL) syntax. For more information on\n   * CEL, [see our documentation](https://github.com/bufbuild/protovalidate/blob/main/docs/cel.md).\n   *\n   * ```proto\n   * message MyMessage {\n   *   // The field `value` must be greater than 42.\n   *   optional int32 value = 1 [(buf.validate.field).cel = {\n   *     id: \"my_message.value\",\n   *     message: \"value must be greater than 42\",\n   *     expression: \"this > 42\",\n   *   }];\n   * }\n   * ```\n   *\n   * @generated from field: repeated buf.validate.Constraint cel = 23;\n   */\n  cel: Constraint[] = [];\n\n  /**\n   * If `required` is true, the field must be populated. A populated field can be\n   * described as \"serialized in the wire format,\" which includes:\n   *\n   * - the following \"nullable\" fields must be explicitly set to be considered populated:\n   *   - singular message fields (whose fields may be unpopulated/default values)\n   *   - member fields of a oneof (may be their default value)\n   *   - proto3 optional fields (may be their default value)\n   *   - proto2 scalar fields (both optional and required)\n   * - proto3 scalar fields must be non-zero to be considered populated\n   * - repeated and map fields must be non-empty to be considered populated\n   *\n   * ```proto\n   * message MyMessage {\n   *   // The field `value` must be set to a non-null value.\n   *   optional MyOtherMessage value = 1 [(buf.validate.field).required = true];\n   * }\n   * ```\n   *\n   * @generated from field: bool required = 25;\n   */\n  required = false;\n\n  /**\n   * Skip validation on the field if its value matches the specified criteria.\n   * See Ignore enum for details.\n   *\n   * ```proto\n   * message UpdateRequest {\n   *   // The uri rule only applies if the field is populated and not an empty\n   *   // string.\n   *   optional string url = 1 [\n   *     (buf.validate.field).ignore = IGNORE_IF_DEFAULT_VALUE,\n   *     (buf.validate.field).string.uri = true,\n   *   ];\n   * }\n   * ```\n   *\n   * @generated from field: buf.validate.Ignore ignore = 27;\n   */\n  ignore = Ignore.UNSPECIFIED;\n\n  /**\n   * @generated from oneof buf.validate.FieldConstraints.type\n   */\n  type: {\n    /**\n     * Scalar Field Types\n     *\n     * @generated from field: buf.validate.FloatRules float = 1;\n     */\n    value: FloatRules;\n    case: \"float\";\n  } | {\n    /**\n     * @generated from field: buf.validate.DoubleRules double = 2;\n     */\n    value: DoubleRules;\n    case: \"double\";\n  } | {\n    /**\n     * @generated from field: buf.validate.Int32Rules int32 = 3;\n     */\n    value: Int32Rules;\n    case: \"int32\";\n  } | {\n    /**\n     * @generated from field: buf.validate.Int64Rules int64 = 4;\n     */\n    value: Int64Rules;\n    case: \"int64\";\n  } | {\n    /**\n     * @generated from field: buf.validate.UInt32Rules uint32 = 5;\n     */\n    value: UInt32Rules;\n    case: \"uint32\";\n  } | {\n    /**\n     * @generated from field: buf.validate.UInt64Rules uint64 = 6;\n     */\n    value: UInt64Rules;\n    case: \"uint64\";\n  } | {\n    /**\n     * @generated from field: buf.validate.SInt32Rules sint32 = 7;\n     */\n    value: SInt32Rules;\n    case: \"sint32\";\n  } | {\n    /**\n     * @generated from field: buf.validate.SInt64Rules sint64 = 8;\n     */\n    value: SInt64Rules;\n    case: \"sint64\";\n  } | {\n    /**\n     * @generated from field: buf.validate.Fixed32Rules fixed32 = 9;\n     */\n    value: Fixed32Rules;\n    case: \"fixed32\";\n  } | {\n    /**\n     * @generated from field: buf.validate.Fixed64Rules fixed64 = 10;\n     */\n    value: Fixed64Rules;\n    case: \"fixed64\";\n  } | {\n    /**\n     * @generated from field: buf.validate.SFixed32Rules sfixed32 = 11;\n     */\n    value: SFixed32Rules;\n    case: \"sfixed32\";\n  } | {\n    /**\n     * @generated from field: buf.validate.SFixed64Rules sfixed64 = 12;\n     */\n    value: SFixed64Rules;\n    case: \"sfixed64\";\n  } | {\n    /**\n     * @generated from field: buf.validate.BoolRules bool = 13;\n     */\n    value: BoolRules;\n    case: \"bool\";\n  } | {\n    /**\n     * @generated from field: buf.validate.StringRules string = 14;\n     */\n    value: StringRules;\n    case: \"string\";\n  } | {\n    /**\n     * @generated from field: buf.validate.BytesRules bytes = 15;\n     */\n    value: BytesRules;\n    case: \"bytes\";\n  } | {\n    /**\n     * Complex Field Types\n     *\n     * @generated from field: buf.validate.EnumRules enum = 16;\n     */\n    value: EnumRules;\n    case: \"enum\";\n  } | {\n    /**\n     * @generated from field: buf.validate.RepeatedRules repeated = 18;\n     */\n    value: RepeatedRules;\n    case: \"repeated\";\n  } | {\n    /**\n     * @generated from field: buf.validate.MapRules map = 19;\n     */\n    value: MapRules;\n    case: \"map\";\n  } | {\n    /**\n     * Well-Known Field Types\n     *\n     * @generated from field: buf.validate.AnyRules any = 20;\n     */\n    value: AnyRules;\n    case: \"any\";\n  } | {\n    /**\n     * @generated from field: buf.validate.DurationRules duration = 21;\n     */\n    value: DurationRules;\n    case: \"duration\";\n  } | {\n    /**\n     * @generated from field: buf.validate.TimestampRules timestamp = 22;\n     */\n    value: TimestampRules;\n    case: \"timestamp\";\n  } | { case: undefined; value?: undefined } = { case: undefined };\n\n  /**\n   * DEPRECATED: use ignore=IGNORE_ALWAYS instead. TODO: remove this field pre-v1.\n   *\n   * @generated from field: bool skipped = 24 [deprecated = true];\n   * @deprecated\n   */\n  skipped = false;\n\n  /**\n   * DEPRECATED: use ignore=IGNORE_IF_UNPOPULATED instead. TODO: remove this field pre-v1.\n   *\n   * @generated from field: bool ignore_empty = 26 [deprecated = true];\n   * @deprecated\n   */\n  ignoreEmpty = false;\n\n  constructor(data?: PartialMessage<FieldConstraints>) {\n    super();\n    proto3.util.initPartial(data, this);\n  }\n\n  static readonly runtime: typeof proto3 = proto3;\n  static readonly typeName = \"buf.validate.FieldConstraints\";\n  static readonly fields: FieldList = proto3.util.newFieldList(() => [\n    { no: 23, name: \"cel\", kind: \"message\", T: Constraint, repeated: true },\n    { no: 25, name: \"required\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */ },\n    { no: 27, name: \"ignore\", kind: \"enum\", T: proto3.getEnumType(Ignore) },\n    { no: 1, name: \"float\", kind: \"message\", T: FloatRules, oneof: \"type\" },\n    { no: 2, name: \"double\", kind: \"message\", T: DoubleRules, oneof: \"type\" },\n    { no: 3, name: \"int32\", kind: \"message\", T: Int32Rules, oneof: \"type\" },\n    { no: 4, name: \"int64\", kind: \"message\", T: Int64Rules, oneof: \"type\" },\n    { no: 5, name: \"uint32\", kind: \"message\", T: UInt32Rules, oneof: \"type\" },\n    { no: 6, name: \"uint64\", kind: \"message\", T: UInt64Rules, oneof: \"type\" },\n    { no: 7, name: \"sint32\", kind: \"message\", T: SInt32Rules, oneof: \"type\" },\n    { no: 8, name: \"sint64\", kind: \"message\", T: SInt64Rules, oneof: \"type\" },\n    { no: 9, name: \"fixed32\", kind: \"message\", T: Fixed32Rules, oneof: \"type\" },\n    { no: 10, name: \"fixed64\", kind: \"message\", T: Fixed64Rules, oneof: \"type\" },\n    { no: 11, name: \"sfixed32\", kind: \"message\", T: SFixed32Rules, oneof: \"type\" },\n    { no: 12, name: \"sfixed64\", kind: \"message\", T: SFixed64Rules, oneof: \"type\" },\n    { no: 13, name: \"bool\", kind: \"message\", T: BoolRules, oneof: \"type\" },\n    { no: 14, name: \"string\", kind: \"message\", T: StringRules, oneof: \"type\" },\n    { no: 15, name: \"bytes\", kind: \"message\", T: BytesRules, oneof: \"type\" },\n    { no: 16, name: \"enum\", kind: \"message\", T: EnumRules, oneof: \"type\" },\n    { no: 18, name: \"repeated\", kind: \"message\", T: RepeatedRules, oneof: \"type\" },\n    { no: 19, name: \"map\", kind: \"message\", T: MapRules, oneof: \"type\" },\n    { no: 20, name: \"any\", kind: \"message\", T: AnyRules, oneof: \"type\" },\n    { no: 21, name: \"duration\", kind: \"message\", T: DurationRules, oneof: \"type\" },\n    { no: 22, name: \"timestamp\", kind: \"message\", T: TimestampRules, oneof: \"type\" },\n    { no: 24, name: \"skipped\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */ },\n    { no: 26, name: \"ignore_empty\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */ },\n  ]);\n\n  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FieldConstraints {\n    return new FieldConstraints().fromBinary(bytes, options);\n  }\n\n  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FieldConstraints {\n    return new FieldConstraints().fromJson(jsonValue, options);\n  }\n\n  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FieldConstraints {\n    return new FieldConstraints().fromJsonString(jsonString, options);\n  }\n\n  static equals(a: FieldConstraints | PlainMessage<FieldConstraints> | undefined, b: FieldConstraints | PlainMessage<FieldConstraints> | undefined): boolean {\n    return proto3.util.equals(FieldConstraints, a, b);\n  }\n}\n\n/**\n * FloatRules describes the constraints applied to `float` values. These\n * rules may also be applied to the `google.protobuf.FloatValue` Well-Known-Type.\n *\n * @generated from message buf.validate.FloatRules\n */\nexport class FloatRules extends Message<FloatRules> {\n  /**\n   * `const` requires the field value to exactly match the specified value. If\n   * the field value doesn't match, an error message is generated.\n   *\n   * ```proto\n   * message MyFloat {\n   *   // value must equal 42.0\n   *   float value = 1 [(buf.validate.field).float.const = 42.0];\n   * }\n   * ```\n   *\n   * @generated from field: optional float const = 1;\n   */\n  const?: number;\n\n  /**\n   * @generated from oneof buf.validate.FloatRules.less_than\n   */\n  lessThan: {\n    /**\n     * `lt` requires the field value to be less than the specified value (field <\n     * value). If the field value is equal to or greater than the specified value,\n     * an error message is generated.\n     *\n     * ```proto\n     * message MyFloat {\n     *   // value must be less than 10.0\n     *   float value = 1 [(buf.validate.field).float.lt = 10.0];\n     * }\n     * ```\n     *\n     * @generated from field: float lt = 2;\n     */\n    value: number;\n    case: \"lt\";\n  } | {\n    /**\n     * `lte` requires the field value to be less than or equal to the specified\n     * value (field <= value). If the field value is greater than the specified\n     * value, an error message is generated.\n     *\n     * ```proto\n     * message MyFloat {\n     *   // value must be less than or equal to 10.0\n     *   float value = 1 [(buf.validate.field).float.lte = 10.0];\n     * }\n     * ```\n     *\n     * @generated from field: float lte = 3;\n     */\n    value: number;\n    case: \"lte\";\n  } | { case: undefined; value?: undefined } = { case: undefined };\n\n  /**\n   * @generated from oneof buf.validate.FloatRules.greater_than\n   */\n  greaterThan: {\n    /**\n     * `gt` requires the field value to be greater than the specified value\n     * (exclusive). If the value of `gt` is larger than a specified `lt` or\n     * `lte`, the range is reversed, and the field value must be outside the\n     * specified range. If the field value doesn't meet the required conditions,\n     * an error message is generated.\n     *\n     * ```proto\n     * message MyFloat {\n     *   // value must be greater than 5.0 [float.gt]\n     *   float value = 1 [(buf.validate.field).float.gt = 5.0];\n     *\n     *   // value must be greater than 5 and less than 10.0 [float.gt_lt]\n     *   float other_value = 2 [(buf.validate.field).float = { gt: 5.0, lt: 10.0 }];\n     *\n     *   // value must be greater than 10 or less than 5.0 [float.gt_lt_exclusive]\n     *   float another_value = 3 [(buf.validate.field).float = { gt: 10.0, lt: 5.0 }];\n     * }\n     * ```\n     *\n     * @generated from field: float gt = 4;\n     */\n    value: number;\n    case: \"gt\";\n  } | {\n    /**\n     * `gte` requires the field value to be greater than or equal to the specified\n     * value (exclusive). If the value of `gte` is larger than a specified `lt`\n     * or `lte`, the range is reversed, and the field value must be outside the\n     * specified range. If the field value doesn't meet the required conditions,\n     * an error message is generated.\n     *\n     * ```proto\n     * message MyFloat {\n     *   // value must be greater than or equal to 5.0 [float.gte]\n     *   float value = 1 [(buf.validate.field).float.gte = 5.0];\n     *\n     *   // value must be greater than or equal to 5.0 and less than 10.0 [float.gte_lt]\n     *   float other_value = 2 [(buf.validate.field).float = { gte: 5.0, lt: 10.0 }];\n     *\n     *   // value must be greater than or equal to 10.0 or less than 5.0 [float.gte_lt_exclusive]\n     *   float another_value = 3 [(buf.validate.field).float = { gte: 10.0, lt: 5.0 }];\n     * }\n     * ```\n     *\n     * @generated from field: float gte = 5;\n     */\n    value: number;\n    case: \"gte\";\n  } | { case: undefined; value?: undefined } = { case: undefined };\n\n  /**\n   * `in` requires the field value to be equal to one of the specified values.\n   * If the field value isn't one of the specified values, an error message\n   * is generated.\n   *\n   * ```proto\n   * message MyFloat {\n   *   // value must be in list [1.0, 2.0, 3.0]\n   *   repeated float value = 1 (buf.validate.field).float = { in: [1.0, 2.0, 3.0] };\n   * }\n   * ```\n   *\n   * @generated from field: repeated float in = 6;\n   */\n  in: number[] = [];\n\n  /**\n   * `in` requires the field value to not be equal to any of the specified\n   * values. If the field value is one of the specified values, an error\n   * message is generated.\n   *\n   * ```proto\n   * message MyFloat {\n   *   // value must not be in list [1.0, 2.0, 3.0]\n   *   repeated float value = 1 (buf.validate.field).float = { not_in: [1.0, 2.0, 3.0] };\n   * }\n   * ```\n   *\n   * @generated from field: repeated float not_in = 7;\n   */\n  notIn: number[] = [];\n\n  /**\n   * `finite` requires the field value to be finite. If the field value is\n   * infinite or NaN, an error message is generated.\n   *\n   * @generated from field: bool finite = 8;\n   */\n  finite = false;\n\n  constructor(data?: PartialMessage<FloatRules>) {\n    super();\n    proto3.util.initPartial(data, this);\n  }\n\n  static readonly runtime: typeof proto3 = proto3;\n  static readonly typeName = \"buf.validate.FloatRules\";\n  static readonly fields: FieldList = proto3.util.newFieldList(() => [\n    { no: 1, name: \"const\", kind: \"scalar\", T: 2 /* ScalarType.FLOAT */, opt: true },\n    { no: 2, name: \"lt\", kind: \"scalar\", T: 2 /* ScalarType.FLOAT */, oneof: \"less_than\" },\n    { no: 3, name: \"lte\", kind: \"scalar\", T: 2 /* ScalarType.FLOAT */, oneof: \"less_than\" },\n    { no: 4, name: \"gt\", kind: \"scalar\", T: 2 /* ScalarType.FLOAT */, oneof: \"greater_than\" },\n    { no: 5, name: \"gte\", kind: \"scalar\", T: 2 /* ScalarType.FLOAT */, oneof: \"greater_than\" },\n    { no: 6, name: \"in\", kind: \"scalar\", T: 2 /* ScalarType.FLOAT */, repeated: true },\n    { no: 7, name: \"not_in\", kind: \"scalar\", T: 2 /* ScalarType.FLOAT */, repeated: true },\n    { no: 8, name: \"finite\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */ },\n  ]);\n\n  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FloatRules {\n    return new FloatRules().fromBinary(bytes, options);\n  }\n\n  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FloatRules {\n    return new FloatRules().fromJson(jsonValue, options);\n  }\n\n  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FloatRules {\n    return new FloatRules().fromJsonString(jsonString, options);\n  }\n\n  static equals(a: FloatRules | PlainMessage<FloatRules> | undefined, b: FloatRules | PlainMessage<FloatRules> | undefined): boolean {\n    return proto3.util.equals(FloatRules, a, b);\n  }\n}\n\n/**\n * DoubleRules describes the constraints applied to `double` values. These\n * rules may also be applied to the `google.protobuf.DoubleValue` Well-Known-Type.\n *\n * @generated from message buf.validate.DoubleRules\n */\nexport class DoubleRules extends Message<DoubleRules> {\n  /**\n   * `const` requires the field value to exactly match the specified value. If\n   * the field value doesn't match, an error message is generated.\n   *\n   * ```proto\n   * message MyDouble {\n   *   // value must equal 42.0\n   *   double value = 1 [(buf.validate.field).double.const = 42.0];\n   * }\n   * ```\n   *\n   * @generated from field: optional double const = 1;\n   */\n  const?: number;\n\n  /**\n   * @generated from oneof buf.validate.DoubleRules.less_than\n   */\n  lessThan: {\n    /**\n     * `lt` requires the field value to be less than the specified value (field <\n     * value). If the field value is equal to or greater than the specified\n     * value, an error message is generated.\n     *\n     * ```proto\n     * message MyDouble {\n     *   // value must be less than 10.0\n     *   double value = 1 [(buf.validate.field).double.lt = 10.0];\n     * }\n     * ```\n     *\n     * @generated from field: double lt = 2;\n     */\n    value: number;\n    case: \"lt\";\n  } | {\n    /**\n     * `lte` requires the field value to be less than or equal to the specified value\n     * (field <= value). If the field value is greater than the specified value,\n     * an error message is generated.\n     *\n     * ```proto\n     * message MyDouble {\n     *   // value must be less than or equal to 10.0\n     *   double value = 1 [(buf.validate.field).double.lte = 10.0];\n     * }\n     * ```\n     *\n     * @generated from field: double lte = 3;\n     */\n    value: number;\n    case: \"lte\";\n  } | { case: undefined; value?: undefined } = { case: undefined };\n\n  /**\n   * @generated from oneof buf.validate.DoubleRules.greater_than\n   */\n  greaterThan: {\n    /**\n     * `gt` requires the field value to be greater than the specified value\n     * (exclusive). If the value of `gt` is larger than a specified `lt` or `lte`,\n     * the range is reversed, and the field value must be outside the specified\n     * range. If the field value doesn't meet the required conditions, an error\n     * message is generated.\n     *\n     * ```proto\n     * message MyDouble {\n     *   // value must be greater than 5.0 [double.gt]\n     *   double value = 1 [(buf.validate.field).double.gt = 5.0];\n     *\n     *   // value must be greater than 5 and less than 10.0 [double.gt_lt]\n     *   double other_value = 2 [(buf.validate.field).double = { gt: 5.0, lt: 10.0 }];\n     *\n     *   // value must be greater than 10 or less than 5.0 [double.gt_lt_exclusive]\n     *   double another_value = 3 [(buf.validate.field).double = { gt: 10.0, lt: 5.0 }];\n     * }\n     * ```\n     *\n     * @generated from field: double gt = 4;\n     */\n    value: number;\n    case: \"gt\";\n  } | {\n    /**\n     * `gte` requires the field value to be greater than or equal to the specified\n     * value (exclusive). If the value of `gte` is larger than a specified `lt` or\n     * `lte`, the range is reversed, and the field value must be outside the\n     * specified range. If the field value doesn't meet the required conditions,\n     * an error message is generated.\n     *\n     * ```proto\n     * message MyDouble {\n     *   // value must be greater than or equal to 5.0 [double.gte]\n     *   double value = 1 [(buf.validate.field).double.gte = 5.0];\n     *\n     *   // value must be greater than or equal to 5.0 and less than 10.0 [double.gte_lt]\n     *   double other_value = 2 [(buf.validate.field).double = { gte: 5.0, lt: 10.0 }];\n     *\n     *   // value must be greater than or equal to 10.0 or less than 5.0 [double.gte_lt_exclusive]\n     *   double another_value = 3 [(buf.validate.field).double = { gte: 10.0, lt: 5.0 }];\n     * }\n     * ```\n     *\n     * @generated from field: double gte = 5;\n     */\n    value: number;\n    case: \"gte\";\n  } | { case: undefined; value?: undefined } = { case: undefined };\n\n  /**\n   * `in` requires the field value to be equal to one of the specified values.\n   * If the field value isn't one of the specified values, an error message is\n   * generated.\n   *\n   * ```proto\n   * message MyDouble {\n   *   // value must be in list [1.0, 2.0, 3.0]\n   *   repeated double value = 1 (buf.validate.field).double = { in: [1.0, 2.0, 3.0] };\n   * }\n   * ```\n   *\n   * @generated from field: repeated double in = 6;\n   */\n  in: number[] = [];\n\n  /**\n   * `not_in` requires the field value to not be equal to any of the specified\n   * values. If the field value is one of the specified values, an error\n   * message is generated.\n   *\n   * ```proto\n   * message MyDouble {\n   *   // value must not be in list [1.0, 2.0, 3.0]\n   *   repeated double value = 1 (buf.validate.field).double = { not_in: [1.0, 2.0, 3.0] };\n   * }\n   * ```\n   *\n   * @generated from field: repeated double not_in = 7;\n   */\n  notIn: number[] = [];\n\n  /**\n   * `finite` requires the field value to be finite. If the field value is\n   * infinite or NaN, an error message is generated.\n   *\n   * @generated from field: bool finite = 8;\n   */\n  finite = false;\n\n  constructor(data?: PartialMessage<DoubleRules>) {\n    super();\n    proto3.util.initPartial(data, this);\n  }\n\n  static readonly runtime: typeof proto3 = proto3;\n  static readonly typeName = \"buf.validate.DoubleRules\";\n  static readonly fields: FieldList = proto3.util.newFieldList(() => [\n    { no: 1, name: \"const\", kind: \"scalar\", T: 1 /* ScalarType.DOUBLE */, opt: true },\n    { no: 2, name: \"lt\", kind: \"scalar\", T: 1 /* ScalarType.DOUBLE */, oneof: \"less_than\" },\n    { no: 3, name: \"lte\", kind: \"scalar\", T: 1 /* ScalarType.DOUBLE */, oneof: \"less_than\" },\n    { no: 4, name: \"gt\", kind: \"scalar\", T: 1 /* ScalarType.DOUBLE */, oneof: \"greater_than\" },\n    { no: 5, name: \"gte\", kind: \"scalar\", T: 1 /* ScalarType.DOUBLE */, oneof: \"greater_than\" },\n    { no: 6, name: \"in\", kind: \"scalar\", T: 1 /* ScalarType.DOUBLE */, repeated: true },\n    { no: 7, name: \"not_in\", kind: \"scalar\", T: 1 /* ScalarType.DOUBLE */, repeated: true },\n    { no: 8, name: \"finite\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */ },\n  ]);\n\n  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DoubleRules {\n    return new DoubleRules().fromBinary(bytes, options);\n  }\n\n  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DoubleRules {\n    return new DoubleRules().fromJson(jsonValue, options);\n  }\n\n  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DoubleRules {\n    return new DoubleRules().fromJsonString(jsonString, options);\n  }\n\n  static equals(a: DoubleRules | PlainMessage<DoubleRules> | undefined, b: DoubleRules | PlainMessage<DoubleRules> | undefined): boolean {\n    return proto3.util.equals(DoubleRules, a, b);\n  }\n}\n\n/**\n * Int32Rules describes the constraints applied to `int32` values. These\n * rules may also be applied to the `google.protobuf.Int32Value` Well-Known-Type.\n *\n * @generated from message buf.validate.Int32Rules\n */\nexport class Int32Rules extends Message<Int32Rules> {\n  /**\n   * `const` requires the field value to exactly match the specified value. If\n   * the field value doesn't match, an error message is generated.\n   *\n   * ```proto\n   * message MyInt32 {\n   *   // value must equal 42\n   *   int32 value = 1 [(buf.validate.field).int32.const = 42];\n   * }\n   * ```\n   *\n   * @generated from field: optional int32 const = 1;\n   */\n  const?: number;\n\n  /**\n   * @generated from oneof buf.validate.Int32Rules.less_than\n   */\n  lessThan: {\n    /**\n     * `lt` requires the field value to be less than the specified value (field\n     * < value). If the field value is equal to or greater than the specified\n     * value, an error message is generated.\n     *\n     * ```proto\n     * message MyInt32 {\n     *   // value must be less than 10\n     *   int32 value = 1 [(buf.validate.field).int32.lt = 10];\n     * }\n     * ```\n     *\n     * @generated from field: int32 lt = 2;\n     */\n    value: number;\n    case: \"lt\";\n  } | {\n    /**\n     * `lte` requires the field value to be less than or equal to the specified\n     * value (field <= value). If the field value is greater than the specified\n     * value, an error message is generated.\n     *\n     * ```proto\n     * message MyInt32 {\n     *   // value must be less than or equal to 10\n     *   int32 value = 1 [(buf.validate.field).int32.lte = 10];\n     * }\n     * ```\n     *\n     * @generated from field: int32 lte = 3;\n     */\n    value: number;\n    case: \"lte\";\n  } | { case: undefined; value?: undefined } = { case: undefined };\n\n  /**\n   * @generated from oneof buf.validate.Int32Rules.greater_than\n   */\n  greaterThan: {\n    /**\n     * `gt` requires the field value to be greater than the specified value\n     * (exclusive). If the value of `gt` is larger than a specified `lt` or\n     * `lte`, the range is reversed, and the field value must be outside the\n     * specified range. If the field value doesn't meet the required conditions,\n     * an error message is generated.\n     *\n     * ```proto\n     * message MyInt32 {\n     *   // value must be greater than 5 [int32.gt]\n     *   int32 value = 1 [(buf.validate.field).int32.gt = 5];\n     *\n     *   // value must be greater than 5 and less than 10 [int32.gt_lt]\n     *   int32 other_value = 2 [(buf.validate.field).int32 = { gt: 5, lt: 10 }];\n     *\n     *   // value must be greater than 10 or less than 5 [int32.gt_lt_exclusive]\n     *   int32 another_value = 3 [(buf.validate.field).int32 = { gt: 10, lt: 5 }];\n     * }\n     * ```\n     *\n     * @generated from field: int32 gt = 4;\n     */\n    value: number;\n    case: \"gt\";\n  } | {\n    /**\n     * `gte` requires the field value to be greater than or equal to the specified value\n     * (exclusive). If the value of `gte` is larger than a specified `lt` or\n     * `lte`, the range is reversed, and the field value must be outside the\n     * specified range. If the field value doesn't meet the required conditions,\n     * an error message is generated.\n     *\n     * ```proto\n     * message MyInt32 {\n     *   // value must be greater than or equal to 5 [int32.gte]\n     *   int32 value = 1 [(buf.validate.field).int32.gte = 5];\n     *\n     *   // value must be greater than or equal to 5 and less than 10 [int32.gte_lt]\n     *   int32 other_value = 2 [(buf.validate.field).int32 = { gte: 5, lt: 10 }];\n     *\n     *   // value must be greater than or equal to 10 or less than 5 [int32.gte_lt_exclusive]\n     *   int32 another_value = 3 [(buf.validate.field).int32 = { gte: 10, lt: 5 }];\n     * }\n     * ```\n     *\n     * @generated from field: int32 gte = 5;\n     */\n    value: number;\n    case: \"gte\";\n  } | { case: undefined; value?: undefined } = { case: undefined };\n\n  /**\n   * `in` requires the field value to be equal to one of the specified values.\n   * If the field value isn't one of the specified values, an error message is\n   * generated.\n   *\n   * ```proto\n   * message MyInt32 {\n   *   // value must be in list [1, 2, 3]\n   *   repeated int32 value = 1 (buf.validate.field).int32 = { in: [1, 2, 3] };\n   * }\n   * ```\n   *\n   * @generated from field: repeated int32 in = 6;\n   */\n  in: number[] = [];\n\n  /**\n   * `not_in` requires the field value to not be equal to any of the specified\n   * values. If the field value is one of the specified values, an error message\n   * is generated.\n   *\n   * ```proto\n   * message MyInt32 {\n   *   // value must not be in list [1, 2, 3]\n   *   repeated int32 value = 1 (buf.validate.field).int32 = { not_in: [1, 2, 3] };\n   * }\n   * ```\n   *\n   * @generated from field: repeated int32 not_in = 7;\n   */\n  notIn: number[] = [];\n\n  constructor(data?: PartialMessage<Int32Rules>) {\n    super();\n    proto3.util.initPartial(data, this);\n  }\n\n  static readonly runtime: typeof proto3 = proto3;\n  static readonly typeName = \"buf.validate.Int32Rules\";\n  static readonly fields: FieldList = proto3.util.newFieldList(() => [\n    { no: 1, name: \"const\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */, opt: true },\n    { no: 2, name: \"lt\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */, oneof: \"less_than\" },\n    { no: 3, name: \"lte\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */, oneof: \"less_than\" },\n    { no: 4, name: \"gt\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */, oneof: \"greater_than\" },\n    { no: 5, name: \"gte\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */, oneof: \"greater_than\" },\n    { no: 6, name: \"in\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */, repeated: true },\n    { no: 7, name: \"not_in\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */, repeated: true },\n  ]);\n\n  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int32Rules {\n    return new Int32Rules().fromBinary(bytes, options);\n  }\n\n  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int32Rules {\n    return new Int32Rules().fromJson(jsonValue, options);\n  }\n\n  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int32Rules {\n    return new Int32Rules().fromJsonString(jsonString, options);\n  }\n\n  static equals(a: Int32Rules | PlainMessage<Int32Rules> | undefined, b: Int32Rules | PlainMessage<Int32Rules> | undefined): boolean {\n    return proto3.util.equals(Int32Rules, a, b);\n  }\n}\n\n/**\n * Int64Rules describes the constraints applied to `int64` values. These\n * rules may also be applied to the `google.protobuf.Int64Value` Well-Known-Type.\n *\n * @generated from message buf.validate.Int64Rules\n */\nexport class Int64Rules extends Message<Int64Rules> {\n  /**\n   * `const` requires the field value to exactly match the specified value. If\n   * the field value doesn't match, an error message is generated.\n   *\n   * ```proto\n   * message MyInt64 {\n   *   // value must equal 42\n   *   int64 value = 1 [(buf.validate.field).int64.const = 42];\n   * }\n   * ```\n   *\n   * @generated from field: optional int64 const = 1;\n   */\n  const?: bigint;\n\n  /**\n   * @generated from oneof buf.validate.Int64Rules.less_than\n   */\n  lessThan: {\n    /**\n     * `lt` requires the field value to be less than the specified value (field <\n     * value). If the field value is equal to or greater than the specified value,\n     * an error message is generated.\n     *\n     * ```proto\n     * message MyInt64 {\n     *   // value must be less than 10\n     *   int64 value = 1 [(buf.validate.field).int64.lt = 10];\n     * }\n     * ```\n     *\n     * @generated from field: int64 lt = 2;\n     */\n    value: bigint;\n    case: \"lt\";\n  } | {\n    /**\n     * `lte` requires the field value to be less than or equal to the specified\n     * value (field <= value). If the field value is greater than the specified\n     * value, an error message is generated.\n     *\n     * ```proto\n     * message MyInt64 {\n     *   // value must be less than or equal to 10\n     *   int64 value = 1 [(buf.validate.field).int64.lte = 10];\n     * }\n     * ```\n     *\n     * @generated from field: int64 lte = 3;\n     */\n    value: bigint;\n    case: \"lte\";\n  } | { case: undefined; value?: undefined } = { case: undefined };\n\n  /**\n   * @generated from oneof buf.validate.Int64Rules.greater_than\n   */\n  greaterThan: {\n    /**\n     * `gt` requires the field value to be greater than the specified value\n     * (exclusive). If the value of `gt` is larger than a specified `lt` or\n     * `lte`, the range is reversed, and the field value must be outside the\n     * specified range. If the field value doesn't meet the required conditions,\n     * an error message is generated.\n     *\n     * ```proto\n     * message MyInt64 {\n     *   // value must be greater than 5 [int64.gt]\n     *   int64 value = 1 [(buf.validate.field).int64.gt = 5];\n     *\n     *   // value must be greater than 5 and less than 10 [int64.gt_lt]\n     *   int64 other_value = 2 [(buf.validate.field).int64 = { gt: 5, lt: 10 }];\n     *\n     *   // value must be greater than 10 or less than 5 [int64.gt_lt_exclusive]\n     *   int64 another_value = 3 [(buf.validate.field).int64 = { gt: 10, lt: 5 }];\n     * }\n     * ```\n     *\n     * @generated from field: int64 gt = 4;\n     */\n    value: bigint;\n    case: \"gt\";\n  } | {\n    /**\n     * `gte` requires the field value to be greater than or equal to the specified\n     * value (exclusive). If the value of `gte` is larger than a specified `lt`\n     * or `lte`, the range is reversed, and the field value must be outside the\n     * specified range. If the field value doesn't meet the required conditions,\n     * an error message is generated.\n     *\n     * ```proto\n     * message MyInt64 {\n     *   // value must be greater than or equal to 5 [int64.gte]\n     *   int64 value = 1 [(buf.validate.field).int64.gte = 5];\n     *\n     *   // value must be greater than or equal to 5 and less than 10 [int64.gte_lt]\n     *   int64 other_value = 2 [(buf.validate.field).int64 = { gte: 5, lt: 10 }];\n     *\n     *   // value must be greater than or equal to 10 or less than 5 [int64.gte_lt_exclusive]\n     *   int64 another_value = 3 [(buf.validate.field).int64 = { gte: 10, lt: 5 }];\n     * }\n     * ```\n     *\n     * @generated from field: int64 gte = 5;\n     */\n    value: bigint;\n    case: \"gte\";\n  } | { case: undefined; value?: undefined } = { case: undefined };\n\n  /**\n   * `in` requires the field value to be equal to one of the specified values.\n   * If the field value isn't one of the specified values, an error message is\n   * generated.\n   *\n   * ```proto\n   * message MyInt64 {\n   *   // value must be in list [1, 2, 3]\n   *   repeated int64 value = 1 (buf.validate.field).int64 = { in: [1, 2, 3] };\n   * }\n   * ```\n   *\n   * @generated from field: repeated int64 in = 6;\n   */\n  in: bigint[] = [];\n\n  /**\n   * `not_in` requires the field value to not be equal to any of the specified\n   * values. If the field value is one of the specified values, an error\n   * message is generated.\n   *\n   * ```proto\n   * message MyInt64 {\n   *   // value must not be in list [1, 2, 3]\n   *   repeated int64 value = 1 (buf.validate.field).int64 = { not_in: [1, 2, 3] };\n   * }\n   * ```\n   *\n   * @generated from field: repeated int64 not_in = 7;\n   */\n  notIn: bigint[] = [];\n\n  constructor(data?: PartialMessage<Int64Rules>) {\n    super();\n    proto3.util.initPartial(data, this);\n  }\n\n  static readonly runtime: typeof proto3 = proto3;\n  static readonly typeName = \"buf.validate.Int64Rules\";\n  static readonly fields: FieldList = proto3.util.newFieldList(() => [\n    { no: 1, name: \"const\", kind: \"scalar\", T: 3 /* ScalarType.INT64 */, opt: true },\n    { no: 2, name: \"lt\", kind: \"scalar\", T: 3 /* ScalarType.INT64 */, oneof: \"less_than\" },\n    { no: 3, name: \"lte\", kind: \"scalar\", T: 3 /* ScalarType.INT64 */, oneof: \"less_than\" },\n    { no: 4, name: \"gt\", kind: \"scalar\", T: 3 /* ScalarType.INT64 */, oneof: \"greater_than\" },\n    { no: 5, name: \"gte\", kind: \"scalar\", T: 3 /* ScalarType.INT64 */, oneof: \"greater_than\" },\n    { no: 6, name: \"in\", kind: \"scalar\", T: 3 /* ScalarType.INT64 */, repeated: true },\n    { no: 7, name: \"not_in\", kind: \"scalar\", T: 3 /* ScalarType.INT64 */, repeated: true },\n  ]);\n\n  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int64Rules {\n    return new Int64Rules().fromBinary(bytes, options);\n  }\n\n  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int64Rules {\n    return new Int64Rules().fromJson(jsonValue, options);\n  }\n\n  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int64Rules {\n    return new Int64Rules().fromJsonString(jsonString, options);\n  }\n\n  static equals(a: Int64Rules | PlainMessage<Int64Rules> | undefined, b: Int64Rules | PlainMessage<Int64Rules> | undefined): boolean {\n    return proto3.util.equals(Int64Rules, a, b);\n  }\n}\n\n/**\n * UInt32Rules describes the constraints applied to `uint32` values. These\n * rules may also be applied to the `google.protobuf.UInt32Value` Well-Known-Type.\n *\n * @generated from message buf.validate.UInt32Rules\n */\nexport class UInt32Rules extends Message<UInt32Rules> {\n  /**\n   * `const` requires the field value to exactly match the specified value. If\n   * the field value doesn't match, an error message is generated.\n   *\n   * ```proto\n   * message MyUInt32 {\n   *   // value must equal 42\n   *   uint32 value = 1 [(buf.validate.field).uint32.const = 42];\n   * }\n   * ```\n   *\n   * @generated from field: optional uint32 const = 1;\n   */\n  const?: number;\n\n  /**\n   * @generated from oneof buf.validate.UInt32Rules.less_than\n   */\n  lessThan: {\n    /**\n     * `lt` requires the field value to be less than the specified value (field <\n     * value). If the field value is equal to or greater than the specified value,\n     * an error message is generated.\n     *\n     * ```proto\n     * message MyUInt32 {\n     *   // value must be less than 10\n     *   uint32 value = 1 [(buf.validate.field).uint32.lt = 10];\n     * }\n     * ```\n     *\n     * @generated from field: uint32 lt = 2;\n     */\n    value: number;\n    case: \"lt\";\n  } | {\n    /**\n     * `lte` requires the field value to be less than or equal to the specified\n     * value (field <= value). If the field value is greater than the specified\n     * value, an error message is generated.\n     *\n     * ```proto\n     * message MyUInt32 {\n     *   // value must be less than or equal to 10\n     *   uint32 value = 1 [(buf.validate.field).uint32.lte = 10];\n     * }\n     * ```\n     *\n     * @generated from field: uint32 lte = 3;\n     */\n    value: number;\n    case: \"lte\";\n  } | { case: undefined; value?: undefined } = { case: undefined };\n\n  /**\n   * @generated from oneof buf.validate.UInt32Rules.greater_than\n   */\n  greaterThan: {\n    /**\n     * `gt` requires the field value to be greater than the specified value\n     * (exclusive). If the value of `gt` is larger than a specified `lt` or\n     * `lte`, the range is reversed, and the field value must be outside the\n     * specified range. If the field value doesn't meet the required conditions,\n     * an error message is generated.\n     *\n     * ```proto\n     * message MyUInt32 {\n     *   // value must be greater than 5 [uint32.gt]\n     *   uint32 value = 1 [(buf.validate.field).uint32.gt = 5];\n     *\n     *   // value must be greater than 5 and less than 10 [uint32.gt_lt]\n     *   uint32 other_value = 2 [(buf.validate.field).uint32 = { gt: 5, lt: 10 }];\n     *\n     *   // value must be greater than 10 or less than 5 [uint32.gt_lt_exclusive]\n     *   uint32 another_value = 3 [(buf.validate.field).uint32 = { gt: 10, lt: 5 }];\n     * }\n     * ```\n     *\n     * @generated from field: uint32 gt = 4;\n     */\n    value: number;\n    case: \"gt\";\n  } | {\n    /**\n     * `gte` requires the field value to be greater than or equal to the specified\n     * value (exclusive). If the value of `gte` is larger than a specified `lt`\n     * or `lte`, the range is reversed, and the field value must be outside the\n     * specified range. If the field value doesn't meet the required conditions,\n     * an error message is generated.\n     *\n     * ```proto\n     * message MyUInt32 {\n     *   // value must be greater than or equal to 5 [uint32.gte]\n     *   uint32 value = 1 [(buf.validate.field).uint32.gte = 5];\n     *\n     *   // value must be greater than or equal to 5 and less than 10 [uint32.gte_lt]\n     *   uint32 other_value = 2 [(buf.validate.field).uint32 = { gte: 5, lt: 10 }];\n     *\n     *   // value must be greater than or equal to 10 or less than 5 [uint32.gte_lt_exclusive]\n     *   uint32 another_value = 3 [(buf.validate.field).uint32 = { gte: 10, lt: 5 }];\n     * }\n     * ```\n     *\n     * @generated from field: uint32 gte = 5;\n     */\n    value: number;\n    case: \"gte\";\n  } | { case: undefined; value?: undefined } = { case: undefined };\n\n  /**\n   * `in` requires the field value to be equal to one of the specified values.\n   * If the field value isn't one of the specified values, an error message is\n   * generated.\n   *\n   * ```proto\n   * message MyUInt32 {\n   *   // value must be in list [1, 2, 3]\n   *   repeated uint32 value = 1 (buf.validate.field).uint32 = { in: [1, 2, 3] };\n   * }\n   * ```\n   *\n   * @generated from field: repeated uint32 in = 6;\n   */\n  in: number[] = [];\n\n  /**\n   * `not_in` requires the field value to not be equal to any of the specified\n   * values. If the field value is one of the specified values, an error\n   * message is generated.\n   *\n   * ```proto\n   * message MyUInt32 {\n   *   // value must not be in list [1, 2, 3]\n   *   repeated uint32 value = 1 (buf.validate.field).uint32 = { not_in: [1, 2, 3] };\n   * }\n   * ```\n   *\n   * @generated from field: repeated uint32 not_in = 7;\n   */\n  notIn: number[] = [];\n\n  constructor(data?: PartialMessage<UInt32Rules>) {\n    super();\n    proto3.util.initPartial(data, this);\n  }\n\n  static readonly runtime: typeof proto3 = proto3;\n  static readonly typeName = \"buf.validate.UInt32Rules\";\n  static readonly fields: FieldList = proto3.util.newFieldList(() => [\n    { no: 1, name: \"const\", kind: \"scalar\", T: 13 /* ScalarType.UINT32 */, opt: true },\n    { no: 2, name: \"lt\", kind: \"scalar\", T: 13 /* ScalarType.UINT32 */, oneof: \"less_than\" },\n    { no: 3, name: \"lte\", kind: \"scalar\", T: 13 /* ScalarType.UINT32 */, oneof: \"less_than\" },\n    { no: 4, name: \"gt\", kind: \"scalar\", T: 13 /* ScalarType.UINT32 */, oneof: \"greater_than\" },\n    { no: 5, name: \"gte\", kind: \"scalar\", T: 13 /* ScalarType.UINT32 */, oneof: \"greater_than\" },\n    { no: 6, name: \"in\", kind: \"scalar\", T: 13 /* ScalarType.UINT32 */, repeated: true },\n    { no: 7, name: \"not_in\", kind: \"scalar\", T: 13 /* ScalarType.UINT32 */, repeated: true },\n  ]);\n\n  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UInt32Rules {\n    return new UInt32Rules().fromBinary(bytes, options);\n  }\n\n  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UInt32Rules {\n    return new UInt32Rules().fromJson(jsonValue, options);\n  }\n\n  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UInt32Rules {\n    return new UInt32Rules().fromJsonString(jsonString, options);\n  }\n\n  static equals(a: UInt32Rules | PlainMessage<UInt32Rules> | undefined, b: UInt32Rules | PlainMessage<UInt32Rules> | undefined): boolean {\n    return proto3.util.equals(UInt32Rules, a, b);\n  }\n}\n\n/**\n * UInt64Rules describes the constraints applied to `uint64` values. These\n * rules may also be applied to the `google.protobuf.UInt64Value` Well-Known-Type.\n *\n * @generated from message buf.validate.UInt64Rules\n */\nexport class UInt64Rules extends Message<UInt64Rules> {\n  /**\n   * `const` requires the field value to exactly match the specified value. If\n   * the field value doesn't match, an error message is generated.\n   *\n   * ```proto\n   * message MyUInt64 {\n   *   // value must equal 42\n   *   uint64 value = 1 [(buf.validate.field).uint64.const = 42];\n   * }\n   * ```\n   *\n   * @generated from field: optional uint64 const = 1;\n   */\n  const?: bigint;\n\n  /**\n   * @generated from oneof buf.validate.UInt64Rules.less_than\n   */\n  lessThan: {\n    /**\n     * `lt` requires the field value to be less than the specified value (field <\n     * value). If the field value is equal to or greater than the specified value,\n     * an error message is generated.\n     *\n     * ```proto\n     * message MyUInt64 {\n     *   // value must be less than 10\n     *   uint64 value = 1 [(buf.validate.field).uint64.lt = 10];\n     * }\n     * ```\n     *\n     * @generated from field: uint64 lt = 2;\n     */\n    value: bigint;\n    case: \"lt\";\n  } | {\n    /**\n     * `lte` requires the field value to be less than or equal to the specified\n     * value (field <= value). If the field value is greater than the specified\n     * value, an error message is generated.\n     *\n     * ```proto\n     * message MyUInt64 {\n     *   // value must be less than or equal to 10\n     *   uint64 value = 1 [(buf.validate.field).uint64.lte = 10];\n     * }\n     * ```\n     *\n     * @generated from field: uint64 lte = 3;\n     */\n    value: bigint;\n    case: \"lte\";\n  } | { case: undefined; value?: undefined } = { case: undefined };\n\n  /**\n   * @generated from oneof buf.validate.UInt64Rules.greater_than\n   */\n  greaterThan: {\n    /**\n     * `gt` requires the field value to be greater than the specified value\n     * (exclusive). If the value of `gt` is larger than a specified `lt` or\n     * `lte`, the range is reversed, and the field value must be outside the\n     * specified range. If the field value doesn't meet the required conditions,\n     * an error message is generated.\n     *\n     * ```proto\n     * message MyUInt64 {\n     *   // value must be greater than 5 [uint64.gt]\n     *   uint64 value = 1 [(buf.validate.field).uint64.gt = 5];\n     *\n     *   // value must be greater than 5 and less than 10 [uint64.gt_lt]\n     *   uint64 other_value = 2 [(buf.validate.field).uint64 = { gt: 5, lt: 10 }];\n     *\n     *   // value must be greater than 10 or less than 5 [uint64.gt_lt_exclusive]\n     *   uint64 another_value = 3 [(buf.validate.field).uint64 = { gt: 10, lt: 5 }];\n     * }\n     * ```\n     *\n     * @generated from field: uint64 gt = 4;\n     */\n    value: bigint;\n    case: \"gt\";\n  } | {\n    /**\n     * `gte` requires the field value to be greater than or equal to the specified\n     * value (exclusive). If the value of `gte` is larger than a specified `lt`\n     * or `lte`, the range is reversed, and the field value must be outside the\n     * specified range. If the field value doesn't meet the required conditions,\n     * an error message is generated.\n     *\n     * ```proto\n     * message MyUInt64 {\n     *   // value must be greater than or equal to 5 [uint64.gte]\n     *   uint64 value = 1 [(buf.validate.field).uint64.gte = 5];\n     *\n     *   // value must be greater than or equal to 5 and less than 10 [uint64.gte_lt]\n     *   uint64 other_value = 2 [(buf.validate.field).uint64 = { gte: 5, lt: 10 }];\n     *\n     *   // value must be greater than or equal to 10 or less than 5 [uint64.gte_lt_exclusive]\n     *   uint64 another_value = 3 [(buf.validate.field).uint64 = { gte: 10, lt: 5 }];\n     * }\n     * ```\n     *\n     * @generated from field: uint64 gte = 5;\n     */\n    value: bigint;\n    case: \"gte\";\n  } | { case: undefined; value?: undefined } = { case: undefined };\n\n  /**\n   * `in` requires the field value to be equal to one of the specified values.\n   * If the field value isn't one of the specified values, an error message is\n   * generated.\n   *\n   * ```proto\n   * message MyUInt64 {\n   *   // value must be in list [1, 2, 3]\n   *   repeated uint64 value = 1 (buf.validate.field).uint64 = { in: [1, 2, 3] };\n   * }\n   * ```\n   *\n   * @generated from field: repeated uint64 in = 6;\n   */\n  in: bigint[] = [];\n\n  /**\n   * `not_in` requires the field value to not be equal to any of the specified\n   * values. If the field value is one of the specified values, an error\n   * message is generated.\n   *\n   * ```proto\n   * message MyUInt64 {\n   *   // value must not be in list [1, 2, 3]\n   *   repeated uint64 value = 1 (buf.validate.field).uint64 = { not_in: [1, 2, 3] };\n   * }\n   * ```\n   *\n   * @generated from field: repeated uint64 not_in = 7;\n   */\n  notIn: bigint[] = [];\n\n  constructor(data?: PartialMessage<UInt64Rules>) {\n    super();\n    proto3.util.initPartial(data, this);\n  }\n\n  static readonly runtime: typeof proto3 = proto3;\n  static readonly typeName = \"buf.validate.UInt64Rules\";\n  static readonly fields: FieldList = proto3.util.newFieldList(() => [\n    { no: 1, name: \"const\", kind: \"scalar\", T: 4 /* ScalarType.UINT64 */, opt: true },\n    { no: 2, name: \"lt\", kind: \"scalar\", T: 4 /* ScalarType.UINT64 */, oneof: \"less_than\" },\n    { no: 3, name: \"lte\", kind: \"scalar\", T: 4 /* ScalarType.UINT64 */, oneof: \"less_than\" },\n    { no: 4, name: \"gt\", kind: \"scalar\", T: 4 /* ScalarType.UINT64 */, oneof: \"greater_than\" },\n    { no: 5, name: \"gte\", kind: \"scalar\", T: 4 /* ScalarType.UINT64 */, oneof: \"greater_than\" },\n    { no: 6, name: \"in\", kind: \"scalar\", T: 4 /* ScalarType.UINT64 */, repeated: true },\n    { no: 7, name: \"not_in\", kind: \"scalar\", T: 4 /* ScalarType.UINT64 */, repeated: true },\n  ]);\n\n  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UInt64Rules {\n    return new UInt64Rules().fromBinary(bytes, options);\n  }\n\n  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UInt64Rules {\n    return new UInt64Rules().fromJson(jsonValue, options);\n  }\n\n  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UInt64Rules {\n    return new UInt64Rules().fromJsonString(jsonString, options);\n  }\n\n  static equals(a: UInt64Rules | PlainMessage<UInt64Rules> | undefined, b: UInt64Rules | PlainMessage<UInt64Rules> | undefined): boolean {\n    return proto3.util.equals(UInt64Rules, a, b);\n  }\n}\n\n/**\n * SInt32Rules describes the constraints applied to `sint32` values.\n *\n * @generated from message buf.validate.SInt32Rules\n */\nexport class SInt32Rules extends Message<SInt32Rules> {\n  /**\n   * `const` requires the field value to exactly match the specified value. If\n   * the field value doesn't match, an error message is generated.\n   *\n   * ```proto\n   * message MySInt32 {\n   *   // value must equal 42\n   *   sint32 value = 1 [(buf.validate.field).sint32.const = 42];\n   * }\n   * ```\n   *\n   * @generated from field: optional sint32 const = 1;\n   */\n  const?: number;\n\n  /**\n   * @generated from oneof buf.validate.SInt32Rules.less_than\n   */\n  lessThan: {\n    /**\n     * `lt` requires the field value to be less than the specified value (field\n     * < value). If the field value is equal to or greater than the specified\n     * value, an error message is generated.\n     *\n     * ```proto\n     * message MySInt32 {\n     *   // value must be less than 10\n     *   sint32 value = 1 [(buf.validate.field).sint32.lt = 10];\n     * }\n     * ```\n     *\n     * @generated from field: sint32 lt = 2;\n     */\n    value: number;\n    case: \"lt\";\n  } | {\n    /**\n     * `lte` requires the field value to be less than or equal to the specified\n     * value (field <= value). If the field value is greater than the specified\n     * value, an error message is generated.\n     *\n     * ```proto\n     * message MySInt32 {\n     *   // value must be less than or equal to 10\n     *   sint32 value = 1 [(buf.validate.field).sint32.lte = 10];\n     * }\n     * ```\n     *\n     * @generated from field: sint32 lte = 3;\n     */\n    value: number;\n    case: \"lte\";\n  } | { case: undefined; value?: undefined } = { case: undefined };\n\n  /**\n   * @generated from oneof buf.validate.SInt32Rules.greater_than\n   */\n  greaterThan: {\n    /**\n     * `gt` requires the field value to be greater than the specified value\n     * (exclusive). If the value of `gt` is larger than a specified `lt` or\n     * `lte`, the range is reversed, and the field value must be outside the\n     * specified range. If the field value doesn't meet the required conditions,\n     * an error message is generated.\n     *\n     * ```proto\n     * message MySInt32 {\n     *   // value must be greater than 5 [sint32.gt]\n     *   sint32 value = 1 [(buf.validate.field).sint32.gt = 5];\n     *\n     *   // value must be greater than 5 and less than 10 [sint32.gt_lt]\n     *   sint32 other_value = 2 [(buf.validate.field).sint32 = { gt: 5, lt: 10 }];\n     *\n     *   // value must be greater than 10 or less than 5 [sint32.gt_lt_exclusive]\n     *   sint32 another_value = 3 [(buf.validate.field).sint32 = { gt: 10, lt: 5 }];\n     * }\n     * ```\n     *\n     * @generated from field: sint32 gt = 4;\n     */\n    value: number;\n    case: \"gt\";\n  } | {\n    /**\n     * `gte` requires the field value to be greater than or equal to the specified\n     * value (exclusive). If the value of `gte` is larger than a specified `lt`\n     * or `lte`, the range is reversed, and the field value must be outside the\n     * specified range. If the field value doesn't meet the required conditions,\n     * an error message is generated.\n     *\n     * ```proto\n     * message MySInt32 {\n     *  // value must be greater than or equal to 5 [sint32.gte]\n     *  sint32 value = 1 [(buf.validate.field).sint32.gte = 5];\n     *\n     *  // value must be greater than or equal to 5 and less than 10 [sint32.gte_lt]\n     *  sint32 other_value = 2 [(buf.validate.field).sint32 = { gte: 5, lt: 10 }];\n     *\n     *  // value must be greater than or equal to 10 or less than 5 [sint32.gte_lt_exclusive]\n     *  sint32 another_value = 3 [(buf.validate.field).sint32 = { gte: 10, lt: 5 }];\n     * }\n     * ```\n     *\n     * @generated from field: sint32 gte = 5;\n     */\n    value: number;\n    case: \"gte\";\n  } | { case: undefined; value?: undefined } = { case: undefined };\n\n  /**\n   * `in` requires the field value to be equal to one of the specified values.\n   * If the field value isn't one of the specified values, an error message is\n   * generated.\n   *\n   * ```proto\n   * message MySInt32 {\n   *   // value must be in list [1, 2, 3]\n   *   repeated sint32 value = 1 (buf.validate.field).sint32 = { in: [1, 2, 3] };\n   * }\n   * ```\n   *\n   * @generated from field: repeated sint32 in = 6;\n   */\n  in: number[] = [];\n\n  /**\n   * `not_in` requires the field value to not be equal to any of the specified\n   * values. If the field value is one of the specified values, an error\n   * message is generated.\n   *\n   * ```proto\n   * message MySInt32 {\n   *   // value must not be in list [1, 2, 3]\n   *   repeated sint32 value = 1 (buf.validate.field).sint32 = { not_in: [1, 2, 3] };\n   * }\n   * ```\n   *\n   * @generated from field: repeated sint32 not_in = 7;\n   */\n  notIn: number[] = [];\n\n  constructor(data?: PartialMessage<SInt32Rules>) {\n    super();\n    proto3.util.initPartial(data, this);\n  }\n\n  static readonly runtime: typeof proto3 = proto3;\n  static readonly typeName = \"buf.validate.SInt32Rules\";\n  static readonly fields: FieldList = proto3.util.newFieldList(() => [\n    { no: 1, name: \"const\", kind: \"scalar\", T: 17 /* ScalarType.SINT32 */, opt: true },\n    { no: 2, name: \"lt\", kind: \"scalar\", T: 17 /* ScalarType.SINT32 */, oneof: \"less_than\" },\n    { no: 3, name: \"lte\", kind: \"scalar\", T: 17 /* ScalarType.SINT32 */, oneof: \"less_than\" },\n    { no: 4, name: \"gt\", kind: \"scalar\", T: 17 /* ScalarType.SINT32 */, oneof: \"greater_than\" },\n    { no: 5, name: \"gte\", kind: \"scalar\", T: 17 /* ScalarType.SINT32 */, oneof: \"greater_than\" },\n    { no: 6, name: \"in\", kind: \"scalar\", T: 17 /* ScalarType.SINT32 */, repeated: true },\n    { no: 7, name: \"not_in\", kind: \"scalar\", T: 17 /* ScalarType.SINT32 */, repeated: true },\n  ]);\n\n  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SInt32Rules {\n    return new SInt32Rules().fromBinary(bytes, options);\n  }\n\n  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SInt32Rules {\n    return new SInt32Rules().fromJson(jsonValue, options);\n  }\n\n  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SInt32Rules {\n    return new SInt32Rules().fromJsonString(jsonString, options);\n  }\n\n  static equals(a: SInt32Rules | PlainMessage<SInt32Rules> | undefined, b: SInt32Rules | PlainMessage<SInt32Rules> | undefined): boolean {\n    return proto3.util.equals(SInt32Rules, a, b);\n  }\n}\n\n/**\n * SInt64Rules describes the constraints applied to `sint64` values.\n *\n * @generated from message buf.validate.SInt64Rules\n */\nexport class SInt64Rules extends Message<SInt64Rules> {\n  /**\n   * `const` requires the field value to exactly match the specified value. If\n   * the field value doesn't match, an error message is generated.\n   *\n   * ```proto\n   * message MySInt64 {\n   *   // value must equal 42\n   *   sint64 value = 1 [(buf.validate.field).sint64.const = 42];\n   * }\n   * ```\n   *\n   * @generated from field: optional sint64 const = 1;\n   */\n  const?: bigint;\n\n  /**\n   * @generated from oneof buf.validate.SInt64Rules.less_than\n   */\n  lessThan: {\n    /**\n     * `lt` requires the field value to be less than the specified value (field\n     * < value). If the field value is equal to or greater than the specified\n     * value, an error message is generated.\n     *\n     * ```proto\n     * message MySInt64 {\n     *   // value must be less than 10\n     *   sint64 value = 1 [(buf.validate.field).sint64.lt = 10];\n     * }\n     * ```\n     *\n     * @generated from field: sint64 lt = 2;\n     */\n    value: bigint;\n    case: \"lt\";\n  } | {\n    /**\n     * `lte` requires the field value to be less than or equal to the specified\n     * value (field <= value). If the field value is greater than the specified\n     * value, an error message is generated.\n     *\n     * ```proto\n     * message MySInt64 {\n     *   // value must be less than or equal to 10\n     *   sint64 value = 1 [(buf.validate.field).sint64.lte = 10];\n     * }\n     * ```\n     *\n     * @generated from field: sint64 lte = 3;\n     */\n    value: bigint;\n    case: \"lte\";\n  } | { case: undefined; value?: undefined } = { case: undefined };\n\n  /**\n   * @generated from oneof buf.validate.SInt64Rules.greater_than\n   */\n  greaterThan: {\n    /**\n     * `gt` requires the field value to be greater than the specified value\n     * (exclusive). If the value of `gt` is larger than a specified `lt` or\n     * `lte`, the range is reversed, and the field value must be outside the\n     * specified range. If the field value doesn't meet the required conditions,\n     * an error message is generated.\n     *\n     * ```proto\n     * message MySInt64 {\n     *   // value must be greater than 5 [sint64.gt]\n     *   sint64 value = 1 [(buf.validate.field).sint64.gt = 5];\n     *\n     *   // value must be greater than 5 and less than 10 [sint64.gt_lt]\n     *   sint64 other_value = 2 [(buf.validate.field).sint64 = { gt: 5, lt: 10 }];\n     *\n     *   // value must be greater than 10 or less than 5 [sint64.gt_lt_exclusive]\n     *   sint64 another_value = 3 [(buf.validate.field).sint64 = { gt: 10, lt: 5 }];\n     * }\n     * ```\n     *\n     * @generated from field: sint64 gt = 4;\n     */\n    value: bigint;\n    case: \"gt\";\n  } | {\n    /**\n     * `gte` requires the field value to be greater than or equal to the specified\n     * value (exclusive). If the value of `gte` is larger than a specified `lt`\n     * or `lte`, the range is reversed, and the field value must be outside the\n     * specified range. If the field value doesn't meet the required conditions,\n     * an error message is generated.\n     *\n     * ```proto\n     * message MySInt64 {\n     *   // value must be greater than or equal to 5 [sint64.gte]\n     *   sint64 value = 1 [(buf.validate.field).sint64.gte = 5];\n     *\n     *   // value must be greater than or equal to 5 and less than 10 [sint64.gte_lt]\n     *   sint64 other_value = 2 [(buf.validate.field).sint64 = { gte: 5, lt: 10 }];\n     *\n     *   // value must be greater than or equal to 10 or less than 5 [sint64.gte_lt_exclusive]\n     *   sint64 another_value = 3 [(buf.validate.field).sint64 = { gte: 10, lt: 5 }];\n     * }\n     * ```\n     *\n     * @generated from field: sint64 gte = 5;\n     */\n    value: bigint;\n    case: \"gte\";\n  } | { case: undefined; value?: undefined } = { case: undefined };\n\n  /**\n   * `in` requires the field value to be equal to one of the specified values.\n   * If the field value isn't one of the specified values, an error message\n   * is generated.\n   *\n   * ```proto\n   * message MySInt64 {\n   *   // value must be in list [1, 2, 3]\n   *   repeated sint64 value = 1 (buf.validate.field).sint64 = { in: [1, 2, 3] };\n   * }\n   * ```\n   *\n   * @generated from field: repeated sint64 in = 6;\n   */\n  in: bigint[] = [];\n\n  /**\n   * `not_in` requires the field value to not be equal to any of the specified\n   * values. If the field value is one of the specified values, an error\n   * message is generated.\n   *\n   * ```proto\n   * message MySInt64 {\n   *   // value must not be in list [1, 2, 3]\n   *   repeated sint64 value = 1 (buf.validate.field).sint64 = { not_in: [1, 2, 3] };\n   * }\n   * ```\n   *\n   * @generated from field: repeated sint64 not_in = 7;\n   */\n  notIn: bigint[] = [];\n\n  constructor(data?: PartialMessage<SInt64Rules>) {\n    super();\n    proto3.util.initPartial(data, this);\n  }\n\n  static readonly runtime: typeof proto3 = proto3;\n  static readonly typeName = \"buf.validate.SInt64Rules\";\n  static readonly fields: FieldList = proto3.util.newFieldList(() => [\n    { no: 1, name: \"const\", kind: \"scalar\", T: 18 /* ScalarType.SINT64 */, opt: true },\n    { no: 2, name: \"lt\", kind: \"scalar\", T: 18 /* ScalarType.SINT64 */, oneof: \"less_than\" },\n    { no: 3, name: \"lte\", kind: \"scalar\", T: 18 /* ScalarType.SINT64 */, oneof: \"less_than\" },\n    { no: 4, name: \"gt\", kind: \"scalar\", T: 18 /* ScalarType.SINT64 */, oneof: \"greater_than\" },\n    { no: 5, name: \"gte\", kind: \"scalar\", T: 18 /* ScalarType.SINT64 */, oneof: \"greater_than\" },\n    { no: 6, name: \"in\", kind: \"scalar\", T: 18 /* ScalarType.SINT64 */, repeated: true },\n    { no: 7, name: \"not_in\", kind: \"scalar\", T: 18 /* ScalarType.SINT64 */, repeated: true },\n  ]);\n\n  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SInt64Rules {\n    return new SInt64Rules().fromBinary(bytes, options);\n  }\n\n  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SInt64Rules {\n    return new SInt64Rules().fromJson(jsonValue, options);\n  }\n\n  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SInt64Rules {\n    return new SInt64Rules().fromJsonString(jsonString, options);\n  }\n\n  static equals(a: SInt64Rules | PlainMessage<SInt64Rules> | undefined, b: SInt64Rules | PlainMessage<SInt64Rules> | undefined): boolean {\n    return proto3.util.equals(SInt64Rules, a, b);\n  }\n}\n\n/**\n * Fixed32Rules describes the constraints applied to `fixed32` values.\n *\n * @generated from message buf.validate.Fixed32Rules\n */\nexport class Fixed32Rules extends Message<Fixed32Rules> {\n  /**\n   * `const` requires the field value to exactly match the specified value.\n   * If the field value doesn't match, an error message is generated.\n   *\n   * ```proto\n   * message MyFixed32 {\n   *   // value must equal 42\n   *   fixed32 value = 1 [(buf.validate.field).fixed32.const = 42];\n   * }\n   * ```\n   *\n   * @generated from field: optional fixed32 const = 1;\n   */\n  const?: number;\n\n  /**\n   * @generated from oneof buf.validate.Fixed32Rules.less_than\n   */\n  lessThan: {\n    /**\n     * `lt` requires the field value to be less than the specified value (field <\n     * value). If the field value is equal to or greater than the specified value,\n     * an error message is generated.\n     *\n     * ```proto\n     * message MyFixed32 {\n     *   // value must be less than 10\n     *   fixed32 value = 1 [(buf.validate.field).fixed32.lt = 10];\n     * }\n     * ```\n     *\n     * @generated from field: fixed32 lt = 2;\n     */\n    value: number;\n    case: \"lt\";\n  } | {\n    /**\n     * `lte` requires the field value to be less than or equal to the specified\n     * value (field <= value). If the field value is greater than the specified\n     * value, an error message is generated.\n     *\n     * ```proto\n     * message MyFixed32 {\n     *   // value must be less than or equal to 10\n     *   fixed32 value = 1 [(buf.validate.field).fixed32.lte = 10];\n     * }\n     * ```\n     *\n     * @generated from field: fixed32 lte = 3;\n     */\n    value: number;\n    case: \"lte\";\n  } | { case: undefined; value?: undefined } = { case: undefined };\n\n  /**\n   * @generated from oneof buf.validate.Fixed32Rules.greater_than\n   */\n  greaterThan: {\n    /**\n     * `gt` requires the field value to be greater than the specified value\n     * (exclusive). If the value of `gt` is larger than a specified `lt` or\n     * `lte`, the range is reversed, and the field value must be outside the\n     * specified range. If the field value doesn't meet the required conditions,\n     * an error message is generated.\n     *\n     * ```proto\n     * message MyFixed32 {\n     *   // value must be greater than 5 [fixed32.gt]\n     *   fixed32 value = 1 [(buf.validate.field).fixed32.gt = 5];\n     *\n     *   // value must be greater than 5 and less than 10 [fixed32.gt_lt]\n     *   fixed32 other_value = 2 [(buf.validate.field).fixed32 = { gt: 5, lt: 10 }];\n     *\n     *   // value must be greater than 10 or less than 5 [fixed32.gt_lt_exclusive]\n     *   fixed32 another_value = 3 [(buf.validate.field).fixed32 = { gt: 10, lt: 5 }];\n     * }\n     * ```\n     *\n     * @generated from field: fixed32 gt = 4;\n     */\n    value: number;\n    case: \"gt\";\n  } | {\n    /**\n     * `gte` requires the field value to be greater than or equal to the specified\n     * value (exclusive). If the value of `gte` is larger than a specified `lt`\n     * or `lte`, the range is reversed, and the field value must be outside the\n     * specified range. If the field value doesn't meet the required conditions,\n     * an error message is generated.\n     *\n     * ```proto\n     * message MyFixed32 {\n     *   // value must be greater than or equal to 5 [fixed32.gte]\n     *   fixed32 value = 1 [(buf.validate.field).fixed32.gte = 5];\n     *\n     *   // value must be greater than or equal to 5 and less than 10 [fixed32.gte_lt]\n     *   fixed32 other_value = 2 [(buf.validate.field).fixed32 = { gte: 5, lt: 10 }];\n     *\n     *   // value must be greater than or equal to 10 or less than 5 [fixed32.gte_lt_exclusive]\n     *   fixed32 another_value = 3 [(buf.validate.field).fixed32 = { gte: 10, lt: 5 }];\n     * }\n     * ```\n     *\n     * @generated from field: fixed32 gte = 5;\n     */\n    value: number;\n    case: \"gte\";\n  } | { case: undefined; value?: undefined } = { case: undefined };\n\n  /**\n   * `in` requires the field value to be equal to one of the specified values.\n   * If the field value isn't one of the specified values, an error message\n   * is generated.\n   *\n   * ```proto\n   * message MyFixed32 {\n   *   // value must be in list [1, 2, 3]\n   *   repeated fixed32 value = 1 (buf.validate.field).fixed32 = { in: [1, 2, 3] };\n   * }\n   * ```\n   *\n   * @generated from field: repeated fixed32 in = 6;\n   */\n  in: number[] = [];\n\n  /**\n   * `not_in` requires the field value to not be equal to any of the specified\n   * values. If the field value is one of the specified values, an error\n   * message is generated.\n   *\n   * ```proto\n   * message MyFixed32 {\n   *   // value must not be in list [1, 2, 3]\n   *   repeated fixed32 value = 1 (buf.validate.field).fixed32 = { not_in: [1, 2, 3] };\n   * }\n   * ```\n   *\n   * @generated from field: repeated fixed32 not_in = 7;\n   */\n  notIn: number[] = [];\n\n  constructor(data?: PartialMessage<Fixed32Rules>) {\n    super();\n    proto3.util.initPartial(data, this);\n  }\n\n  static readonly runtime: typeof proto3 = proto3;\n  static readonly typeName = \"buf.validate.Fixed32Rules\";\n  static readonly fields: FieldList = proto3.util.newFieldList(() => [\n    { no: 1, name: \"const\", kind: \"scalar\", T: 7 /* ScalarType.FIXED32 */, opt: true },\n    { no: 2, name: \"lt\", kind: \"scalar\", T: 7 /* ScalarType.FIXED32 */, oneof: \"less_than\" },\n    { no: 3, name: \"lte\", kind: \"scalar\", T: 7 /* ScalarType.FIXED32 */, oneof: \"less_than\" },\n    { no: 4, name: \"gt\", kind: \"scalar\", T: 7 /* ScalarType.FIXED32 */, oneof: \"greater_than\" },\n    { no: 5, name: \"gte\", kind: \"scalar\", T: 7 /* ScalarType.FIXED32 */, oneof: \"greater_than\" },\n    { no: 6, name: \"in\", kind: \"scalar\", T: 7 /* ScalarType.FIXED32 */, repeated: true },\n    { no: 7, name: \"not_in\", kind: \"scalar\", T: 7 /* ScalarType.FIXED32 */, repeated: true },\n  ]);\n\n  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Fixed32Rules {\n    return new Fixed32Rules().fromBinary(bytes, options);\n  }\n\n  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Fixed32Rules {\n    return new Fixed32Rules().fromJson(jsonValue, options);\n  }\n\n  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Fixed32Rules {\n    return new Fixed32Rules().fromJsonString(jsonString, options);\n  }\n\n  static equals(a: Fixed32Rules | PlainMessage<Fixed32Rules> | undefined, b: Fixed32Rules | PlainMessage<Fixed32Rules> | undefined): boolean {\n    return proto3.util.equals(Fixed32Rules, a, b);\n  }\n}\n\n/**\n * Fixed64Rules describes the constraints applied to `fixed64` values.\n *\n * @generated from message buf.validate.Fixed64Rules\n */\nexport class Fixed64Rules extends Message<Fixed64Rules> {\n  /**\n   * `const` requires the field value to exactly match the specified value. If\n   * the field value doesn't match, an error message is generated.\n   *\n   * ```proto\n   * message MyFixed64 {\n   *   // value must equal 42\n   *   fixed64 value = 1 [(buf.validate.field).fixed64.const = 42];\n   * }\n   * ```\n   *\n   * @generated from field: optional fixed64 const = 1;\n   */\n  const?: bigint;\n\n  /**\n   * @generated from oneof buf.validate.Fixed64Rules.less_than\n   */\n  lessThan: {\n    /**\n     * `lt` requires the field value to be less than the specified value (field <\n     * value). If the field value is equal to or greater than the specified value,\n     * an error message is generated.\n     *\n     * ```proto\n     * message MyFixed64 {\n     *   // value must be less than 10\n     *   fixed64 value = 1 [(buf.validate.field).fixed64.lt = 10];\n     * }\n     * ```\n     *\n     * @generated from field: fixed64 lt = 2;\n     */\n    value: bigint;\n    case: \"lt\";\n  } | {\n    /**\n     * `lte` requires the field value to be less than or equal to the specified\n     * value (field <= value). If the field value is greater than the specified\n     * value, an error message is generated.\n     *\n     * ```proto\n     * message MyFixed64 {\n     *   // value must be less than or equal to 10\n     *   fixed64 value = 1 [(buf.validate.field).fixed64.lte = 10];\n     * }\n     * ```\n     *\n     * @generated from field: fixed64 lte = 3;\n     */\n    value: bigint;\n    case: \"lte\";\n  } | { case: undefined; value?: undefined } = { case: undefined };\n\n  /**\n   * @generated from oneof buf.validate.Fixed64Rules.greater_than\n   */\n  greaterThan: {\n    /**\n     * `gt` requires the field value to be greater than the specified value\n     * (exclusive). If the value of `gt` is larger than a specified `lt` or\n     * `lte`, the range is reversed, and the field value must be outside the\n     * specified range. If the field value doesn't meet the required conditions,\n     * an error message is generated.\n     *\n     * ```proto\n     * message MyFixed64 {\n     *   // value must be greater than 5 [fixed64.gt]\n     *   fixed64 value = 1 [(buf.validate.field).fixed64.gt = 5];\n     *\n     *   // value must be greater than 5 and less than 10 [fixed64.gt_lt]\n     *   fixed64 other_value = 2 [(buf.validate.field).fixed64 = { gt: 5, lt: 10 }];\n     *\n     *   // value must be greater than 10 or less than 5 [fixed64.gt_lt_exclusive]\n     *   fixed64 another_value = 3 [(buf.validate.field).fixed64 = { gt: 10, lt: 5 }];\n     * }\n     * ```\n     *\n     * @generated from field: fixed64 gt = 4;\n     */\n    value: bigint;\n    case: \"gt\";\n  } | {\n    /**\n     * `gte` requires the field value to be greater than or equal to the specified\n     * value (exclusive). If the value of `gte` is larger than a specified `lt`\n     * or `lte`, the range is reversed, and the field value must be outside the\n     * specified range. If the field value doesn't meet the required conditions,\n     * an error message is generated.\n     *\n     * ```proto\n     * message MyFixed64 {\n     *   // value must be greater than or equal to 5 [fixed64.gte]\n     *   fixed64 value = 1 [(buf.validate.field).fixed64.gte = 5];\n     *\n     *   // value must be greater than or equal to 5 and less than 10 [fixed64.gte_lt]\n     *   fixed64 other_value = 2 [(buf.validate.field).fixed64 = { gte: 5, lt: 10 }];\n     *\n     *   // value must be greater than or equal to 10 or less than 5 [fixed64.gte_lt_exclusive]\n     *   fixed64 another_value = 3 [(buf.validate.field).fixed64 = { gte: 10, lt: 5 }];\n     * }\n     * ```\n     *\n     * @generated from field: fixed64 gte = 5;\n     */\n    value: bigint;\n    case: \"gte\";\n  } | { case: undefined; value?: undefined } = { case: undefined };\n\n  /**\n   * `in` requires the field value to be equal to one of the specified values.\n   * If the field value isn't one of the specified values, an error message is\n   * generated.\n   *\n   * ```proto\n   * message MyFixed64 {\n   *   // value must be in list [1, 2, 3]\n   *   repeated fixed64 value = 1 (buf.validate.field).fixed64 = { in: [1, 2, 3] };\n   * }\n   * ```\n   *\n   * @generated from field: repeated fixed64 in = 6;\n   */\n  in: bigint[] = [];\n\n  /**\n   * `not_in` requires the field value to not be equal to any of the specified\n   * values. If the field value is one of the specified values, an error\n   * message is generated.\n   *\n   * ```proto\n   * message MyFixed64 {\n   *   // value must not be in list [1, 2, 3]\n   *   repeated fixed64 value = 1 (buf.validate.field).fixed64 = { not_in: [1, 2, 3] };\n   * }\n   * ```\n   *\n   * @generated from field: repeated fixed64 not_in = 7;\n   */\n  notIn: bigint[] = [];\n\n  constructor(data?: PartialMessage<Fixed64Rules>) {\n    super();\n    proto3.util.initPartial(data, this);\n  }\n\n  static readonly runtime: typeof proto3 = proto3;\n  static readonly typeName = \"buf.validate.Fixed64Rules\";\n  static readonly fields: FieldList = proto3.util.newFieldList(() => [\n    { no: 1, name: \"const\", kind: \"scalar\", T: 6 /* ScalarType.FIXED64 */, opt: true },\n    { no: 2, name: \"lt\", kind: \"scalar\", T: 6 /* ScalarType.FIXED64 */, oneof: \"less_than\" },\n    { no: 3, name: \"lte\", kind: \"scalar\", T: 6 /* ScalarType.FIXED64 */, oneof: \"less_than\" },\n    { no: 4, name: \"gt\", kind: \"scalar\", T: 6 /* ScalarType.FIXED64 */, oneof: \"greater_than\" },\n    { no: 5, name: \"gte\", kind: \"scalar\", T: 6 /* ScalarType.FIXED64 */, oneof: \"greater_than\" },\n    { no: 6, name: \"in\", kind: \"scalar\", T: 6 /* ScalarType.FIXED64 */, repeated: true },\n    { no: 7, name: \"not_in\", kind: \"scalar\", T: 6 /* ScalarType.FIXED64 */, repeated: true },\n  ]);\n\n  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Fixed64Rules {\n    return new Fixed64Rules().fromBinary(bytes, options);\n  }\n\n  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Fixed64Rules {\n    return new Fixed64Rules().fromJson(jsonValue, options);\n  }\n\n  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Fixed64Rules {\n    return new Fixed64Rules().fromJsonString(jsonString, options);\n  }\n\n  static equals(a: Fixed64Rules | PlainMessage<Fixed64Rules> | undefined, b: Fixed64Rules | PlainMessage<Fixed64Rules> | undefined): boolean {\n    return proto3.util.equals(Fixed64Rules, a, b);\n  }\n}\n\n/**\n * SFixed32Rules describes the constraints applied to `fixed32` values.\n *\n * @generated from message buf.validate.SFixed32Rules\n */\nexport class SFixed32Rules extends Message<SFixed32Rules> {\n  /**\n   * `const` requires the field value to exactly match the specified value. If\n   * the field value doesn't match, an error message is generated.\n   *\n   * ```proto\n   * message MySFixed32 {\n   *   // value must equal 42\n   *   sfixed32 value = 1 [(buf.validate.field).sfixed32.const = 42];\n   * }\n   * ```\n   *\n   * @generated from field: optional sfixed32 const = 1;\n   */\n  const?: number;\n\n  /**\n   * @generated from oneof buf.validate.SFixed32Rules.less_than\n   */\n  lessThan: {\n    /**\n     * `lt` requires the field value to be less than the specified value (field <\n     * value). If the field value is equal to or greater than the specified value,\n     * an error message is generated.\n     *\n     * ```proto\n     * message MySFixed32 {\n     *   // value must be less than 10\n     *   sfixed32 value = 1 [(buf.validate.field).sfixed32.lt = 10];\n     * }\n     * ```\n     *\n     * @generated from field: sfixed32 lt = 2;\n     */\n    value: number;\n    case: \"lt\";\n  } | {\n    /**\n     * `lte` requires the field value to be less than or equal to the specified\n     * value (field <= value). If the field value is greater than the specified\n     * value, an error message is generated.\n     *\n     * ```proto\n     * message MySFixed32 {\n     *   // value must be less than or equal to 10\n     *   sfixed32 value = 1 [(buf.validate.field).sfixed32.lte = 10];\n     * }\n     * ```\n     *\n     * @generated from field: sfixed32 lte = 3;\n     */\n    value: number;\n    case: \"lte\";\n  } | { case: undefined; value?: undefined } = { case: undefined };\n\n  /**\n   * @generated from oneof buf.validate.SFixed32Rules.greater_than\n   */\n  greaterThan: {\n    /**\n     * `gt` requires the field value to be greater than the specified value\n     * (exclusive). If the value of `gt` is larger than a specified `lt` or\n     * `lte`, the range is reversed, and the field value must be outside the\n     * specified range. If the field value doesn't meet the required conditions,\n     * an error message is generated.\n     *\n     * ```proto\n     * message MySFixed32 {\n     *   // value must be greater than 5 [sfixed32.gt]\n     *   sfixed32 value = 1 [(buf.validate.field).sfixed32.gt = 5];\n     *\n     *   // value must be greater than 5 and less than 10 [sfixed32.gt_lt]\n     *   sfixed32 other_value = 2 [(buf.validate.field).sfixed32 = { gt: 5, lt: 10 }];\n     *\n     *   // value must be greater than 10 or less than 5 [sfixed32.gt_lt_exclusive]\n     *   sfixed32 another_value = 3 [(buf.validate.field).sfixed32 = { gt: 10, lt: 5 }];\n     * }\n     * ```\n     *\n     * @generated from field: sfixed32 gt = 4;\n     */\n    value: number;\n    case: \"gt\";\n  } | {\n    /**\n     * `gte` requires the field value to be greater than or equal to the specified\n     * value (exclusive). If the value of `gte` is larger than a specified `lt`\n     * or `lte`, the range is reversed, and the field value must be outside the\n     * specified range. If the field value doesn't meet the required conditions,\n     * an error message is generated.\n     *\n     * ```proto\n     * message MySFixed32 {\n     *   // value must be greater than or equal to 5 [sfixed32.gte]\n     *   sfixed32 value = 1 [(buf.validate.field).sfixed32.gte = 5];\n     *\n     *   // value must be greater than or equal to 5 and less than 10 [sfixed32.gte_lt]\n     *   sfixed32 other_value = 2 [(buf.validate.field).sfixed32 = { gte: 5, lt: 10 }];\n     *\n     *   // value must be greater than or equal to 10 or less than 5 [sfixed32.gte_lt_exclusive]\n     *   sfixed32 another_value = 3 [(buf.validate.field).sfixed32 = { gte: 10, lt: 5 }];\n     * }\n     * ```\n     *\n     * @generated from field: sfixed32 gte = 5;\n     */\n    value: number;\n    case: \"gte\";\n  } | { case: undefined; value?: undefined } = { case: undefined };\n\n  /**\n   * `in` requires the field value to be equal to one of the specified values.\n   * If the field value isn't one of the specified values, an error message is\n   * generated.\n   *\n   * ```proto\n   * message MySFixed32 {\n   *   // value must be in list [1, 2, 3]\n   *   repeated sfixed32 value = 1 (buf.validate.field).sfixed32 = { in: [1, 2, 3] };\n   * }\n   * ```\n   *\n   * @generated from field: repeated sfixed32 in = 6;\n   */\n  in: number[] = [];\n\n  /**\n   * `not_in` requires the field value to not be equal to any of the specified\n   * values. If the field value is one of the specified values, an error\n   * message is generated.\n   *\n   * ```proto\n   * message MySFixed32 {\n   *   // value must not be in list [1, 2, 3]\n   *   repeated sfixed32 value = 1 (buf.validate.field).sfixed32 = { not_in: [1, 2, 3] };\n   * }\n   * ```\n   *\n   * @generated from field: repeated sfixed32 not_in = 7;\n   */\n  notIn: number[] = [];\n\n  constructor(data?: PartialMessage<SFixed32Rules>) {\n    super();\n    proto3.util.initPartial(data, this);\n  }\n\n  static readonly runtime: typeof proto3 = proto3;\n  static readonly typeName = \"buf.validate.SFixed32Rules\";\n  static readonly fields: FieldList = proto3.util.newFieldList(() => [\n    { no: 1, name: \"const\", kind: \"scalar\", T: 15 /* ScalarType.SFIXED32 */, opt: true },\n    { no: 2, name: \"lt\", kind: \"scalar\", T: 15 /* ScalarType.SFIXED32 */, oneof: \"less_than\" },\n    { no: 3, name: \"lte\", kind: \"scalar\", T: 15 /* ScalarType.SFIXED32 */, oneof: \"less_than\" },\n    { no: 4, name: \"gt\", kind: \"scalar\", T: 15 /* ScalarType.SFIXED32 */, oneof: \"greater_than\" },\n    { no: 5, name: \"gte\", kind: \"scalar\", T: 15 /* ScalarType.SFIXED32 */, oneof: \"greater_than\" },\n    { no: 6, name: \"in\", kind: \"scalar\", T: 15 /* ScalarType.SFIXED32 */, repeated: true },\n    { no: 7, name: \"not_in\", kind: \"scalar\", T: 15 /* ScalarType.SFIXED32 */, repeated: true },\n  ]);\n\n  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SFixed32Rules {\n    return new SFixed32Rules().fromBinary(bytes, options);\n  }\n\n  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SFixed32Rules {\n    return new SFixed32Rules().fromJson(jsonValue, options);\n  }\n\n  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SFixed32Rules {\n    return new SFixed32Rules().fromJsonString(jsonString, options);\n  }\n\n  static equals(a: SFixed32Rules | PlainMessage<SFixed32Rules> | undefined, b: SFixed32Rules | PlainMessage<SFixed32Rules> | undefined): boolean {\n    return proto3.util.equals(SFixed32Rules, a, b);\n  }\n}\n\n/**\n * SFixed64Rules describes the constraints applied to `fixed64` values.\n *\n * @generated from message buf.validate.SFixed64Rules\n */\nexport class SFixed64Rules extends Message<SFixed64Rules> {\n  /**\n   * `const` requires the field value to exactly match the specified value. If\n   * the field value doesn't match, an error message is generated.\n   *\n   * ```proto\n   * message MySFixed64 {\n   *   // value must equal 42\n   *   sfixed64 value = 1 [(buf.validate.field).sfixed64.const = 42];\n   * }\n   * ```\n   *\n   * @generated from field: optional sfixed64 const = 1;\n   */\n  const?: bigint;\n\n  /**\n   * @generated from oneof buf.validate.SFixed64Rules.less_than\n   */\n  lessThan: {\n    /**\n     * `lt` requires the field value to be less than the specified value (field <\n     * value). If the field value is equal to or greater than the specified value,\n     * an error message is generated.\n     *\n     * ```proto\n     * message MySFixed64 {\n     *   // value must be less than 10\n     *   sfixed64 value = 1 [(buf.validate.field).sfixed64.lt = 10];\n     * }\n     * ```\n     *\n     * @generated from field: sfixed64 lt = 2;\n     */\n    value: bigint;\n    case: \"lt\";\n  } | {\n    /**\n     * `lte` requires the field value to be less than or equal to the specified\n     * value (field <= value). If the field value is greater than the specified\n     * value, an error message is generated.\n     *\n     * ```proto\n     * message MySFixed64 {\n     *   // value must be less than or equal to 10\n     *   sfixed64 value = 1 [(buf.validate.field).sfixed64.lte = 10];\n     * }\n     * ```\n     *\n     * @generated from field: sfixed64 lte = 3;\n     */\n    value: bigint;\n    case: \"lte\";\n  } | { case: undefined; value?: undefined } = { case: undefined };\n\n  /**\n   * @generated from oneof buf.validate.SFixed64Rules.greater_than\n   */\n  greaterThan: {\n    /**\n     * `gt` requires the field value to be greater than the specified value\n     * (exclusive). If the value of `gt` is larger than a specified `lt` or\n     * `lte`, the range is reversed, and the field value must be outside the\n     * specified range. If the field value doesn't meet the required conditions,\n     * an error message is generated.\n     *\n     * ```proto\n     * message MySFixed64 {\n     *   // value must be greater than 5 [sfixed64.gt]\n     *   sfixed64 value = 1 [(buf.validate.field).sfixed64.gt = 5];\n     *\n     *   // value must be greater than 5 and less than 10 [sfixed64.gt_lt]\n     *   sfixed64 other_value = 2 [(buf.validate.field).sfixed64 = { gt: 5, lt: 10 }];\n     *\n     *   // value must be greater than 10 or less than 5 [sfixed64.gt_lt_exclusive]\n     *   sfixed64 another_value = 3 [(buf.validate.field).sfixed64 = { gt: 10, lt: 5 }];\n     * }\n     * ```\n     *\n     * @generated from field: sfixed64 gt = 4;\n     */\n    value: bigint;\n    case: \"gt\";\n  } | {\n    /**\n     * `gte` requires the field value to be greater than or equal to the specified\n     * value (exclusive). If the value of `gte` is larger than a specified `lt`\n     * or `lte`, the range is reversed, and the field value must be outside the\n     * specified range. If the field value doesn't meet the required conditions,\n     * an error message is generated.\n     *\n     * ```proto\n     * message MySFixed64 {\n     *   // value must be greater than or equal to 5 [sfixed64.gte]\n     *   sfixed64 value = 1 [(buf.validate.field).sfixed64.gte = 5];\n     *\n     *   // value must be greater than or equal to 5 and less than 10 [sfixed64.gte_lt]\n     *   sfixed64 other_value = 2 [(buf.validate.field).sfixed64 = { gte: 5, lt: 10 }];\n     *\n     *   // value must be greater than or equal to 10 or less than 5 [sfixed64.gte_lt_exclusive]\n     *   sfixed64 another_value = 3 [(buf.validate.field).sfixed64 = { gte: 10, lt: 5 }];\n     * }\n     * ```\n     *\n     * @generated from field: sfixed64 gte = 5;\n     */\n    value: bigint;\n    case: \"gte\";\n  } | { case: undefined; value?: undefined } = { case: undefined };\n\n  /**\n   * `in` requires the field value to be equal to one of the specified values.\n   * If the field value isn't one of the specified values, an error message is\n   * generated.\n   *\n   * ```proto\n   * message MySFixed64 {\n   *   // value must be in list [1, 2, 3]\n   *   repeated sfixed64 value = 1 (buf.validate.field).sfixed64 = { in: [1, 2, 3] };\n   * }\n   * ```\n   *\n   * @generated from field: repeated sfixed64 in = 6;\n   */\n  in: bigint[] = [];\n\n  /**\n   * `not_in` requires the field value to not be equal to any of the specified\n   * values. If the field value is one of the specified values, an error\n   * message is generated.\n   *\n   * ```proto\n   * message MySFixed64 {\n   *   // value must not be in list [1, 2, 3]\n   *   repeated sfixed64 value = 1 (buf.validate.field).sfixed64 = { not_in: [1, 2, 3] };\n   * }\n   * ```\n   *\n   * @generated from field: repeated sfixed64 not_in = 7;\n   */\n  notIn: bigint[] = [];\n\n  constructor(data?: PartialMessage<SFixed64Rules>) {\n    super();\n    proto3.util.initPartial(data, this);\n  }\n\n  static readonly runtime: typeof proto3 = proto3;\n  static readonly typeName = \"buf.validate.SFixed64Rules\";\n  static readonly fields: FieldList = proto3.util.newFieldList(() => [\n    { no: 1, name: \"const\", kind: \"scalar\", T: 16 /* ScalarType.SFIXED64 */, opt: true },\n    { no: 2, name: \"lt\", kind: \"scalar\", T: 16 /* ScalarType.SFIXED64 */, oneof: \"less_than\" },\n    { no: 3, name: \"lte\", kind: \"scalar\", T: 16 /* ScalarType.SFIXED64 */, oneof: \"less_than\" },\n    { no: 4, name: \"gt\", kind: \"scalar\", T: 16 /* ScalarType.SFIXED64 */, oneof: \"greater_than\" },\n    { no: 5, name: \"gte\", kind: \"scalar\", T: 16 /* ScalarType.SFIXED64 */, oneof: \"greater_than\" },\n    { no: 6, name: \"in\", kind: \"scalar\", T: 16 /* ScalarType.SFIXED64 */, repeated: true },\n    { no: 7, name: \"not_in\", kind: \"scalar\", T: 16 /* ScalarType.SFIXED64 */, repeated: true },\n  ]);\n\n  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SFixed64Rules {\n    return new SFixed64Rules().fromBinary(bytes, options);\n  }\n\n  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SFixed64Rules {\n    return new SFixed64Rules().fromJson(jsonValue, options);\n  }\n\n  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SFixed64Rules {\n    return new SFixed64Rules().fromJsonString(jsonString, options);\n  }\n\n  static equals(a: SFixed64Rules | PlainMessage<SFixed64Rules> | undefined, b: SFixed64Rules | PlainMessage<SFixed64Rules> | undefined): boolean {\n    return proto3.util.equals(SFixed64Rules, a, b);\n  }\n}\n\n/**\n * BoolRules describes the constraints applied to `bool` values. These rules\n * may also be applied to the `google.protobuf.BoolValue` Well-Known-Type.\n *\n * @generated from message buf.validate.BoolRules\n */\nexport class BoolRules extends Message<BoolRules> {\n  /**\n   * `const` requires the field value to exactly match the specified boolean value.\n   * If the field value doesn't match, an error message is generated.\n   *\n   * ```proto\n   * message MyBool {\n   *   // value must equal true\n   *   bool value = 1 [(buf.validate.field).bool.const = true];\n   * }\n   * ```\n   *\n   * @generated from field: optional bool const = 1;\n   */\n  const?: boolean;\n\n  constructor(data?: PartialMessage<BoolRules>) {\n    super();\n    proto3.util.initPartial(data, this);\n  }\n\n  static readonly runtime: typeof proto3 = proto3;\n  static readonly typeName = \"buf.validate.BoolRules\";\n  static readonly fields: FieldList = proto3.util.newFieldList(() => [\n    { no: 1, name: \"const\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, opt: true },\n  ]);\n\n  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BoolRules {\n    return new BoolRules().fromBinary(bytes, options);\n  }\n\n  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BoolRules {\n    return new BoolRules().fromJson(jsonValue, options);\n  }\n\n  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BoolRules {\n    return new BoolRules().fromJsonString(jsonString, options);\n  }\n\n  static equals(a: BoolRules | PlainMessage<BoolRules> | undefined, b: BoolRules | PlainMessage<BoolRules> | undefined): boolean {\n    return proto3.util.equals(BoolRules, a, b);\n  }\n}\n\n/**\n * StringRules describes the constraints applied to `string` values These\n * rules may also be applied to the `google.protobuf.StringValue` Well-Known-Type.\n *\n * @generated from message buf.validate.StringRules\n */\nexport class StringRules extends Message<StringRules> {\n  /**\n   * `const` requires the field value to exactly match the specified value. If\n   * the field value doesn't match, an error message is generated.\n   *\n   * ```proto\n   * message MyString {\n   *   // value must equal `hello`\n   *   string value = 1 [(buf.validate.field).string.const = \"hello\"];\n   * }\n   * ```\n   *\n   * @generated from field: optional string const = 1;\n   */\n  const?: string;\n\n  /**\n   * `len` dictates that the field value must have the specified\n   * number of characters (Unicode code points), which may differ from the number\n   * of bytes in the string. If the field value does not meet the specified\n   * length, an error message will be generated.\n   *\n   * ```proto\n   * message MyString {\n   *   // value length must be 5 characters\n   *   string value = 1 [(buf.validate.field).string.len = 5];\n   * }\n   * ```\n   *\n   * @generated from field: optional uint64 len = 19;\n   */\n  len?: bigint;\n\n  /**\n   * `min_len` specifies that the field value must have at least the specified\n   * number of characters (Unicode code points), which may differ from the number\n   * of bytes in the string. If the field value contains fewer characters, an error\n   * message will be generated.\n   *\n   * ```proto\n   * message MyString {\n   *   // value length must be at least 3 characters\n   *   string value = 1 [(buf.validate.field).string.min_len = 3];\n   * }\n   * ```\n   *\n   * @generated from field: optional uint64 min_len = 2;\n   */\n  minLen?: bigint;\n\n  /**\n   * `max_len` specifies that the field value must have no more than the specified\n   * number of characters (Unicode code points), which may differ from the\n   * number of bytes in the string. If the field value contains more characters,\n   * an error message will be generated.\n   *\n   * ```proto\n   * message MyString {\n   *   // value length must be at most 10 characters\n   *   string value = 1 [(buf.validate.field).string.max_len = 10];\n   * }\n   * ```\n   *\n   * @generated from field: optional uint64 max_len = 3;\n   */\n  maxLen?: bigint;\n\n  /**\n   * `len_bytes` dictates that the field value must have the specified number of\n   * bytes. If the field value does not match the specified length in bytes,\n   * an error message will be generated.\n   *\n   * ```proto\n   * message MyString {\n   *   // value length must be 6 bytes\n   *   string value = 1 [(buf.validate.field).string.len_bytes = 6];\n   * }\n   * ```\n   *\n   * @generated from field: optional uint64 len_bytes = 20;\n   */\n  lenBytes?: bigint;\n\n  /**\n   * `min_bytes` specifies that the field value must have at least the specified\n   * number of bytes. If the field value contains fewer bytes, an error message\n   * will be generated.\n   *\n   * ```proto\n   * message MyString {\n   *   // value length must be at least 4 bytes\n   *   string value = 1 [(buf.validate.field).string.min_bytes = 4];\n   * }\n   *\n   * ```\n   *\n   * @generated from field: optional uint64 min_bytes = 4;\n   */\n  minBytes?: bigint;\n\n  /**\n   * `max_bytes` specifies that the field value must have no more than the\n   * specified number of bytes. If the field value contains more bytes, an\n   * error message will be generated.\n   *\n   * ```proto\n   * message MyString {\n   *   // value length must be at most 8 bytes\n   *   string value = 1 [(buf.validate.field).string.max_bytes = 8];\n   * }\n   * ```\n   *\n   * @generated from field: optional uint64 max_bytes = 5;\n   */\n  maxBytes?: bigint;\n\n  /**\n   * `pattern` specifies that the field value must match the specified\n   * regular expression (RE2 syntax), with the expression provided without any\n   * delimiters. If the field value doesn't match the regular expression, an\n   * error message will be generated.\n   *\n   * ```proto\n   * message MyString {\n   *   // value does not match regex pattern `^[a-zA-Z]//$`\n   *   string value = 1 [(buf.validate.field).string.pattern = \"^[a-zA-Z]//$\"];\n   * }\n   * ```\n   *\n   * @generated from field: optional string pattern = 6;\n   */\n  pattern?: string;\n\n  /**\n   * `prefix` specifies that the field value must have the\n   * specified substring at the beginning of the string. If the field value\n   * doesn't start with the specified prefix, an error message will be\n   * generated.\n   *\n   * ```proto\n   * message MyString {\n   *   // value does not have prefix `pre`\n   *   string value = 1 [(buf.validate.field).string.prefix = \"pre\"];\n   * }\n   * ```\n   *\n   * @generated from field: optional string prefix = 7;\n   */\n  prefix?: string;\n\n  /**\n   * `suffix` specifies that the field value must have the\n   * specified substring at the end of the string. If the field value doesn't\n   * end with the specified suffix, an error message will be generated.\n   *\n   * ```proto\n   * message MyString {\n   *   // value does not have suffix `post`\n   *   string value = 1 [(buf.validate.field).string.suffix = \"post\"];\n   * }\n   * ```\n   *\n   * @generated from field: optional string suffix = 8;\n   */\n  suffix?: string;\n\n  /**\n   * `contains` specifies that the field value must have the\n   * specified substring anywhere in the string. If the field value doesn't\n   * contain the specified substring, an error message will be generated.\n   *\n   * ```proto\n   * message MyString {\n   *   // value does not contain substring `inside`.\n   *   string value = 1 [(buf.validate.field).string.contains = \"inside\"];\n   * }\n   * ```\n   *\n   * @generated from field: optional string contains = 9;\n   */\n  contains?: string;\n\n  /**\n   * `not_contains` specifies that the field value must not have the\n   * specified substring anywhere in the string. If the field value contains\n   * the specified substring, an error message will be generated.\n   *\n   * ```proto\n   * message MyString {\n   *   // value contains substring `inside`.\n   *   string value = 1 [(buf.validate.field).string.not_contains = \"inside\"];\n   * }\n   * ```\n   *\n   * @generated from field: optional string not_contains = 23;\n   */\n  notContains?: string;\n\n  /**\n   * `in` specifies that the field value must be equal to one of the specified\n   * values. If the field value isn't one of the specified values, an error\n   * message will be generated.\n   *\n   * ```proto\n   * message MyString {\n   *   // value must be in list [\"apple\", \"banana\"]\n   *   repeated string value = 1 [(buf.validate.field).string.in = \"apple\", (buf.validate.field).string.in = \"banana\"];\n   * }\n   * ```\n   *\n   * @generated from field: repeated string in = 10;\n   */\n  in: string[] = [];\n\n  /**\n   * `not_in` specifies that the field value cannot be equal to any\n   * of the specified values. If the field value is one of the specified values,\n   * an error message will be generated.\n   * ```proto\n   * message MyString {\n   *   // value must not be in list [\"orange\", \"grape\"]\n   *   repeated string value = 1 [(buf.validate.field).string.not_in = \"orange\", (buf.validate.field).string.not_in = \"grape\"];\n   * }\n   * ```\n   *\n   * @generated from field: repeated string not_in = 11;\n   */\n  notIn: string[] = [];\n\n  /**\n   * `WellKnown` rules provide advanced constraints against common string\n   * patterns\n   *\n   * @generated from oneof buf.validate.StringRules.well_known\n   */\n  wellKnown: {\n    /**\n     * `email` specifies that the field value must be a valid email address\n     * (addr-spec only) as defined by [RFC 5322](https://tools.ietf.org/html/rfc5322#section-3.4.1).\n     * If the field value isn't a valid email address, an error message will be generated.\n     *\n     * ```proto\n     * message MyString {\n     *   // value must be a valid email address\n     *   string value = 1 [(buf.validate.field).string.email = true];\n     * }\n     * ```\n     *\n     * @generated from field: bool email = 12;\n     */\n    value: boolean;\n    case: \"email\";\n  } | {\n    /**\n     * `hostname` specifies that the field value must be a valid\n     * hostname as defined by [RFC 1034](https://tools.ietf.org/html/rfc1034#section-3.5). This constraint doesn't support\n     * internationalized domain names (IDNs). If the field value isn't a\n     * valid hostname, an error message will be generated.\n     *\n     * ```proto\n     * message MyString {\n     *   // value must be a valid hostname\n     *   string value = 1 [(buf.validate.field).string.hostname = true];\n     * }\n     * ```\n     *\n     * @generated from field: bool hostname = 13;\n     */\n    value: boolean;\n    case: \"hostname\";\n  } | {\n    /**\n     * `ip` specifies that the field value must be a valid IP\n     * (v4 or v6) address, without surrounding square brackets for IPv6 addresses.\n     * If the field value isn't a valid IP address, an error message will be\n     * generated.\n     *\n     * ```proto\n     * message MyString {\n     *   // value must be a valid IP address\n     *   string value = 1 [(buf.validate.field).string.ip = true];\n     * }\n     * ```\n     *\n     * @generated from field: bool ip = 14;\n     */\n    value: boolean;\n    case: \"ip\";\n  } | {\n    /**\n     * `ipv4` specifies that the field value must be a valid IPv4\n     * address. If the field value isn't a valid IPv4 address, an error message\n     * will be generated.\n     *\n     * ```proto\n     * message MyString {\n     *   // value must be a valid IPv4 address\n     *   string value = 1 [(buf.validate.field).string.ipv4 = true];\n     * }\n     * ```\n     *\n     * @generated from field: bool ipv4 = 15;\n     */\n    value: boolean;\n    case: \"ipv4\";\n  } | {\n    /**\n     * `ipv6` specifies that the field value must be a valid\n     * IPv6 address, without surrounding square brackets. If the field value is\n     * not a valid IPv6 address, an error message will be generated.\n     *\n     * ```proto\n     * message MyString {\n     *   // value must be a valid IPv6 address\n     *   string value = 1 [(buf.validate.field).string.ipv6 = true];\n     * }\n     * ```\n     *\n     * @generated from field: bool ipv6 = 16;\n     */\n    value: boolean;\n    case: \"ipv6\";\n  } | {\n    /**\n     * `uri` specifies that the field value must be a valid,\n     * absolute URI as defined by [RFC 3986](https://tools.ietf.org/html/rfc3986#section-3). If the field value isn't a valid,\n     * absolute URI, an error message will be generated.\n     *\n     * ```proto\n     * message MyString {\n     *   // value must be a valid URI\n     *   string value = 1 [(buf.validate.field).string.uri = true];\n     * }\n     * ```\n     *\n     * @generated from field: bool uri = 17;\n     */\n    value: boolean;\n    case: \"uri\";\n  } | {\n    /**\n     * `uri_ref` specifies that the field value must be a valid URI\n     * as defined by [RFC 3986](https://tools.ietf.org/html/rfc3986#section-3) and may be either relative or absolute. If the\n     * field value isn't a valid URI, an error message will be generated.\n     *\n     * ```proto\n     * message MyString {\n     *   // value must be a valid URI\n     *   string value = 1 [(buf.validate.field).string.uri_ref = true];\n     * }\n     * ```\n     *\n     * @generated from field: bool uri_ref = 18;\n     */\n    value: boolean;\n    case: \"uriRef\";\n  } | {\n    /**\n     * `address` specifies that the field value must be either a valid hostname\n     * as defined by [RFC 1034](https://tools.ietf.org/html/rfc1034#section-3.5)\n     * (which doesn't support internationalized domain names or IDNs) or a valid\n     * IP (v4 or v6). If the field value isn't a valid hostname or IP, an error\n     * message will be generated.\n     *\n     * ```proto\n     * message MyString {\n     *   // value must be a valid hostname, or ip address\n     *   string value = 1 [(buf.validate.field).string.address = true];\n     * }\n     * ```\n     *\n     * @generated from field: bool address = 21;\n     */\n    value: boolean;\n    case: \"address\";\n  } | {\n    /**\n     * `uuid` specifies that the field value must be a valid UUID as defined by\n     * [RFC 4122](https://tools.ietf.org/html/rfc4122#section-4.1.2). If the\n     * field value isn't a valid UUID, an error message will be generated.\n     *\n     * ```proto\n     * message MyString {\n     *   // value must be a valid UUID\n     *   string value = 1 [(buf.validate.field).string.uuid = true];\n     * }\n     * ```\n     *\n     * @generated from field: bool uuid = 22;\n     */\n    value: boolean;\n    case: \"uuid\";\n  } | {\n    /**\n     * `tuuid` (trimmed UUID) specifies that the field value must be a valid UUID as\n     * defined by [RFC 4122](https://tools.ietf.org/html/rfc4122#section-4.1.2) with all dashes\n     * omitted. If the field value isn't a valid UUID without dashes, an error message\n     * will be generated.\n     *\n     * ```proto\n     * message MyString {\n     *   // value must be a valid trimmed UUID\n     *   string value = 1 [(buf.validate.field).string.tuuid = true];\n     * }\n     * ```\n     *\n     * @generated from field: bool tuuid = 33;\n     */\n    value: boolean;\n    case: \"tuuid\";\n  } | {\n    /**\n     * `ip_with_prefixlen` specifies that the field value must be a valid IP (v4 or v6)\n     * address with prefix length. If the field value isn't a valid IP with prefix\n     * length, an error message will be generated.\n     *\n     *\n     * ```proto\n     * message MyString {\n     *   // value must be a valid IP with prefix length\n     *    string value = 1 [(buf.validate.field).string.ip_with_prefixlen = true];\n     * }\n     * ```\n     *\n     * @generated from field: bool ip_with_prefixlen = 26;\n     */\n    value: boolean;\n    case: \"ipWithPrefixlen\";\n  } | {\n    /**\n     * `ipv4_with_prefixlen` specifies that the field value must be a valid\n     * IPv4 address with prefix.\n     * If the field value isn't a valid IPv4 address with prefix length,\n     * an error message will be generated.\n     *\n     * ```proto\n     * message MyString {\n     *   // value must be a valid IPv4 address with prefix length\n     *    string value = 1 [(buf.validate.field).string.ipv4_with_prefixlen = true];\n     * }\n     * ```\n     *\n     * @generated from field: bool ipv4_with_prefixlen = 27;\n     */\n    value: boolean;\n    case: \"ipv4WithPrefixlen\";\n  } | {\n    /**\n     * `ipv6_with_prefixlen` specifies that the field value must be a valid\n     * IPv6 address with prefix length.\n     * If the field value is not a valid IPv6 address with prefix length,\n     * an error message will be generated.\n     *\n     * ```proto\n     * message MyString {\n     *   // value must be a valid IPv6 address prefix length\n     *    string value = 1 [(buf.validate.field).string.ipv6_with_prefixlen = true];\n     * }\n     * ```\n     *\n     * @generated from field: bool ipv6_with_prefixlen = 28;\n     */\n    value: boolean;\n    case: \"ipv6WithPrefixlen\";\n  } | {\n    /**\n     * `ip_prefix` specifies that the field value must be a valid IP (v4 or v6) prefix.\n     * If the field value isn't a valid IP prefix, an error message will be\n     * generated. The prefix must have all zeros for the masked bits of the prefix (e.g.,\n     * `127.0.0.0/16`, not `127.0.0.1/16`).\n     *\n     * ```proto\n     * message MyString {\n     *   // value must be a valid IP prefix\n     *    string value = 1 [(buf.validate.field).string.ip_prefix = true];\n     * }\n     * ```\n     *\n     * @generated from field: bool ip_prefix = 29;\n     */\n    value: boolean;\n    case: \"ipPrefix\";\n  } | {\n    /**\n     * `ipv4_prefix` specifies that the field value must be a valid IPv4\n     * prefix. If the field value isn't a valid IPv4 prefix, an error message\n     * will be generated. The prefix must have all zeros for the masked bits of\n     * the prefix (e.g., `127.0.0.0/16`, not `127.0.0.1/16`).\n     *\n     * ```proto\n     * message MyString {\n     *   // value must be a valid IPv4 prefix\n     *    string value = 1 [(buf.validate.field).string.ipv4_prefix = true];\n     * }\n     * ```\n     *\n     * @generated from field: bool ipv4_prefix = 30;\n     */\n    value: boolean;\n    case: \"ipv4Prefix\";\n  } | {\n    /**\n     * `ipv6_prefix` specifies that the field value must be a valid IPv6 prefix.\n     * If the field value is not a valid IPv6 prefix, an error message will be\n     * generated. The prefix must have all zeros for the masked bits of the prefix\n     * (e.g., `2001:db8::/48`, not `2001:db8::1/48`).\n     *\n     * ```proto\n     * message MyString {\n     *   // value must be a valid IPv6 prefix\n     *    string value = 1 [(buf.validate.field).string.ipv6_prefix = true];\n     * }\n     * ```\n     *\n     * @generated from field: bool ipv6_prefix = 31;\n     */\n    value: boolean;\n    case: \"ipv6Prefix\";\n  } | {\n    /**\n     * `host_and_port` specifies the field value must be a valid host and port\n     * pair. The host must be a valid hostname or IP address while the port\n     * must be in the range of 0-65535, inclusive. IPv6 addresses must be delimited\n     * with square brackets (e.g., `[::1]:1234`).\n     *\n     * @generated from field: bool host_and_port = 32;\n     */\n    value: boolean;\n    case: \"hostAndPort\";\n  } | {\n    /**\n     * `well_known_regex` specifies a common well-known pattern\n     * defined as a regex. If the field value doesn't match the well-known\n     * regex, an error message will be generated.\n     *\n     * ```proto\n     * message MyString {\n     *   // value must be a valid HTTP header value\n     *   string value = 1 [(buf.validate.field).string.well_known_regex = KNOWN_REGEX_HTTP_HEADER_VALUE];\n     * }\n     * ```\n     *\n     * #### KnownRegex\n     *\n     * `well_known_regex` contains some well-known patterns.\n     *\n     * | Name                          | Number | Description                               |\n     * |-------------------------------|--------|-------------------------------------------|\n     * | KNOWN_REGEX_UNSPECIFIED       | 0      |                                           |\n     * | KNOWN_REGEX_HTTP_HEADER_NAME  | 1      | HTTP header name as defined by [RFC 7230](https://tools.ietf.org/html/rfc7230#section-3.2)  |\n     * | KNOWN_REGEX_HTTP_HEADER_VALUE | 2      | HTTP header value as defined by [RFC 7230](https://tools.ietf.org/html/rfc7230#section-3.2.4) |\n     *\n     * @generated from field: buf.validate.KnownRegex well_known_regex = 24;\n     */\n    value: KnownRegex;\n    case: \"wellKnownRegex\";\n  } | { case: undefined; value?: undefined } = { case: undefined };\n\n  /**\n   * This applies to regexes `HTTP_HEADER_NAME` and `HTTP_HEADER_VALUE` to\n   * enable strict header validation. By default, this is true, and HTTP header\n   * validations are [RFC-compliant](https://tools.ietf.org/html/rfc7230#section-3). Setting to false will enable looser\n   * validations that only disallow `\\r\\n\\0` characters, which can be used to\n   * bypass header matching rules.\n   *\n   * ```proto\n   * message MyString {\n   *   // The field `value` must have be a valid HTTP headers, but not enforced with strict rules.\n   *   string value = 1 [(buf.validate.field).string.strict = false];\n   * }\n   * ```\n   *\n   * @generated from field: optional bool strict = 25;\n   */\n  strict?: boolean;\n\n  constructor(data?: PartialMessage<StringRules>) {\n    super();\n    proto3.util.initPartial(data, this);\n  }\n\n  static readonly runtime: typeof proto3 = proto3;\n  static readonly typeName = \"buf.validate.StringRules\";\n  static readonly fields: FieldList = proto3.util.newFieldList(() => [\n    { no: 1, name: \"const\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 19, name: \"len\", kind: \"scalar\", T: 4 /* ScalarType.UINT64 */, opt: true },\n    { no: 2, name: \"min_len\", kind: \"scalar\", T: 4 /* ScalarType.UINT64 */, opt: true },\n    { no: 3, name: \"max_len\", kind: \"scalar\", T: 4 /* ScalarType.UINT64 */, opt: true },\n    { no: 20, name: \"len_bytes\", kind: \"scalar\", T: 4 /* ScalarType.UINT64 */, opt: true },\n    { no: 4, name: \"min_bytes\", kind: \"scalar\", T: 4 /* ScalarType.UINT64 */, opt: true },\n    { no: 5, name: \"max_bytes\", kind: \"scalar\", T: 4 /* ScalarType.UINT64 */, opt: true },\n    { no: 6, name: \"pattern\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 7, name: \"prefix\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 8, name: \"suffix\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 9, name: \"contains\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 23, name: \"not_contains\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 10, name: \"in\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, repeated: true },\n    { no: 11, name: \"not_in\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, repeated: true },\n    { no: 12, name: \"email\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, oneof: \"well_known\" },\n    { no: 13, name: \"hostname\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, oneof: \"well_known\" },\n    { no: 14, name: \"ip\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, oneof: \"well_known\" },\n    { no: 15, name: \"ipv4\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, oneof: \"well_known\" },\n    { no: 16, name: \"ipv6\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, oneof: \"well_known\" },\n    { no: 17, name: \"uri\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, oneof: \"well_known\" },\n    { no: 18, name: \"uri_ref\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, oneof: \"well_known\" },\n    { no: 21, name: \"address\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, oneof: \"well_known\" },\n    { no: 22, name: \"uuid\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, oneof: \"well_known\" },\n    { no: 33, name: \"tuuid\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, oneof: \"well_known\" },\n    { no: 26, name: \"ip_with_prefixlen\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, oneof: \"well_known\" },\n    { no: 27, name: \"ipv4_with_prefixlen\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, oneof: \"well_known\" },\n    { no: 28, name: \"ipv6_with_prefixlen\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, oneof: \"well_known\" },\n    { no: 29, name: \"ip_prefix\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, oneof: \"well_known\" },\n    { no: 30, name: \"ipv4_prefix\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, oneof: \"well_known\" },\n    { no: 31, name: \"ipv6_prefix\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, oneof: \"well_known\" },\n    { no: 32, name: \"host_and_port\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, oneof: \"well_known\" },\n    { no: 24, name: \"well_known_regex\", kind: \"enum\", T: proto3.getEnumType(KnownRegex), oneof: \"well_known\" },\n    { no: 25, name: \"strict\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, opt: true },\n  ]);\n\n  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringRules {\n    return new StringRules().fromBinary(bytes, options);\n  }\n\n  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringRules {\n    return new StringRules().fromJson(jsonValue, options);\n  }\n\n  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringRules {\n    return new StringRules().fromJsonString(jsonString, options);\n  }\n\n  static equals(a: StringRules | PlainMessage<StringRules> | undefined, b: StringRules | PlainMessage<StringRules> | undefined): boolean {\n    return proto3.util.equals(StringRules, a, b);\n  }\n}\n\n/**\n * BytesRules describe the constraints applied to `bytes` values. These rules\n * may also be applied to the `google.protobuf.BytesValue` Well-Known-Type.\n *\n * @generated from message buf.validate.BytesRules\n */\nexport class BytesRules extends Message<BytesRules> {\n  /**\n   * `const` requires the field value to exactly match the specified bytes\n   * value. If the field value doesn't match, an error message is generated.\n   *\n   * ```proto\n   * message MyBytes {\n   *   // value must be \"\\x01\\x02\\x03\\x04\"\n   *   bytes value = 1 [(buf.validate.field).bytes.const = \"\\x01\\x02\\x03\\x04\"];\n   * }\n   * ```\n   *\n   * @generated from field: optional bytes const = 1;\n   */\n  const?: Uint8Array;\n\n  /**\n   * `len` requires the field value to have the specified length in bytes.\n   * If the field value doesn't match, an error message is generated.\n   *\n   * ```proto\n   * message MyBytes {\n   *   // value length must be 4 bytes.\n   *   optional bytes value = 1 [(buf.validate.field).bytes.len = 4];\n   * }\n   * ```\n   *\n   * @generated from field: optional uint64 len = 13;\n   */\n  len?: bigint;\n\n  /**\n   * `min_len` requires the field value to have at least the specified minimum\n   * length in bytes.\n   * If the field value doesn't meet the requirement, an error message is generated.\n   *\n   * ```proto\n   * message MyBytes {\n   *   // value length must be at least 2 bytes.\n   *   optional bytes value = 1 [(buf.validate.field).bytes.min_len = 2];\n   * }\n   * ```\n   *\n   * @generated from field: optional uint64 min_len = 2;\n   */\n  minLen?: bigint;\n\n  /**\n   * `max_len` requires the field value to have at most the specified maximum\n   * length in bytes.\n   * If the field value exceeds the requirement, an error message is generated.\n   *\n   * ```proto\n   * message MyBytes {\n   *   // value must be at most 6 bytes.\n   *   optional bytes value = 1 [(buf.validate.field).bytes.max_len = 6];\n   * }\n   * ```\n   *\n   * @generated from field: optional uint64 max_len = 3;\n   */\n  maxLen?: bigint;\n\n  /**\n   * `pattern` requires the field value to match the specified regular\n   * expression ([RE2 syntax](https://github.com/google/re2/wiki/Syntax)).\n   * The value of the field must be valid UTF-8 or validation will fail with a\n   * runtime error.\n   * If the field value doesn't match the pattern, an error message is generated.\n   *\n   * ```proto\n   * message MyBytes {\n   *   // value must match regex pattern \"^[a-zA-Z0-9]+$\".\n   *   optional bytes value = 1 [(buf.validate.field).bytes.pattern = \"^[a-zA-Z0-9]+$\"];\n   * }\n   * ```\n   *\n   * @generated from field: optional string pattern = 4;\n   */\n  pattern?: string;\n\n  /**\n   * `prefix` requires the field value to have the specified bytes at the\n   * beginning of the string.\n   * If the field value doesn't meet the requirement, an error message is generated.\n   *\n   * ```proto\n   * message MyBytes {\n   *   // value does not have prefix \\x01\\x02\n   *   optional bytes value = 1 [(buf.validate.field).bytes.prefix = \"\\x01\\x02\"];\n   * }\n   * ```\n   *\n   * @generated from field: optional bytes prefix = 5;\n   */\n  prefix?: Uint8Array;\n\n  /**\n   * `suffix` requires the field value to have the specified bytes at the end\n   * of the string.\n   * If the field value doesn't meet the requirement, an error message is generated.\n   *\n   * ```proto\n   * message MyBytes {\n   *   // value does not have suffix \\x03\\x04\n   *   optional bytes value = 1 [(buf.validate.field).bytes.suffix = \"\\x03\\x04\"];\n   * }\n   * ```\n   *\n   * @generated from field: optional bytes suffix = 6;\n   */\n  suffix?: Uint8Array;\n\n  /**\n   * `contains` requires the field value to have the specified bytes anywhere in\n   * the string.\n   * If the field value doesn't meet the requirement, an error message is generated.\n   *\n   * ```protobuf\n   * message MyBytes {\n   *   // value does not contain \\x02\\x03\n   *   optional bytes value = 1 [(buf.validate.field).bytes.contains = \"\\x02\\x03\"];\n   * }\n   * ```\n   *\n   * @generated from field: optional bytes contains = 7;\n   */\n  contains?: Uint8Array;\n\n  /**\n   * `in` requires the field value to be equal to one of the specified\n   * values. If the field value doesn't match any of the specified values, an\n   * error message is generated.\n   *\n   * ```protobuf\n   * message MyBytes {\n   *   // value must in [\"\\x01\\x02\", \"\\x02\\x03\", \"\\x03\\x04\"]\n   *   optional bytes value = 1 [(buf.validate.field).bytes.in = {\"\\x01\\x02\", \"\\x02\\x03\", \"\\x03\\x04\"}];\n   * }\n   * ```\n   *\n   * @generated from field: repeated bytes in = 8;\n   */\n  in: Uint8Array[] = [];\n\n  /**\n   * `not_in` requires the field value to be not equal to any of the specified\n   * values.\n   * If the field value matches any of the specified values, an error message is\n   * generated.\n   *\n   * ```proto\n   * message MyBytes {\n   *   // value must not in [\"\\x01\\x02\", \"\\x02\\x03\", \"\\x03\\x04\"]\n   *   optional bytes value = 1 [(buf.validate.field).bytes.not_in = {\"\\x01\\x02\", \"\\x02\\x03\", \"\\x03\\x04\"}];\n   * }\n   * ```\n   *\n   * @generated from field: repeated bytes not_in = 9;\n   */\n  notIn: Uint8Array[] = [];\n\n  /**\n   * WellKnown rules provide advanced constraints against common byte\n   * patterns\n   *\n   * @generated from oneof buf.validate.BytesRules.well_known\n   */\n  wellKnown: {\n    /**\n     * `ip` ensures that the field `value` is a valid IP address (v4 or v6) in byte format.\n     * If the field value doesn't meet this constraint, an error message is generated.\n     *\n     * ```proto\n     * message MyBytes {\n     *   // value must be a valid IP address\n     *   optional bytes value = 1 [(buf.validate.field).bytes.ip = true];\n     * }\n     * ```\n     *\n     * @generated from field: bool ip = 10;\n     */\n    value: boolean;\n    case: \"ip\";\n  } | {\n    /**\n     * `ipv4` ensures that the field `value` is a valid IPv4 address in byte format.\n     * If the field value doesn't meet this constraint, an error message is generated.\n     *\n     * ```proto\n     * message MyBytes {\n     *   // value must be a valid IPv4 address\n     *   optional bytes value = 1 [(buf.validate.field).bytes.ipv4 = true];\n     * }\n     * ```\n     *\n     * @generated from field: bool ipv4 = 11;\n     */\n    value: boolean;\n    case: \"ipv4\";\n  } | {\n    /**\n     * `ipv6` ensures that the field `value` is a valid IPv6 address in byte format.\n     * If the field value doesn't meet this constraint, an error message is generated.\n     * ```proto\n     * message MyBytes {\n     *   // value must be a valid IPv6 address\n     *   optional bytes value = 1 [(buf.validate.field).bytes.ipv6 = true];\n     * }\n     * ```\n     *\n     * @generated from field: bool ipv6 = 12;\n     */\n    value: boolean;\n    case: \"ipv6\";\n  } | { case: undefined; value?: undefined } = { case: undefined };\n\n  constructor(data?: PartialMessage<BytesRules>) {\n    super();\n    proto3.util.initPartial(data, this);\n  }\n\n  static readonly runtime: typeof proto3 = proto3;\n  static readonly typeName = \"buf.validate.BytesRules\";\n  static readonly fields: FieldList = proto3.util.newFieldList(() => [\n    { no: 1, name: \"const\", kind: \"scalar\", T: 12 /* ScalarType.BYTES */, opt: true },\n    { no: 13, name: \"len\", kind: \"scalar\", T: 4 /* ScalarType.UINT64 */, opt: true },\n    { no: 2, name: \"min_len\", kind: \"scalar\", T: 4 /* ScalarType.UINT64 */, opt: true },\n    { no: 3, name: \"max_len\", kind: \"scalar\", T: 4 /* ScalarType.UINT64 */, opt: true },\n    { no: 4, name: \"pattern\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, opt: true },\n    { no: 5, name: \"prefix\", kind: \"scalar\", T: 12 /* ScalarType.BYTES */, opt: true },\n    { no: 6, name: \"suffix\", kind: \"scalar\", T: 12 /* ScalarType.BYTES */, opt: true },\n    { no: 7, name: \"contains\", kind: \"scalar\", T: 12 /* ScalarType.BYTES */, opt: true },\n    { no: 8, name: \"in\", kind: \"scalar\", T: 12 /* ScalarType.BYTES */, repeated: true },\n    { no: 9, name: \"not_in\", kind: \"scalar\", T: 12 /* ScalarType.BYTES */, repeated: true },\n    { no: 10, name: \"ip\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, oneof: \"well_known\" },\n    { no: 11, name: \"ipv4\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, oneof: \"well_known\" },\n    { no: 12, name: \"ipv6\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, oneof: \"well_known\" },\n  ]);\n\n  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BytesRules {\n    return new BytesRules().fromBinary(bytes, options);\n  }\n\n  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BytesRules {\n    return new BytesRules().fromJson(jsonValue, options);\n  }\n\n  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BytesRules {\n    return new BytesRules().fromJsonString(jsonString, options);\n  }\n\n  static equals(a: BytesRules | PlainMessage<BytesRules> | undefined, b: BytesRules | PlainMessage<BytesRules> | undefined): boolean {\n    return proto3.util.equals(BytesRules, a, b);\n  }\n}\n\n/**\n * EnumRules describe the constraints applied to `enum` values.\n *\n * @generated from message buf.validate.EnumRules\n */\nexport class EnumRules extends Message<EnumRules> {\n  /**\n   * `const` requires the field value to exactly match the specified enum value.\n   * If the field value doesn't match, an error message is generated.\n   *\n   * ```proto\n   * enum MyEnum {\n   *   MY_ENUM_UNSPECIFIED = 0;\n   *   MY_ENUM_VALUE1 = 1;\n   *   MY_ENUM_VALUE2 = 2;\n   * }\n   *\n   * message MyMessage {\n   *   // The field `value` must be exactly MY_ENUM_VALUE1.\n   *   MyEnum value = 1 [(buf.validate.field).enum.const = 1];\n   * }\n   * ```\n   *\n   * @generated from field: optional int32 const = 1;\n   */\n  const?: number;\n\n  /**\n   * `defined_only` requires the field value to be one of the defined values for\n   * this enum, failing on any undefined value.\n   *\n   * ```proto\n   * enum MyEnum {\n   *   MY_ENUM_UNSPECIFIED = 0;\n   *   MY_ENUM_VALUE1 = 1;\n   *   MY_ENUM_VALUE2 = 2;\n   * }\n   *\n   * message MyMessage {\n   *   // The field `value` must be a defined value of MyEnum.\n   *   MyEnum value = 1 [(buf.validate.field).enum.defined_only = true];\n   * }\n   * ```\n   *\n   * @generated from field: optional bool defined_only = 2;\n   */\n  definedOnly?: boolean;\n\n  /**\n   * `in` requires the field value to be equal to one of the\n   * specified enum values. If the field value doesn't match any of the\n   * specified values, an error message is generated.\n   *\n   * ```proto\n   * enum MyEnum {\n   *   MY_ENUM_UNSPECIFIED = 0;\n   *   MY_ENUM_VALUE1 = 1;\n   *   MY_ENUM_VALUE2 = 2;\n   * }\n   *\n   * message MyMessage {\n   *   // The field `value` must be equal to one of the specified values.\n   *   MyEnum value = 1 [(buf.validate.field).enum = { in: [1, 2]}];\n   * }\n   * ```\n   *\n   * @generated from field: repeated int32 in = 3;\n   */\n  in: number[] = [];\n\n  /**\n   * `not_in` requires the field value to be not equal to any of the\n   * specified enum values. If the field value matches one of the specified\n   * values, an error message is generated.\n   *\n   * ```proto\n   * enum MyEnum {\n   *   MY_ENUM_UNSPECIFIED = 0;\n   *   MY_ENUM_VALUE1 = 1;\n   *   MY_ENUM_VALUE2 = 2;\n   * }\n   *\n   * message MyMessage {\n   *   // The field `value` must not be equal to any of the specified values.\n   *   MyEnum value = 1 [(buf.validate.field).enum = { not_in: [1, 2]}];\n   * }\n   * ```\n   *\n   * @generated from field: repeated int32 not_in = 4;\n   */\n  notIn: number[] = [];\n\n  constructor(data?: PartialMessage<EnumRules>) {\n    super();\n    proto3.util.initPartial(data, this);\n  }\n\n  static readonly runtime: typeof proto3 = proto3;\n  static readonly typeName = \"buf.validate.EnumRules\";\n  static readonly fields: FieldList = proto3.util.newFieldList(() => [\n    { no: 1, name: \"const\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */, opt: true },\n    { no: 2, name: \"defined_only\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, opt: true },\n    { no: 3, name: \"in\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */, repeated: true },\n    { no: 4, name: \"not_in\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */, repeated: true },\n  ]);\n\n  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnumRules {\n    return new EnumRules().fromBinary(bytes, options);\n  }\n\n  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnumRules {\n    return new EnumRules().fromJson(jsonValue, options);\n  }\n\n  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnumRules {\n    return new EnumRules().fromJsonString(jsonString, options);\n  }\n\n  static equals(a: EnumRules | PlainMessage<EnumRules> | undefined, b: EnumRules | PlainMessage<EnumRules> | undefined): boolean {\n    return proto3.util.equals(EnumRules, a, b);\n  }\n}\n\n/**\n * RepeatedRules describe the constraints applied to `repeated` values.\n *\n * @generated from message buf.validate.RepeatedRules\n */\nexport class RepeatedRules extends Message<RepeatedRules> {\n  /**\n   * `min_items` requires that this field must contain at least the specified\n   * minimum number of items.\n   *\n   * Note that `min_items = 1` is equivalent to setting a field as `required`.\n   *\n   * ```proto\n   * message MyRepeated {\n   *   // value must contain at least  2 items\n   *   repeated string value = 1 [(buf.validate.field).repeated.min_items = 2];\n   * }\n   * ```\n   *\n   * @generated from field: optional uint64 min_items = 1;\n   */\n  minItems?: bigint;\n\n  /**\n   * `max_items` denotes that this field must not exceed a\n   * certain number of items as the upper limit. If the field contains more\n   * items than specified, an error message will be generated, requiring the\n   * field to maintain no more than the specified number of items.\n   *\n   * ```proto\n   * message MyRepeated {\n   *   // value must contain no more than 3 item(s)\n   *   repeated string value = 1 [(buf.validate.field).repeated.max_items = 3];\n   * }\n   * ```\n   *\n   * @generated from field: optional uint64 max_items = 2;\n   */\n  maxItems?: bigint;\n\n  /**\n   * `unique` indicates that all elements in this field must\n   * be unique. This constraint is strictly applicable to scalar and enum\n   * types, with message types not being supported.\n   *\n   * ```proto\n   * message MyRepeated {\n   *   // repeated value must contain unique items\n   *   repeated string value = 1 [(buf.validate.field).repeated.unique = true];\n   * }\n   * ```\n   *\n   * @generated from field: optional bool unique = 3;\n   */\n  unique?: boolean;\n\n  /**\n   * `items` details the constraints to be applied to each item\n   * in the field. Even for repeated message fields, validation is executed\n   * against each item unless skip is explicitly specified.\n   *\n   * ```proto\n   * message MyRepeated {\n   *   // The items in the field `value` must follow the specified constraints.\n   *   repeated string value = 1 [(buf.validate.field).repeated.items = {\n   *     string: {\n   *       min_len: 3\n   *       max_len: 10\n   *     }\n   *   }];\n   * }\n   * ```\n   *\n   * @generated from field: optional buf.validate.FieldConstraints items = 4;\n   */\n  items?: FieldConstraints;\n\n  constructor(data?: PartialMessage<RepeatedRules>) {\n    super();\n    proto3.util.initPartial(data, this);\n  }\n\n  static readonly runtime: typeof proto3 = proto3;\n  static readonly typeName = \"buf.validate.RepeatedRules\";\n  static readonly fields: FieldList = proto3.util.newFieldList(() => [\n    { no: 1, name: \"min_items\", kind: \"scalar\", T: 4 /* ScalarType.UINT64 */, opt: true },\n    { no: 2, name: \"max_items\", kind: \"scalar\", T: 4 /* ScalarType.UINT64 */, opt: true },\n    { no: 3, name: \"unique\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, opt: true },\n    { no: 4, name: \"items\", kind: \"message\", T: FieldConstraints, opt: true },\n  ]);\n\n  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepeatedRules {\n    return new RepeatedRules().fromBinary(bytes, options);\n  }\n\n  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepeatedRules {\n    return new RepeatedRules().fromJson(jsonValue, options);\n  }\n\n  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepeatedRules {\n    return new RepeatedRules().fromJsonString(jsonString, options);\n  }\n\n  static equals(a: RepeatedRules | PlainMessage<RepeatedRules> | undefined, b: RepeatedRules | PlainMessage<RepeatedRules> | undefined): boolean {\n    return proto3.util.equals(RepeatedRules, a, b);\n  }\n}\n\n/**\n * MapRules describe the constraints applied to `map` values.\n *\n * @generated from message buf.validate.MapRules\n */\nexport class MapRules extends Message<MapRules> {\n  /**\n   * Specifies the minimum number of key-value pairs allowed. If the field has\n   * fewer key-value pairs than specified, an error message is generated.\n   *\n   * ```proto\n   * message MyMap {\n   *   // The field `value` must have at least 2 key-value pairs.\n   *   map<string, string> value = 1 [(buf.validate.field).map.min_pairs = 2];\n   * }\n   * ```\n   *\n   * @generated from field: optional uint64 min_pairs = 1;\n   */\n  minPairs?: bigint;\n\n  /**\n   * Specifies the maximum number of key-value pairs allowed. If the field has\n   * more key-value pairs than specified, an error message is generated.\n   *\n   * ```proto\n   * message MyMap {\n   *   // The field `value` must have at most 3 key-value pairs.\n   *   map<string, string> value = 1 [(buf.validate.field).map.max_pairs = 3];\n   * }\n   * ```\n   *\n   * @generated from field: optional uint64 max_pairs = 2;\n   */\n  maxPairs?: bigint;\n\n  /**\n   * Specifies the constraints to be applied to each key in the field.\n   *\n   * ```proto\n   * message MyMap {\n   *   // The keys in the field `value` must follow the specified constraints.\n   *   map<string, string> value = 1 [(buf.validate.field).map.keys = {\n   *     string: {\n   *       min_len: 3\n   *       max_len: 10\n   *     }\n   *   }];\n   * }\n   * ```\n   *\n   * @generated from field: optional buf.validate.FieldConstraints keys = 4;\n   */\n  keys?: FieldConstraints;\n\n  /**\n   * Specifies the constraints to be applied to the value of each key in the\n   * field. Message values will still have their validations evaluated unless\n   * skip is specified here.\n   *\n   * ```proto\n   * message MyMap {\n   *   // The values in the field `value` must follow the specified constraints.\n   *   map<string, string> value = 1 [(buf.validate.field).map.values = {\n   *     string: {\n   *       min_len: 5\n   *       max_len: 20\n   *     }\n   *   }];\n   * }\n   * ```\n   *\n   * @generated from field: optional buf.validate.FieldConstraints values = 5;\n   */\n  values?: FieldConstraints;\n\n  constructor(data?: PartialMessage<MapRules>) {\n    super();\n    proto3.util.initPartial(data, this);\n  }\n\n  static readonly runtime: typeof proto3 = proto3;\n  static readonly typeName = \"buf.validate.MapRules\";\n  static readonly fields: FieldList = proto3.util.newFieldList(() => [\n    { no: 1, name: \"min_pairs\", kind: \"scalar\", T: 4 /* ScalarType.UINT64 */, opt: true },\n    { no: 2, name: \"max_pairs\", kind: \"scalar\", T: 4 /* ScalarType.UINT64 */, opt: true },\n    { no: 4, name: \"keys\", kind: \"message\", T: FieldConstraints, opt: true },\n    { no: 5, name: \"values\", kind: \"message\", T: FieldConstraints, opt: true },\n  ]);\n\n  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapRules {\n    return new MapRules().fromBinary(bytes, options);\n  }\n\n  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapRules {\n    return new MapRules().fromJson(jsonValue, options);\n  }\n\n  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapRules {\n    return new MapRules().fromJsonString(jsonString, options);\n  }\n\n  static equals(a: MapRules | PlainMessage<MapRules> | undefined, b: MapRules | PlainMessage<MapRules> | undefined): boolean {\n    return proto3.util.equals(MapRules, a, b);\n  }\n}\n\n/**\n * AnyRules describe constraints applied exclusively to the `google.protobuf.Any` well-known type.\n *\n * @generated from message buf.validate.AnyRules\n */\nexport class AnyRules extends Message<AnyRules> {\n  /**\n   * `in` requires the field's `type_url` to be equal to one of the\n   * specified values. If it doesn't match any of the specified values, an error\n   * message is generated.\n   *\n   * ```proto\n   * message MyAny {\n   *   //  The `value` field must have a `type_url` equal to one of the specified values.\n   *   google.protobuf.Any value = 1 [(buf.validate.field).any.in = [\"type.googleapis.com/MyType1\", \"type.googleapis.com/MyType2\"]];\n   * }\n   * ```\n   *\n   * @generated from field: repeated string in = 2;\n   */\n  in: string[] = [];\n\n  /**\n   * requires the field's type_url to be not equal to any of the specified values. If it matches any of the specified values, an error message is generated.\n   *\n   * ```proto\n   * message MyAny {\n   *   // The field `value` must not have a `type_url` equal to any of the specified values.\n   *   google.protobuf.Any value = 1 [(buf.validate.field).any.not_in = [\"type.googleapis.com/ForbiddenType1\", \"type.googleapis.com/ForbiddenType2\"]];\n   * }\n   * ```\n   *\n   * @generated from field: repeated string not_in = 3;\n   */\n  notIn: string[] = [];\n\n  constructor(data?: PartialMessage<AnyRules>) {\n    super();\n    proto3.util.initPartial(data, this);\n  }\n\n  static readonly runtime: typeof proto3 = proto3;\n  static readonly typeName = \"buf.validate.AnyRules\";\n  static readonly fields: FieldList = proto3.util.newFieldList(() => [\n    { no: 2, name: \"in\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, repeated: true },\n    { no: 3, name: \"not_in\", kind: \"scalar\", T: 9 /* ScalarType.STRING */, repeated: true },\n  ]);\n\n  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnyRules {\n    return new AnyRules().fromBinary(bytes, options);\n  }\n\n  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnyRules {\n    return new AnyRules().fromJson(jsonValue, options);\n  }\n\n  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnyRules {\n    return new AnyRules().fromJsonString(jsonString, options);\n  }\n\n  static equals(a: AnyRules | PlainMessage<AnyRules> | undefined, b: AnyRules | PlainMessage<AnyRules> | undefined): boolean {\n    return proto3.util.equals(AnyRules, a, b);\n  }\n}\n\n/**\n * DurationRules describe the constraints applied exclusively to the `google.protobuf.Duration` well-known type.\n *\n * @generated from message buf.validate.DurationRules\n */\nexport class DurationRules extends Message<DurationRules> {\n  /**\n   * `const` dictates that the field must match the specified value of the `google.protobuf.Duration` type exactly.\n   * If the field's value deviates from the specified value, an error message\n   * will be generated.\n   *\n   * ```proto\n   * message MyDuration {\n   *   // value must equal 5s\n   *   google.protobuf.Duration value = 1 [(buf.validate.field).duration.const = \"5s\"];\n   * }\n   * ```\n   *\n   * @generated from field: optional google.protobuf.Duration const = 2;\n   */\n  const?: Duration;\n\n  /**\n   * @generated from oneof buf.validate.DurationRules.less_than\n   */\n  lessThan: {\n    /**\n     * `lt` stipulates that the field must be less than the specified value of the `google.protobuf.Duration` type,\n     * exclusive. If the field's value is greater than or equal to the specified\n     * value, an error message will be generated.\n     *\n     * ```proto\n     * message MyDuration {\n     *   // value must be less than 5s\n     *   google.protobuf.Duration value = 1 [(buf.validate.field).duration.lt = \"5s\"];\n     * }\n     * ```\n     *\n     * @generated from field: google.protobuf.Duration lt = 3;\n     */\n    value: Duration;\n    case: \"lt\";\n  } | {\n    /**\n     * `lte` indicates that the field must be less than or equal to the specified\n     * value of the `google.protobuf.Duration` type, inclusive. If the field's value is greater than the specified value,\n     * an error message will be generated.\n     *\n     * ```proto\n     * message MyDuration {\n     *   // value must be less than or equal to 10s\n     *   google.protobuf.Duration value = 1 [(buf.validate.field).duration.lte = \"10s\"];\n     * }\n     * ```\n     *\n     * @generated from field: google.protobuf.Duration lte = 4;\n     */\n    value: Duration;\n    case: \"lte\";\n  } | { case: undefined; value?: undefined } = { case: undefined };\n\n  /**\n   * @generated from oneof buf.validate.DurationRules.greater_than\n   */\n  greaterThan: {\n    /**\n     * `gt` requires the duration field value to be greater than the specified\n     * value (exclusive). If the value of `gt` is larger than a specified `lt`\n     * or `lte`, the range is reversed, and the field value must be outside the\n     * specified range. If the field value doesn't meet the required conditions,\n     * an error message is generated.\n     *\n     * ```proto\n     * message MyDuration {\n     *   // duration must be greater than 5s [duration.gt]\n     *   google.protobuf.Duration value = 1 [(buf.validate.field).duration.gt = { seconds: 5 }];\n     *\n     *   // duration must be greater than 5s and less than 10s [duration.gt_lt]\n     *   google.protobuf.Duration another_value = 2 [(buf.validate.field).duration = { gt: { seconds: 5 }, lt: { seconds: 10 } }];\n     *\n     *   // duration must be greater than 10s or less than 5s [duration.gt_lt_exclusive]\n     *   google.protobuf.Duration other_value = 3 [(buf.validate.field).duration = { gt: { seconds: 10 }, lt: { seconds: 5 } }];\n     * }\n     * ```\n     *\n     * @generated from field: google.protobuf.Duration gt = 5;\n     */\n    value: Duration;\n    case: \"gt\";\n  } | {\n    /**\n     * `gte` requires the duration field value to be greater than or equal to the\n     * specified value (exclusive). If the value of `gte` is larger than a\n     * specified `lt` or `lte`, the range is reversed, and the field value must\n     * be outside the specified range. If the field value doesn't meet the\n     * required conditions, an error message is generated.\n     *\n     * ```proto\n     * message MyDuration {\n     *  // duration must be greater than or equal to 5s [duration.gte]\n     *  google.protobuf.Duration value = 1 [(buf.validate.field).duration.gte = { seconds: 5 }];\n     *\n     *  // duration must be greater than or equal to 5s and less than 10s [duration.gte_lt]\n     *  google.protobuf.Duration another_value = 2 [(buf.validate.field).duration = { gte: { seconds: 5 }, lt: { seconds: 10 } }];\n     *\n     *  // duration must be greater than or equal to 10s or less than 5s [duration.gte_lt_exclusive]\n     *  google.protobuf.Duration other_value = 3 [(buf.validate.field).duration = { gte: { seconds: 10 }, lt: { seconds: 5 } }];\n     * }\n     * ```\n     *\n     * @generated from field: google.protobuf.Duration gte = 6;\n     */\n    value: Duration;\n    case: \"gte\";\n  } | { case: undefined; value?: undefined } = { case: undefined };\n\n  /**\n   * `in` asserts that the field must be equal to one of the specified values of the `google.protobuf.Duration` type.\n   * If the field's value doesn't correspond to any of the specified values,\n   * an error message will be generated.\n   *\n   * ```proto\n   * message MyDuration {\n   *   // value must be in list [1s, 2s, 3s]\n   *   google.protobuf.Duration value = 1 [(buf.validate.field).duration.in = [\"1s\", \"2s\", \"3s\"]];\n   * }\n   * ```\n   *\n   * @generated from field: repeated google.protobuf.Duration in = 7;\n   */\n  in: Duration[] = [];\n\n  /**\n   * `not_in` denotes that the field must not be equal to\n   * any of the specified values of the `google.protobuf.Duration` type.\n   * If the field's value matches any of these values, an error message will be\n   * generated.\n   *\n   * ```proto\n   * message MyDuration {\n   *   // value must not be in list [1s, 2s, 3s]\n   *   google.protobuf.Duration value = 1 [(buf.validate.field).duration.not_in = [\"1s\", \"2s\", \"3s\"]];\n   * }\n   * ```\n   *\n   * @generated from field: repeated google.protobuf.Duration not_in = 8;\n   */\n  notIn: Duration[] = [];\n\n  constructor(data?: PartialMessage<DurationRules>) {\n    super();\n    proto3.util.initPartial(data, this);\n  }\n\n  static readonly runtime: typeof proto3 = proto3;\n  static readonly typeName = \"buf.validate.DurationRules\";\n  static readonly fields: FieldList = proto3.util.newFieldList(() => [\n    { no: 2, name: \"const\", kind: \"message\", T: Duration, opt: true },\n    { no: 3, name: \"lt\", kind: \"message\", T: Duration, oneof: \"less_than\" },\n    { no: 4, name: \"lte\", kind: \"message\", T: Duration, oneof: \"less_than\" },\n    { no: 5, name: \"gt\", kind: \"message\", T: Duration, oneof: \"greater_than\" },\n    { no: 6, name: \"gte\", kind: \"message\", T: Duration, oneof: \"greater_than\" },\n    { no: 7, name: \"in\", kind: \"message\", T: Duration, repeated: true },\n    { no: 8, name: \"not_in\", kind: \"message\", T: Duration, repeated: true },\n  ]);\n\n  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DurationRules {\n    return new DurationRules().fromBinary(bytes, options);\n  }\n\n  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DurationRules {\n    return new DurationRules().fromJson(jsonValue, options);\n  }\n\n  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DurationRules {\n    return new DurationRules().fromJsonString(jsonString, options);\n  }\n\n  static equals(a: DurationRules | PlainMessage<DurationRules> | undefined, b: DurationRules | PlainMessage<DurationRules> | undefined): boolean {\n    return proto3.util.equals(DurationRules, a, b);\n  }\n}\n\n/**\n * TimestampRules describe the constraints applied exclusively to the `google.protobuf.Timestamp` well-known type.\n *\n * @generated from message buf.validate.TimestampRules\n */\nexport class TimestampRules extends Message<TimestampRules> {\n  /**\n   * `const` dictates that this field, of the `google.protobuf.Timestamp` type, must exactly match the specified value. If the field value doesn't correspond to the specified timestamp, an error message will be generated.\n   *\n   * ```proto\n   * message MyTimestamp {\n   *   // value must equal 2023-05-03T10:00:00Z\n   *   google.protobuf.Timestamp created_at = 1 [(buf.validate.field).timestamp.const = {seconds: 1727998800}];\n   * }\n   * ```\n   *\n   * @generated from field: optional google.protobuf.Timestamp const = 2;\n   */\n  const?: Timestamp;\n\n  /**\n   * @generated from oneof buf.validate.TimestampRules.less_than\n   */\n  lessThan: {\n    /**\n     * requires the duration field value to be less than the specified value (field < value). If the field value doesn't meet the required conditions, an error message is generated.\n     *\n     * ```proto\n     * message MyDuration {\n     *   // duration must be less than 'P3D' [duration.lt]\n     *   google.protobuf.Duration value = 1 [(buf.validate.field).duration.lt = { seconds: 259200 }];\n     * }\n     * ```\n     *\n     * @generated from field: google.protobuf.Timestamp lt = 3;\n     */\n    value: Timestamp;\n    case: \"lt\";\n  } | {\n    /**\n     * requires the timestamp field value to be less than or equal to the specified value (field <= value). If the field value doesn't meet the required conditions, an error message is generated.\n     *\n     * ```proto\n     * message MyTimestamp {\n     *   // timestamp must be less than or equal to '2023-05-14T00:00:00Z' [timestamp.lte]\n     *   google.protobuf.Timestamp value = 1 [(buf.validate.field).timestamp.lte = { seconds: 1678867200 }];\n     * }\n     * ```\n     *\n     * @generated from field: google.protobuf.Timestamp lte = 4;\n     */\n    value: Timestamp;\n    case: \"lte\";\n  } | {\n    /**\n     * `lt_now` specifies that this field, of the `google.protobuf.Timestamp` type, must be less than the current time. `lt_now` can only be used with the `within` rule.\n     *\n     * ```proto\n     * message MyTimestamp {\n     *  // value must be less than now\n     *   google.protobuf.Timestamp created_at = 1 [(buf.validate.field).timestamp.lt_now = true];\n     * }\n     * ```\n     *\n     * @generated from field: bool lt_now = 7;\n     */\n    value: boolean;\n    case: \"ltNow\";\n  } | { case: undefined; value?: undefined } = { case: undefined };\n\n  /**\n   * @generated from oneof buf.validate.TimestampRules.greater_than\n   */\n  greaterThan: {\n    /**\n     * `gt` requires the timestamp field value to be greater than the specified\n     * value (exclusive). If the value of `gt` is larger than a specified `lt`\n     * or `lte`, the range is reversed, and the field value must be outside the\n     * specified range. If the field value doesn't meet the required conditions,\n     * an error message is generated.\n     *\n     * ```proto\n     * message MyTimestamp {\n     *   // timestamp must be greater than '2023-01-01T00:00:00Z' [timestamp.gt]\n     *   google.protobuf.Timestamp value = 1 [(buf.validate.field).timestamp.gt = { seconds: 1672444800 }];\n     *\n     *   // timestamp must be greater than '2023-01-01T00:00:00Z' and less than '2023-01-02T00:00:00Z' [timestamp.gt_lt]\n     *   google.protobuf.Timestamp another_value = 2 [(buf.validate.field).timestamp = { gt: { seconds: 1672444800 }, lt: { seconds: 1672531200 } }];\n     *\n     *   // timestamp must be greater than '2023-01-02T00:00:00Z' or less than '2023-01-01T00:00:00Z' [timestamp.gt_lt_exclusive]\n     *   google.protobuf.Timestamp other_value = 3 [(buf.validate.field).timestamp = { gt: { seconds: 1672531200 }, lt: { seconds: 1672444800 } }];\n     * }\n     * ```\n     *\n     * @generated from field: google.protobuf.Timestamp gt = 5;\n     */\n    value: Timestamp;\n    case: \"gt\";\n  } | {\n    /**\n     * `gte` requires the timestamp field value to be greater than or equal to the\n     * specified value (exclusive). If the value of `gte` is larger than a\n     * specified `lt` or `lte`, the range is reversed, and the field value\n     * must be outside the specified range. If the field value doesn't meet\n     * the required conditions, an error message is generated.\n     *\n     * ```proto\n     * message MyTimestamp {\n     *   // timestamp must be greater than or equal to '2023-01-01T00:00:00Z' [timestamp.gte]\n     *   google.protobuf.Timestamp value = 1 [(buf.validate.field).timestamp.gte = { seconds: 1672444800 }];\n     *\n     *   // timestamp must be greater than or equal to '2023-01-01T00:00:00Z' and less than '2023-01-02T00:00:00Z' [timestamp.gte_lt]\n     *   google.protobuf.Timestamp another_value = 2 [(buf.validate.field).timestamp = { gte: { seconds: 1672444800 }, lt: { seconds: 1672531200 } }];\n     *\n     *   // timestamp must be greater than or equal to '2023-01-02T00:00:00Z' or less than '2023-01-01T00:00:00Z' [timestamp.gte_lt_exclusive]\n     *   google.protobuf.Timestamp other_value = 3 [(buf.validate.field).timestamp = { gte: { seconds: 1672531200 }, lt: { seconds: 1672444800 } }];\n     * }\n     * ```\n     *\n     * @generated from field: google.protobuf.Timestamp gte = 6;\n     */\n    value: Timestamp;\n    case: \"gte\";\n  } | {\n    /**\n     * `gt_now` specifies that this field, of the `google.protobuf.Timestamp` type, must be greater than the current time. `gt_now` can only be used with the `within` rule.\n     *\n     * ```proto\n     * message MyTimestamp {\n     *   // value must be greater than now\n     *   google.protobuf.Timestamp created_at = 1 [(buf.validate.field).timestamp.gt_now = true];\n     * }\n     * ```\n     *\n     * @generated from field: bool gt_now = 8;\n     */\n    value: boolean;\n    case: \"gtNow\";\n  } | { case: undefined; value?: undefined } = { case: undefined };\n\n  /**\n   * `within` specifies that this field, of the `google.protobuf.Timestamp` type, must be within the specified duration of the current time. If the field value isn't within the duration, an error message is generated.\n   *\n   * ```proto\n   * message MyTimestamp {\n   *   // value must be within 1 hour of now\n   *   google.protobuf.Timestamp created_at = 1 [(buf.validate.field).timestamp.within = {seconds: 3600}];\n   * }\n   * ```\n   *\n   * @generated from field: optional google.protobuf.Duration within = 9;\n   */\n  within?: Duration;\n\n  constructor(data?: PartialMessage<TimestampRules>) {\n    super();\n    proto3.util.initPartial(data, this);\n  }\n\n  static readonly runtime: typeof proto3 = proto3;\n  static readonly typeName = \"buf.validate.TimestampRules\";\n  static readonly fields: FieldList = proto3.util.newFieldList(() => [\n    { no: 2, name: \"const\", kind: \"message\", T: Timestamp, opt: true },\n    { no: 3, name: \"lt\", kind: \"message\", T: Timestamp, oneof: \"less_than\" },\n    { no: 4, name: \"lte\", kind: \"message\", T: Timestamp, oneof: \"less_than\" },\n    { no: 7, name: \"lt_now\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, oneof: \"less_than\" },\n    { no: 5, name: \"gt\", kind: \"message\", T: Timestamp, oneof: \"greater_than\" },\n    { no: 6, name: \"gte\", kind: \"message\", T: Timestamp, oneof: \"greater_than\" },\n    { no: 8, name: \"gt_now\", kind: \"scalar\", T: 8 /* ScalarType.BOOL */, oneof: \"greater_than\" },\n    { no: 9, name: \"within\", kind: \"message\", T: Duration, opt: true },\n  ]);\n\n  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimestampRules {\n    return new TimestampRules().fromBinary(bytes, options);\n  }\n\n  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimestampRules {\n    return new TimestampRules().fromJson(jsonValue, options);\n  }\n\n  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimestampRules {\n    return new TimestampRules().fromJsonString(jsonString, options);\n  }\n\n  static equals(a: TimestampRules | PlainMessage<TimestampRules> | undefined, b: TimestampRules | PlainMessage<TimestampRules> | undefined): boolean {\n    return proto3.util.equals(TimestampRules, a, b);\n  }\n}\n\n/**\n * Rules specify the validations to be performed on this message. By default,\n * no validation is performed against a message.\n *\n * @generated from extension: optional buf.validate.MessageConstraints message = 1159;\n */\nexport const message = proto3.makeExtension<MessageOptions, MessageConstraints>(\n  \"buf.validate.message\", \n  MessageOptions, \n  () => ({ no: 1159, kind: \"message\", T: MessageConstraints, opt: true }),\n);\n\n/**\n * Rules specify the validations to be performed on this oneof. By default,\n * no validation is performed against a oneof.\n *\n * @generated from extension: optional buf.validate.OneofConstraints oneof = 1159;\n */\nexport const oneof = proto3.makeExtension<OneofOptions, OneofConstraints>(\n  \"buf.validate.oneof\", \n  OneofOptions, \n  () => ({ no: 1159, kind: \"message\", T: OneofConstraints, opt: true }),\n);\n\n/**\n * Rules specify the validations to be performed on this field. By default,\n * no validation is performed against a field.\n *\n * @generated from extension: optional buf.validate.FieldConstraints field = 1159;\n */\nexport const field = proto3.makeExtension<FieldOptions, FieldConstraints>(\n  \"buf.validate.field\", \n  FieldOptions, \n  () => ({ no: 1159, kind: \"message\", T: FieldConstraints, opt: true }),\n);\n\n"],"mappings":"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","names":["Ignore","KnownRegex"]}